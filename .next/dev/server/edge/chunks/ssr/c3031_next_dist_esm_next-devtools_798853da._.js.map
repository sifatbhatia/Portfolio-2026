{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/use-app-dev-rendering-indicator.tsx"],"sourcesContent":["'use client'\n\nimport { useEffect, useTransition } from 'react'\nimport { dispatcher } from 'next/dist/compiled/next-devtools'\n\nexport const useAppDevRenderingIndicator = () => {\n  const [isPending, startTransition] = useTransition()\n\n  useEffect(() => {\n    if (isPending) {\n      dispatcher.renderingIndicatorShow()\n    } else {\n      dispatcher.renderingIndicatorHide()\n    }\n  }, [isPending])\n\n  return startTransition\n}\n"],"names":["useEffect","useTransition","dispatcher","useAppDevRenderingIndicator","isPending","startTransition","renderingIndicatorShow","renderingIndicatorHide"],"mappings":";;;;AAEA,SAASA,SAAS,EAAEC,aAAa,QAAQ,QAAO;AAChD,SAASC,UAAU,QAAQ,mCAAkC;AAH7D;;;AAKO,MAAMC,8BAA8B;IACzC,MAAM,CAACC,WAAWC,gBAAgB,OAAGJ,kMAAAA;QAErCD,8LAAAA,EAAU;QACR,IAAII,WAAW;YACbF,+MAAAA,CAAWI,sBAAsB;QACnC,OAAO;YACLJ,+MAAAA,CAAWK,sBAAsB;QACnC;IACF,GAAG;QAACH;KAAU;IAEd,OAAOC;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/shared/console-error.ts"],"sourcesContent":["// To distinguish from React error.digest, we use a different symbol here to determine if the error is from console.error or unhandled promise rejection.\nconst digestSym = Symbol.for('next.console.error.digest')\n\n// Represent non Error shape unhandled promise rejections or console.error errors.\n// Those errors will be captured and displayed in Error Overlay.\ntype ConsoleError = Error & {\n  [digestSym]: 'NEXT_CONSOLE_ERROR'\n  environmentName: string\n}\n\nexport function createConsoleError(\n  message: string | Error,\n  environmentName?: string | null\n): ConsoleError {\n  const error = (\n    typeof message === 'string' ? new Error(message) : message\n  ) as ConsoleError\n  error[digestSym] = 'NEXT_CONSOLE_ERROR'\n\n  if (environmentName && !error.environmentName) {\n    error.environmentName = environmentName\n  }\n\n  return error\n}\n\nexport const isConsoleError = (error: any): error is ConsoleError => {\n  return error && error[digestSym] === 'NEXT_CONSOLE_ERROR'\n}\n"],"names":["digestSym","Symbol","for","createConsoleError","message","environmentName","error","Error","isConsoleError"],"mappings":";;;;;;AAAA,yJAAyJ;AACzJ,MAAMA,YAAYC,OAAOC,GAAG,CAAC;AAStB,SAASC,mBACdC,OAAuB,EACvBC,eAA+B;IAE/B,MAAMC,QACJ,OAAOF,YAAY,WAAW,OAAA,cAAkB,CAAlB,IAAIG,MAAMH,UAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAiB,KAAIA;IAErDE,KAAK,CAACN,UAAU,GAAG;IAEnB,IAAIK,mBAAmB,CAACC,MAAMD,eAAe,EAAE;QAC7CC,MAAMD,eAAe,GAAGA;IAC1B;IAEA,OAAOC;AACT;AAEO,MAAME,iBAAiB,CAACF;IAC7B,OAAOA,SAASA,KAAK,CAACN,UAAU,KAAK;AACvC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/errors/stitched-error.ts"],"sourcesContent":["import React from 'react'\nimport isError from '../../../../lib/is-error'\n\nconst ownerStacks = new WeakMap<Error, string | null>()\n\nexport function getOwnerStack(error: Error): string | null | undefined {\n  return ownerStacks.get(error)\n}\nexport function setOwnerStack(error: Error, stack: string | null) {\n  ownerStacks.set(error, stack)\n}\n\nexport function coerceError(value: unknown): Error {\n  return isError(value) ? value : new Error('' + value)\n}\n\nexport function setOwnerStackIfAvailable(error: Error): void {\n  // React 18 and prod does not have `captureOwnerStack`\n  if ('captureOwnerStack' in React) {\n    setOwnerStack(error, React.captureOwnerStack())\n  }\n}\n\nexport function decorateDevError(thrownValue: unknown) {\n  const error = coerceError(thrownValue)\n  setOwnerStackIfAvailable(error)\n  return error\n}\n"],"names":["React","isError","ownerStacks","WeakMap","getOwnerStack","error","get","setOwnerStack","stack","set","coerceError","value","Error","setOwnerStackIfAvailable","captureOwnerStack","decorateDevError","thrownValue"],"mappings":";;;;;;;;;;;;AAAA,OAAOA,WAAW,QAAO;AACzB,OAAOC,aAAa,2BAA0B;;;AAE9C,MAAMC,cAAc,IAAIC;AAEjB,SAASC,cAAcC,KAAY;IACxC,OAAOH,YAAYI,GAAG,CAACD;AACzB;AACO,SAASE,cAAcF,KAAY,EAAEG,KAAoB;IAC9DN,YAAYO,GAAG,CAACJ,OAAOG;AACzB;AAEO,SAASE,YAAYC,KAAc;IACxC,WAAOV,2LAAAA,EAAQU,SAASA,QAAQ,OAAA,cAAqB,CAArB,IAAIC,MAAM,KAAKD,QAAf,qBAAA;eAAA;oBAAA;sBAAA;IAAoB;AACtD;AAEO,SAASE,yBAAyBR,KAAY;IACnD,sDAAsD;IACtD,IAAI,uBAAuBL,4LAAAA,EAAO;QAChCO,cAAcF,OAAOL,4LAAAA,CAAMc,iBAAiB;IAC9C;AACF;AAEO,SAASC,iBAAiBC,WAAoB;IACnD,MAAMX,QAAQK,YAAYM;IAC1BH,yBAAyBR;IACzB,OAAOA;AACT","ignoreList":[0]}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/terminal-logging-config.ts"],"sourcesContent":["export function getTerminalLoggingConfig():\n  | false\n  | boolean\n  | {\n      depthLimit?: number\n      edgeLimit?: number\n      showSourceLocation?: boolean\n    } {\n  try {\n    return JSON.parse(\n      process.env.__NEXT_BROWSER_DEBUG_INFO_IN_TERMINAL || 'false'\n    )\n  } catch {\n    return false\n  }\n}\n\nexport function getIsTerminalLoggingEnabled(): boolean {\n  const config = getTerminalLoggingConfig()\n  return Boolean(config)\n}\n"],"names":["getTerminalLoggingConfig","JSON","parse","process","env","__NEXT_BROWSER_DEBUG_INFO_IN_TERMINAL","getIsTerminalLoggingEnabled","config","Boolean"],"mappings":";;;;;;AAAO,SAASA;IAQd,IAAI;QACF,OAAOC,KAAKC,KAAK,CACfC,QAAQC,GAAG,CAACC,iCAAyC,IAAJ;IAErD,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAASC;IACd,MAAMC,SAASP;IACf,OAAOQ,QAAQD;AACjB","ignoreList":[0]}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/shared/forward-logs-shared.ts"],"sourcesContent":["export type LogMethod =\n  | 'log'\n  | 'info'\n  | 'debug'\n  | 'table'\n  | 'error'\n  | 'assert'\n  | 'dir'\n  | 'dirxml'\n  | 'group'\n  | 'groupCollapsed'\n  | 'groupEnd'\n  | 'trace'\n  | 'warn'\n\nexport type ConsoleEntry<T> = {\n  kind: 'console'\n  method: LogMethod\n  consoleMethodStack: string | null\n  args: Array<\n    | {\n        kind: 'arg'\n        data: T\n      }\n    | {\n        kind: 'formatted-error-arg'\n        prefix: string\n        stack: string\n      }\n  >\n}\n\nexport type ConsoleErrorEntry<T> = {\n  kind: 'any-logged-error'\n  method: 'error'\n  consoleErrorStack: string\n  args: Array<\n    | {\n        kind: 'arg'\n        data: T\n        isRejectionMessage?: boolean\n      }\n    | {\n        kind: 'formatted-error-arg'\n        prefix: string\n        stack: string | null\n      }\n  >\n}\n\nexport type FormattedErrorEntry = {\n  kind: 'formatted-error'\n  prefix: string\n  stack: string\n  method: 'error'\n}\n\nexport type ClientLogEntry =\n  | ConsoleEntry<unknown>\n  | ConsoleErrorEntry<unknown>\n  | FormattedErrorEntry\nexport type ServerLogEntry =\n  | ConsoleEntry<string>\n  | ConsoleErrorEntry<string>\n  | FormattedErrorEntry\n\nexport const UNDEFINED_MARKER = '__next_tagged_undefined'\n\n// Based on https://github.com/facebook/react/blob/28dc0776be2e1370fe217549d32aee2519f0cf05/packages/react-server/src/ReactFlightServer.js#L248\nexport function patchConsoleMethod<T extends keyof Console>(\n  methodName: T,\n  wrapper: (\n    methodName: T,\n    ...args: Console[T] extends (...args: infer P) => any ? P : never[]\n  ) => void\n): () => void {\n  const descriptor = Object.getOwnPropertyDescriptor(console, methodName)\n  if (\n    descriptor &&\n    (descriptor.configurable || descriptor.writable) &&\n    typeof descriptor.value === 'function'\n  ) {\n    const originalMethod = descriptor.value as Console[T] extends (\n      ...args: any[]\n    ) => any\n      ? Console[T]\n      : never\n    const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name')\n    const wrapperMethod = function (\n      this: typeof console,\n      ...args: Console[T] extends (...args: infer P) => any ? P : never[]\n    ) {\n      wrapper(methodName, ...args)\n\n      originalMethod.apply(this, args)\n    }\n    if (originalName) {\n      Object.defineProperty(wrapperMethod, 'name', originalName)\n    }\n    Object.defineProperty(console, methodName, {\n      value: wrapperMethod,\n    })\n\n    return () => {\n      Object.defineProperty(console, methodName, {\n        value: originalMethod,\n        writable: descriptor.writable,\n        configurable: descriptor.configurable,\n      })\n    }\n  }\n\n  return () => {}\n}\n"],"names":["UNDEFINED_MARKER","patchConsoleMethod","methodName","wrapper","descriptor","Object","getOwnPropertyDescriptor","console","configurable","writable","value","originalMethod","originalName","wrapperMethod","args","apply","defineProperty"],"mappings":";;;;;;AAkEO,MAAMA,mBAAmB,0BAAyB;AAGlD,SAASC,mBACdC,UAAa,EACbC,OAGS;IAET,MAAMC,aAAaC,OAAOC,wBAAwB,CAACC,SAASL;IAC5D,IACEE,cACCA,CAAAA,WAAWI,YAAY,IAAIJ,WAAWK,QAAO,KAC9C,OAAOL,WAAWM,KAAK,KAAK,YAC5B;QACA,MAAMC,iBAAiBP,WAAWM,KAAK;QAKvC,MAAME,eAAeP,OAAOC,wBAAwB,CAACK,gBAAgB;QACrE,MAAME,gBAAgB,SAEpB,GAAGC,IAAgE;YAEnEX,QAAQD,eAAeY;YAEvBH,eAAeI,KAAK,CAAC,IAAI,EAAED;QAC7B;QACA,IAAIF,cAAc;YAChBP,OAAOW,cAAc,CAACH,eAAe,QAAQD;QAC/C;QACAP,OAAOW,cAAc,CAACT,SAASL,YAAY;YACzCQ,OAAOG;QACT;QAEA,OAAO;YACLR,OAAOW,cAAc,CAACT,SAASL,YAAY;gBACzCQ,OAAOC;gBACPF,UAAUL,WAAWK,QAAQ;gBAC7BD,cAAcJ,WAAWI,YAAY;YACvC;QACF;IACF;IAEA,OAAO,KAAO;AAChB","ignoreList":[0]}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/forward-logs-utils.ts"],"sourcesContent":["import { configure } from 'next/dist/compiled/safe-stable-stringify'\nimport { getTerminalLoggingConfig } from './terminal-logging-config'\nimport { UNDEFINED_MARKER } from '../../shared/forward-logs-shared'\n\nconst terminalLoggingConfig = getTerminalLoggingConfig()\n\nconst PROMISE_MARKER = 'Promise {}'\nconst UNAVAILABLE_MARKER = '[Unable to view]'\n\nconst maximumDepth =\n  typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.depthLimit\n    ? terminalLoggingConfig.depthLimit\n    : 5\nconst maximumBreadth =\n  typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.edgeLimit\n    ? terminalLoggingConfig.edgeLimit\n    : 100\n\nexport const safeStringifyWithDepth = configure({\n  maximumDepth,\n  maximumBreadth,\n})\n\n/**\n * allows us to:\n * - revive the undefined log in the server as it would look in the browser\n * - not read/attempt to serialize promises (next will console error if you do that, and will cause this program to infinitely recurse)\n * - if we read a proxy that throws (no way to detect if something is a proxy), explain to the user we can't read this data\n */\nexport function preLogSerializationClone<T>(\n  value: T,\n  seen = new WeakMap()\n): any {\n  if (value === undefined) return UNDEFINED_MARKER\n  if (value === null || typeof value !== 'object') return value\n  if (seen.has(value as object)) return seen.get(value as object)\n\n  try {\n    Object.keys(value as object)\n  } catch {\n    return UNAVAILABLE_MARKER\n  }\n\n  try {\n    if (typeof (value as any).then === 'function') return PROMISE_MARKER\n  } catch {\n    return UNAVAILABLE_MARKER\n  }\n\n  if (Array.isArray(value)) {\n    const out: any[] = []\n    seen.set(value, out)\n    for (const item of value) {\n      try {\n        out.push(preLogSerializationClone(item, seen))\n      } catch {\n        out.push(UNAVAILABLE_MARKER)\n      }\n    }\n    return out\n  }\n\n  const proto = Object.getPrototypeOf(value)\n  if (proto === Object.prototype || proto === null) {\n    const out: Record<string, unknown> = {}\n    seen.set(value as object, out)\n    for (const key of Object.keys(value as object)) {\n      try {\n        out[key] = preLogSerializationClone((value as any)[key], seen)\n      } catch {\n        out[key] = UNAVAILABLE_MARKER\n      }\n    }\n    return out\n  }\n\n  return Object.prototype.toString.call(value)\n}\n\n// only safe if passed safeClone data\nexport const logStringify = (data: unknown): string => {\n  try {\n    const result = safeStringifyWithDepth(data)\n    return result ?? `\"${UNAVAILABLE_MARKER}\"`\n  } catch {\n    return `\"${UNAVAILABLE_MARKER}\"`\n  }\n}\n"],"names":["configure","getTerminalLoggingConfig","UNDEFINED_MARKER","terminalLoggingConfig","PROMISE_MARKER","UNAVAILABLE_MARKER","maximumDepth","depthLimit","maximumBreadth","edgeLimit","safeStringifyWithDepth","preLogSerializationClone","value","seen","WeakMap","undefined","has","get","Object","keys","then","Array","isArray","out","set","item","push","proto","getPrototypeOf","prototype","key","toString","call","logStringify","data","result"],"mappings":";;;;;;;;AAAA,SAASA,SAAS,QAAQ,2CAA0C;AACpE,SAASC,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,gBAAgB,QAAQ,mCAAkC;;;;AAEnE,MAAMC,4BAAwBF,+PAAAA;AAE9B,MAAMG,iBAAiB;AACvB,MAAMC,qBAAqB;AAE3B,MAAMC,eACJ,OAAOH,0BAA0B,YAAYA,sBAAsBI,UAAU,GACzEJ,sBAAsBI,UAAU,GAChC;AACN,MAAMC,iBACJ,OAAOL,0BAA0B,YAAYA,sBAAsBM,SAAS,GACxEN,sBAAsBM,SAAS,GAC/B;AAEC,MAAMC,6BAAyBV,oNAAAA,EAAU;IAC9CM;IACAE;AACF,GAAE;AAQK,SAASG,yBACdC,KAAQ,EACRC,OAAO,IAAIC,SAAS;IAEpB,IAAIF,UAAUG,WAAW,OAAOb,yOAAAA;IAChC,IAAIU,UAAU,QAAQ,OAAOA,UAAU,UAAU,OAAOA;IACxD,IAAIC,KAAKG,GAAG,CAACJ,QAAkB,OAAOC,KAAKI,GAAG,CAACL;IAE/C,IAAI;QACFM,OAAOC,IAAI,CAACP;IACd,EAAE,OAAM;QACN,OAAOP;IACT;IAEA,IAAI;QACF,IAAI,OAAQO,MAAcQ,IAAI,KAAK,YAAY,OAAOhB;IACxD,EAAE,OAAM;QACN,OAAOC;IACT;IAEA,IAAIgB,MAAMC,OAAO,CAACV,QAAQ;QACxB,MAAMW,MAAa,EAAE;QACrBV,KAAKW,GAAG,CAACZ,OAAOW;QAChB,KAAK,MAAME,QAAQb,MAAO;YACxB,IAAI;gBACFW,IAAIG,IAAI,CAACf,yBAAyBc,MAAMZ;YAC1C,EAAE,OAAM;gBACNU,IAAIG,IAAI,CAACrB;YACX;QACF;QACA,OAAOkB;IACT;IAEA,MAAMI,QAAQT,OAAOU,cAAc,CAAChB;IACpC,IAAIe,UAAUT,OAAOW,SAAS,IAAIF,UAAU,MAAM;QAChD,MAAMJ,MAA+B,CAAC;QACtCV,KAAKW,GAAG,CAACZ,OAAiBW;QAC1B,KAAK,MAAMO,OAAOZ,OAAOC,IAAI,CAACP,OAAkB;YAC9C,IAAI;gBACFW,GAAG,CAACO,IAAI,GAAGnB,yBAA0BC,KAAa,CAACkB,IAAI,EAAEjB;YAC3D,EAAE,OAAM;gBACNU,GAAG,CAACO,IAAI,GAAGzB;YACb;QACF;QACA,OAAOkB;IACT;IAEA,OAAOL,OAAOW,SAAS,CAACE,QAAQ,CAACC,IAAI,CAACpB;AACxC;AAGO,MAAMqB,eAAe,CAACC;IAC3B,IAAI;QACF,MAAMC,SAASzB,uBAAuBwB;QACtC,OAAOC,UAAU,CAAC,CAAC,EAAE9B,mBAAmB,CAAC,CAAC;IAC5C,EAAE,OAAM;QACN,OAAO,CAAC,CAAC,EAAEA,mBAAmB,CAAC,CAAC;IAClC;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/forward-logs.ts"],"sourcesContent":["import {\n  getOwnerStack,\n  setOwnerStackIfAvailable,\n} from './errors/stitched-error'\nimport { getErrorSource } from '../../../shared/lib/error-source'\nimport { getIsTerminalLoggingEnabled } from './terminal-logging-config'\nimport {\n  type ConsoleEntry,\n  type ConsoleErrorEntry,\n  type FormattedErrorEntry,\n  type ClientLogEntry,\n  type LogMethod,\n  patchConsoleMethod,\n} from '../../shared/forward-logs-shared'\nimport {\n  preLogSerializationClone,\n  logStringify,\n  safeStringifyWithDepth,\n} from './forward-logs-utils'\n\n// Client-side file logger for browser logs\nclass ClientFileLogger {\n  private logEntries: Array<{\n    timestamp: string\n    level: string // log level\n    message: string // log message\n  }> = []\n\n  private formatTimestamp(): string {\n    const now = new Date()\n    const hours = now.getHours().toString().padStart(2, '0')\n    const minutes = now.getMinutes().toString().padStart(2, '0')\n    const seconds = now.getSeconds().toString().padStart(2, '0')\n    const milliseconds = now.getMilliseconds().toString().padStart(3, '0')\n\n    return `${hours}:${minutes}:${seconds}.${milliseconds}`\n  }\n\n  log(level: string, args: any[]): void {\n    if (isReactServerReplayedLog(args)) {\n      return\n    }\n\n    // Format the args into a message string\n    const message = args\n      .map((arg) => {\n        if (typeof arg === 'string') return arg\n        if (typeof arg === 'number' || typeof arg === 'boolean')\n          return String(arg)\n        if (arg === null) return 'null'\n        if (arg === undefined) return 'undefined'\n        // Handle DOM nodes - only log the tag name to avoid React proxied elements\n        if (arg instanceof Element) {\n          return `<${arg.tagName.toLowerCase()}>`\n        }\n        return safeStringifyWithDepth(arg)\n      })\n      .join(' ')\n\n    const logEntry = {\n      timestamp: this.formatTimestamp(),\n      level: level.toUpperCase(),\n      message,\n    }\n    this.logEntries.push(logEntry)\n\n    // Schedule flush when new log is added\n    scheduleLogFlush()\n  }\n  getLogs(): Array<{ timestamp: string; level: string; message: string }> {\n    return [...this.logEntries]\n  }\n\n  clear(): void {\n    this.logEntries = []\n  }\n}\n\nconst clientFileLogger = new ClientFileLogger()\n\n// Set up flush-based sending of client file logs\nlet logFlushTimeout: NodeJS.Timeout | null = null\nlet heartbeatInterval: NodeJS.Timeout | null = null\n\nconst scheduleLogFlush = () => {\n  if (logFlushTimeout) {\n    clearTimeout(logFlushTimeout)\n  }\n\n  logFlushTimeout = setTimeout(() => {\n    sendClientFileLogs()\n    logFlushTimeout = null\n  }, 100) // Send after 100ms (much faster with debouncing)\n}\n\nconst cancelLogFlush = () => {\n  if (logFlushTimeout) {\n    clearTimeout(logFlushTimeout)\n    logFlushTimeout = null\n  }\n}\n\nconst startHeartbeat = () => {\n  if (heartbeatInterval) return\n\n  heartbeatInterval = setInterval(() => {\n    if (logQueue.socket && logQueue.socket.readyState === WebSocket.OPEN) {\n      try {\n        // Send a ping to keep the connection alive\n        logQueue.socket.send(JSON.stringify({ event: 'ping' }))\n      } catch (error) {\n        // Connection might be closed, stop heartbeat\n        stopHeartbeat()\n      }\n    } else {\n      stopHeartbeat()\n    }\n  }, 5000) // Send ping every 5 seconds\n}\n\nconst stopHeartbeat = () => {\n  if (heartbeatInterval) {\n    clearInterval(heartbeatInterval)\n    heartbeatInterval = null\n  }\n}\n\nconst isTerminalLoggingEnabled = getIsTerminalLoggingEnabled()\n\nconst methods: Array<LogMethod> = [\n  'log',\n  'info',\n  'warn',\n  'debug',\n  'table',\n  'assert',\n  'dir',\n  'dirxml',\n  'group',\n  'groupCollapsed',\n  'groupEnd',\n  'trace',\n]\n\nconst afterThisFrame = (cb: () => void) => {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const rafId = requestAnimationFrame(() => {\n    timeout = setTimeout(() => {\n      cb()\n    })\n  })\n\n  return () => {\n    cancelAnimationFrame(rafId)\n    clearTimeout(timeout)\n  }\n}\n\nlet isPatched = false\n\nconst serializeEntries = (entries: Array<ClientLogEntry>) =>\n  entries.map((clientEntry) => {\n    switch (clientEntry.kind) {\n      case 'any-logged-error':\n      case 'console': {\n        return {\n          ...clientEntry,\n          args: clientEntry.args.map(stringifyUserArg),\n        }\n      }\n      case 'formatted-error': {\n        return clientEntry\n      }\n      default: {\n        return null!\n      }\n    }\n  })\n\n// Function to send client file logs to server\nconst sendClientFileLogs = () => {\n  if (!logQueue.socket || logQueue.socket.readyState !== WebSocket.OPEN) {\n    return\n  }\n\n  const logs = clientFileLogger.getLogs()\n  if (logs.length === 0) {\n    return\n  }\n\n  try {\n    const payload = JSON.stringify({\n      event: 'client-file-logs',\n      logs: logs,\n    })\n\n    logQueue.socket.send(payload)\n  } catch (error) {\n    console.error(error)\n  } finally {\n    // Clear logs regardless of send success to prevent memory leaks\n    clientFileLogger.clear()\n  }\n}\n\n// Combined state and public API\nexport const logQueue: {\n  entries: Array<ClientLogEntry>\n  onSocketReady: (socket: WebSocket) => void\n  flushScheduled: boolean\n  socket: WebSocket | null\n  cancelFlush: (() => void) | null\n  sourceType?: 'server' | 'edge-server'\n  router: 'app' | 'pages' | null\n  scheduleLogSend: (entry: ClientLogEntry) => void\n} = {\n  entries: [],\n  flushScheduled: false,\n  cancelFlush: null,\n  socket: null,\n  sourceType: undefined,\n  router: null,\n  scheduleLogSend: (entry: ClientLogEntry) => {\n    logQueue.entries.push(entry)\n    if (logQueue.flushScheduled) {\n      return\n    }\n    // safe to deref and use in setTimeout closure since we cancel on new socket\n    const socket = logQueue.socket\n    if (!socket) {\n      return\n    }\n\n    // we probably dont need this\n    logQueue.flushScheduled = true\n\n    // non blocking log flush, runs at most once per frame\n    logQueue.cancelFlush = afterThisFrame(() => {\n      logQueue.flushScheduled = false\n\n      // just incase\n      try {\n        const payload = JSON.stringify({\n          event: 'browser-logs',\n          entries: serializeEntries(logQueue.entries),\n          router: logQueue.router,\n          // needed for source mapping, we just assign the sourceType from the last error for the whole batch\n          sourceType: logQueue.sourceType,\n        })\n\n        socket.send(payload)\n        logQueue.entries = []\n        logQueue.sourceType = undefined\n\n        // Also send client file logs\n        sendClientFileLogs()\n      } catch {\n        // error (make sure u don't infinite loop)\n        /* noop */\n      }\n    })\n  },\n  onSocketReady: (socket: WebSocket) => {\n    // When MCP or terminal logging is enabled, we enable the socket connection,\n    // otherwise it will not proceed.\n    if (!isTerminalLoggingEnabled && !process.env.__NEXT_MCP_SERVER) {\n      return\n    }\n    if (socket.readyState !== WebSocket.OPEN) {\n      // invariant\n      return\n    }\n\n    // incase an existing timeout was going to run with a stale socket\n    logQueue.cancelFlush?.()\n    logQueue.socket = socket\n\n    // Add socket event listeners to track connection state\n    socket.addEventListener('close', () => {\n      cancelLogFlush()\n      stopHeartbeat()\n    })\n\n    // Only send terminal logs if enabled\n    if (isTerminalLoggingEnabled) {\n      try {\n        const payload = JSON.stringify({\n          event: 'browser-logs',\n          entries: serializeEntries(logQueue.entries),\n          router: logQueue.router,\n          sourceType: logQueue.sourceType,\n        })\n\n        socket.send(payload)\n        logQueue.entries = []\n        logQueue.sourceType = undefined\n      } catch {\n        /** noop just incase */\n      }\n    }\n\n    // Always send client file logs when socket is ready\n    sendClientFileLogs()\n\n    // Start heartbeat to keep connection alive\n    startHeartbeat()\n  },\n}\n\nconst stringifyUserArg = (\n  arg:\n    | {\n        kind: 'arg'\n        data: unknown\n      }\n    | {\n        kind: 'formatted-error-arg'\n      }\n) => {\n  if (arg.kind !== 'arg') {\n    return arg\n  }\n  return {\n    ...arg,\n    data: logStringify(arg.data),\n  }\n}\n\nconst createErrorArg = (error: Error) => {\n  const stack = stackWithOwners(error)\n  return {\n    kind: 'formatted-error-arg' as const,\n    prefix: error.message ? `${error.name}: ${error.message}` : `${error.name}`,\n    stack,\n  }\n}\n\nconst createLogEntry = (level: LogMethod, args: any[]) => {\n  // Always log to client file logger with args (formatting done inside log method)\n  clientFileLogger.log(level, args)\n\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  // do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers\n  // error capture stack trace maybe\n  const stack = stackWithOwners(new Error())\n  const stackLines = stack?.split('\\n')\n  const cleanStack = stackLines?.slice(3).join('\\n') // this is probably ignored anyways\n  const entry: ConsoleEntry<unknown> = {\n    kind: 'console',\n    consoleMethodStack: cleanStack ?? null, // depending on browser we might not have stack\n    method: level,\n    args: args.map((arg) => {\n      if (arg instanceof Error) {\n        return createErrorArg(arg)\n      }\n      return {\n        kind: 'arg',\n        data: preLogSerializationClone(arg),\n      }\n    }),\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nexport const forwardErrorLog = (args: any[]) => {\n  // Always log to client file logger with args (formatting done inside log method)\n  clientFileLogger.log('error', args)\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  const errorObjects = args.filter((arg) => arg instanceof Error)\n  const first = errorObjects.at(0)\n  if (first) {\n    const source = getErrorSource(first)\n    if (source) {\n      logQueue.sourceType = source\n    }\n  }\n  /**\n   * browser shows stack regardless of type of data passed to console.error, so we should do the same\n   *\n   * do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers\n   */\n  const stack = stackWithOwners(new Error())\n  const stackLines = stack?.split('\\n')\n  const cleanStack = stackLines?.slice(3).join('\\n')\n\n  const entry: ConsoleErrorEntry<unknown> = {\n    kind: 'any-logged-error',\n    method: 'error',\n    consoleErrorStack: cleanStack ?? '',\n    args: args.map((arg) => {\n      if (arg instanceof Error) {\n        return createErrorArg(arg)\n      }\n      return {\n        kind: 'arg',\n        data: preLogSerializationClone(arg),\n      }\n    }),\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst createUncaughtErrorEntry = (\n  errorName: string,\n  errorMessage: string,\n  fullStack: string\n) => {\n  const entry: FormattedErrorEntry = {\n    kind: 'formatted-error',\n    prefix: `Uncaught ${errorName}: ${errorMessage}`,\n    stack: fullStack,\n    method: 'error',\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst stackWithOwners = (error: Error) => {\n  let ownerStack = ''\n  setOwnerStackIfAvailable(error)\n  ownerStack = getOwnerStack(error) || ''\n  const stack = (error.stack || '') + ownerStack\n  return stack\n}\n\nexport function logUnhandledRejection(reason: unknown) {\n  // Always log to client file logger\n  const message =\n    reason instanceof Error\n      ? `${reason.name}: ${reason.message}`\n      : JSON.stringify(reason)\n  clientFileLogger.log('error', [`unhandledRejection: ${message}`])\n\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  if (reason instanceof Error) {\n    createUnhandledRejectionErrorEntry(reason, stackWithOwners(reason))\n    return\n  }\n  createUnhandledRejectionNonErrorEntry(reason)\n}\n\nconst createUnhandledRejectionErrorEntry = (\n  error: Error,\n  fullStack: string\n) => {\n  const source = getErrorSource(error)\n  if (source) {\n    logQueue.sourceType = source\n  }\n\n  const entry: ClientLogEntry = {\n    kind: 'formatted-error',\n    prefix: `тип unhandledRejection: ${error.name}: ${error.message}`,\n    stack: fullStack,\n    method: 'error',\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst createUnhandledRejectionNonErrorEntry = (reason: unknown) => {\n  const entry: ClientLogEntry = {\n    kind: 'any-logged-error',\n    // we can't access the stack since the event is dispatched async and creating an inline error would be meaningless\n    consoleErrorStack: '',\n    method: 'error',\n    args: [\n      {\n        kind: 'arg',\n        data: `тип unhandledRejection:`,\n        isRejectionMessage: true,\n      },\n      {\n        kind: 'arg',\n        data: preLogSerializationClone(reason),\n      },\n    ],\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst isHMR = (args: any[]) => {\n  const firstArg = args[0]\n  if (typeof firstArg !== 'string') {\n    return false\n  }\n  if (firstArg.startsWith('[Fast Refresh]')) {\n    return true\n  }\n\n  if (firstArg.startsWith('[HMR]')) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Matches the format of logs arguments React replayed from the RSC.\n */\nconst isReactServerReplayedLog = (args: any[]) => {\n  if (args.length < 3) {\n    return false\n  }\n\n  const [format, styles, label] = args\n\n  if (\n    typeof format !== 'string' ||\n    typeof styles !== 'string' ||\n    typeof label !== 'string'\n  ) {\n    return false\n  }\n\n  return format.startsWith('%c%s%c') && styles.includes('background:')\n}\n\nexport function forwardUnhandledError(error: Error) {\n  // Always log to client file logger\n  clientFileLogger.log('error', [\n    `uncaughtError: ${error.name}: ${error.message}`,\n  ])\n\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  createUncaughtErrorEntry(error.name, error.message, stackWithOwners(error))\n}\n\n// TODO: this router check is brittle, we need to update based on the current router the user is using\nexport const initializeDebugLogForwarding = (router: 'app' | 'pages'): void => {\n  // probably don't need this\n  if (isPatched) {\n    return\n  }\n  // TODO(rob): why does this break rendering on server, important to know incase the same bug appears in browser\n  if (typeof window === 'undefined') {\n    return\n  }\n\n  // better to be safe than sorry\n  try {\n    methods.forEach((method) =>\n      patchConsoleMethod(method, (_, ...args) => {\n        if (isHMR(args)) {\n          return\n        }\n        if (isReactServerReplayedLog(args)) {\n          return\n        }\n        createLogEntry(method, args)\n      })\n    )\n  } catch {}\n  logQueue.router = router\n  isPatched = true\n\n  // Cleanup on page unload\n  window.addEventListener('beforeunload', () => {\n    cancelLogFlush()\n    stopHeartbeat()\n    // Send any remaining logs before page unloads\n    sendClientFileLogs()\n  })\n}\n"],"names":["getOwnerStack","setOwnerStackIfAvailable","getErrorSource","getIsTerminalLoggingEnabled","patchConsoleMethod","preLogSerializationClone","logStringify","safeStringifyWithDepth","ClientFileLogger","formatTimestamp","now","Date","hours","getHours","toString","padStart","minutes","getMinutes","seconds","getSeconds","milliseconds","getMilliseconds","log","level","args","isReactServerReplayedLog","message","map","arg","String","undefined","Element","tagName","toLowerCase","join","logEntry","timestamp","toUpperCase","logEntries","push","scheduleLogFlush","getLogs","clear","clientFileLogger","logFlushTimeout","heartbeatInterval","clearTimeout","setTimeout","sendClientFileLogs","cancelLogFlush","startHeartbeat","setInterval","logQueue","socket","readyState","WebSocket","OPEN","send","JSON","stringify","event","error","stopHeartbeat","clearInterval","isTerminalLoggingEnabled","methods","afterThisFrame","cb","timeout","rafId","requestAnimationFrame","cancelAnimationFrame","isPatched","serializeEntries","entries","clientEntry","kind","stringifyUserArg","logs","length","payload","console","flushScheduled","cancelFlush","sourceType","router","scheduleLogSend","entry","onSocketReady","process","env","__NEXT_MCP_SERVER","addEventListener","data","createErrorArg","stack","stackWithOwners","prefix","name","createLogEntry","Error","stackLines","split","cleanStack","slice","consoleMethodStack","method","forwardErrorLog","errorObjects","filter","first","at","source","consoleErrorStack","createUncaughtErrorEntry","errorName","errorMessage","fullStack","ownerStack","logUnhandledRejection","reason","createUnhandledRejectionErrorEntry","createUnhandledRejectionNonErrorEntry","isRejectionMessage","isHMR","firstArg","startsWith","format","styles","label","includes","forwardUnhandledError","initializeDebugLogForwarding","window","forEach","_"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 699, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/errors/use-error-handler.ts"],"sourcesContent":["import { useEffect } from 'react'\nimport { isNextRouterError } from '../../../../client/components/is-next-router-error'\nimport {\n  formatConsoleArgs,\n  parseConsoleArgs,\n} from '../../../../client/lib/console'\nimport isError from '../../../../lib/is-error'\nimport { createConsoleError } from '../../../shared/console-error'\nimport { coerceError, setOwnerStackIfAvailable } from './stitched-error'\nimport { forwardUnhandledError, logUnhandledRejection } from '../forward-logs'\n\nconst queueMicroTask =\n  globalThis.queueMicrotask || ((cb: () => void) => Promise.resolve().then(cb))\n\ntype ErrorHandler = (error: Error) => void\n\nconst errorQueue: Array<Error> = []\nconst errorHandlers: Array<ErrorHandler> = []\nconst rejectionQueue: Array<Error> = []\nconst rejectionHandlers: Array<ErrorHandler> = []\n\nexport function handleConsoleError(\n  originError: unknown,\n  consoleErrorArgs: any[]\n) {\n  let error: Error\n  const { environmentName } = parseConsoleArgs(consoleErrorArgs)\n  if (isError(originError)) {\n    error = createConsoleError(originError, environmentName)\n  } else {\n    error = createConsoleError(\n      formatConsoleArgs(consoleErrorArgs),\n      environmentName\n    )\n  }\n  setOwnerStackIfAvailable(error)\n\n  errorQueue.push(error)\n  for (const handler of errorHandlers) {\n    // Delayed the error being passed to React Dev Overlay,\n    // avoid the state being synchronously updated in the component.\n    queueMicroTask(() => {\n      handler(error)\n    })\n  }\n}\n\nexport function handleClientError(error: Error) {\n  errorQueue.push(error)\n  for (const handler of errorHandlers) {\n    // Delayed the error being passed to React Dev Overlay,\n    // avoid the state being synchronously updated in the component.\n    queueMicroTask(() => {\n      handler(error)\n    })\n  }\n}\n\nexport function useErrorHandler(\n  handleOnUnhandledError: ErrorHandler,\n  handleOnUnhandledRejection: ErrorHandler\n) {\n  useEffect(() => {\n    // Handle queued errors.\n    errorQueue.forEach(handleOnUnhandledError)\n    rejectionQueue.forEach(handleOnUnhandledRejection)\n\n    // Listen to new errors.\n    errorHandlers.push(handleOnUnhandledError)\n    rejectionHandlers.push(handleOnUnhandledRejection)\n\n    return () => {\n      // Remove listeners.\n      errorHandlers.splice(errorHandlers.indexOf(handleOnUnhandledError), 1)\n      rejectionHandlers.splice(\n        rejectionHandlers.indexOf(handleOnUnhandledRejection),\n        1\n      )\n\n      // Reset error queues.\n      errorQueue.splice(0, errorQueue.length)\n      rejectionQueue.splice(0, rejectionQueue.length)\n    }\n  }, [handleOnUnhandledError, handleOnUnhandledRejection])\n}\n\nfunction onUnhandledError(event: WindowEventMap['error']): void | boolean {\n  const thrownValue: unknown = event.error\n  if (isNextRouterError(thrownValue)) {\n    event.preventDefault()\n    return false\n  }\n  // When there's an error property present, we log the error to error overlay.\n  // Otherwise we don't do anything as it's not logging in the console either.\n  if (thrownValue) {\n    const error = coerceError(thrownValue)\n    setOwnerStackIfAvailable(error)\n    handleClientError(error)\n    forwardUnhandledError(error)\n  }\n}\n\nfunction onUnhandledRejection(ev: WindowEventMap['unhandledrejection']): void {\n  const reason: unknown = ev?.reason\n  if (isNextRouterError(reason)) {\n    ev.preventDefault()\n    return\n  }\n\n  const error = coerceError(reason)\n  setOwnerStackIfAvailable(error)\n\n  rejectionQueue.push(error)\n  for (const handler of rejectionHandlers) {\n    handler(error)\n  }\n\n  logUnhandledRejection(reason)\n}\n\nexport function handleGlobalErrors() {\n  if (typeof window !== 'undefined') {\n    try {\n      // Increase the number of stack frames on the client\n      Error.stackTraceLimit = 50\n    } catch {}\n\n    window.addEventListener('error', onUnhandledError)\n    window.addEventListener('unhandledrejection', onUnhandledRejection)\n  }\n}\n"],"names":["useEffect","isNextRouterError","formatConsoleArgs","parseConsoleArgs","isError","createConsoleError","coerceError","setOwnerStackIfAvailable","forwardUnhandledError","logUnhandledRejection","queueMicroTask","globalThis","queueMicrotask","cb","Promise","resolve","then","errorQueue","errorHandlers","rejectionQueue","rejectionHandlers","handleConsoleError","originError","consoleErrorArgs","error","environmentName","push","handler","handleClientError","useErrorHandler","handleOnUnhandledError","handleOnUnhandledRejection","forEach","splice","indexOf","length","onUnhandledError","event","thrownValue","preventDefault","onUnhandledRejection","ev","reason","handleGlobalErrors","window","Error","stackTraceLimit","addEventListener"],"mappings":";;;;;;;;;;AAAA,SAASA,SAAS,QAAQ,QAAO;AACjC,SAASC,iBAAiB,QAAQ,qDAAoD;AACtF,SACEC,iBAAiB,EACjBC,gBAAgB,QACX,iCAAgC;AACvC,OAAOC,aAAa,2BAA0B;AAC9C,SAASC,kBAAkB,QAAQ,gCAA+B;AAClE,SAASC,WAAW,EAAEC,wBAAwB,QAAQ,mBAAkB;AACxE,SAASC,qBAAqB,EAAEC,qBAAqB,QAAQ,kBAAiB;;;;;;;;AAE9E,MAAMC,iBACJC,WAAWC,cAAc,IAAK,CAAA,CAACC,KAAmBC,QAAQC,OAAO,GAAGC,IAAI,CAACH,GAAE;AAI7E,MAAMI,aAA2B,EAAE;AACnC,MAAMC,gBAAqC,EAAE;AAC7C,MAAMC,iBAA+B,EAAE;AACvC,MAAMC,oBAAyC,EAAE;AAE1C,SAASC,mBACdC,WAAoB,EACpBC,gBAAuB;IAEvB,IAAIC;IACJ,MAAM,EAAEC,eAAe,EAAE,OAAGtB,0MAAAA,EAAiBoB;IAC7C,QAAInB,2LAAAA,EAAQkB,cAAc;QACxBE,YAAQnB,kOAAAA,EAAmBiB,aAAaG;IAC1C,OAAO;QACLD,YAAQnB,kOAAAA,MACNH,2MAAAA,EAAkBqB,mBAClBE;IAEJ;QACAlB,6PAAAA,EAAyBiB;IAEzBP,WAAWS,IAAI,CAACF;IAChB,KAAK,MAAMG,WAAWT,cAAe;QACnC,uDAAuD;QACvD,gEAAgE;QAChER,eAAe;YACbiB,QAAQH;QACV;IACF;AACF;AAEO,SAASI,kBAAkBJ,KAAY;IAC5CP,WAAWS,IAAI,CAACF;IAChB,KAAK,MAAMG,WAAWT,cAAe;QACnC,uDAAuD;QACvD,gEAAgE;QAChER,eAAe;YACbiB,QAAQH;QACV;IACF;AACF;AAEO,SAASK,gBACdC,sBAAoC,EACpCC,0BAAwC;QAExC/B,8LAAAA,EAAU;QACR,wBAAwB;QACxBiB,WAAWe,OAAO,CAACF;QACnBX,eAAea,OAAO,CAACD;QAEvB,wBAAwB;QACxBb,cAAcQ,IAAI,CAACI;QACnBV,kBAAkBM,IAAI,CAACK;QAEvB,OAAO;YACL,oBAAoB;YACpBb,cAAce,MAAM,CAACf,cAAcgB,OAAO,CAACJ,yBAAyB;YACpEV,kBAAkBa,MAAM,CACtBb,kBAAkBc,OAAO,CAACH,6BAC1B;YAGF,sBAAsB;YACtBd,WAAWgB,MAAM,CAAC,GAAGhB,WAAWkB,MAAM;YACtChB,eAAec,MAAM,CAAC,GAAGd,eAAegB,MAAM;QAChD;IACF,GAAG;QAACL;QAAwBC;KAA2B;AACzD;AAEA,SAASK,iBAAiBC,KAA8B;IACtD,MAAMC,cAAuBD,MAAMb,KAAK;IACxC,QAAIvB,wOAAAA,EAAkBqC,cAAc;QAClCD,MAAME,cAAc;QACpB,OAAO;IACT;IACA,6EAA6E;IAC7E,4EAA4E;IAC5E,IAAID,aAAa;QACf,MAAMd,YAAQlB,gPAAAA,EAAYgC;YAC1B/B,6PAAAA,EAAyBiB;QACzBI,kBAAkBJ;YAClBhB,8OAAAA,EAAsBgB;IACxB;AACF;AAEA,SAASgB,qBAAqBC,EAAwC;IACpE,MAAMC,SAAkBD,IAAIC;IAC5B,QAAIzC,wOAAAA,EAAkByC,SAAS;QAC7BD,GAAGF,cAAc;QACjB;IACF;IAEA,MAAMf,YAAQlB,gPAAAA,EAAYoC;QAC1BnC,6PAAAA,EAAyBiB;IAEzBL,eAAeO,IAAI,CAACF;IACpB,KAAK,MAAMG,WAAWP,kBAAmB;QACvCO,QAAQH;IACV;QAEAf,8OAAAA,EAAsBiC;AACxB;AAEO,SAASC;IACd,IAAI,OAAOC,WAAW,aAAa;;AASrC","ignoreList":[0]}},
    {"offset": {"line": 814, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/errors/replay-ssr-only-errors.tsx"],"sourcesContent":["import { useEffect } from 'react'\nimport { handleClientError } from './use-error-handler'\nimport { isNextRouterError } from '../../../../client/components/is-next-router-error'\nimport { MISSING_ROOT_TAGS_ERROR } from '../../../../shared/lib/errors/constants'\n\nfunction readSsrError(): (Error & { digest?: string }) | null {\n  if (typeof document === 'undefined') {\n    return null\n  }\n\n  const ssrErrorTemplateTag = document.querySelector(\n    'template[data-next-error-message]'\n  )\n  if (ssrErrorTemplateTag) {\n    const message: string = ssrErrorTemplateTag.getAttribute(\n      'data-next-error-message'\n    )!\n    const stack = ssrErrorTemplateTag.getAttribute('data-next-error-stack')\n    const digest = ssrErrorTemplateTag.getAttribute('data-next-error-digest')\n    const error = new Error(message)\n    if (digest) {\n      ;(error as any).digest = digest\n    }\n    // Skip Next.js SSR'd internal errors that which will be handled by the error boundaries.\n    if (isNextRouterError(error)) {\n      return null\n    }\n    error.stack = stack || ''\n    return error\n  }\n\n  return null\n}\n\n/**\n * Needs to be in the same error boundary as the shell.\n * If it commits, we know we recovered from an SSR error.\n * If it doesn't commit, we errored again and React will take care of error reporting.\n */\nexport function ReplaySsrOnlyErrors({\n  onBlockingError,\n}: {\n  onBlockingError: () => void\n}) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Need to read during render. The attributes will be gone after commit.\n    const ssrError = readSsrError()\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (ssrError !== null) {\n        // TODO(veil): Include original Owner Stack (NDX-905)\n        // TODO(veil): Mark as recoverable error\n        // TODO(veil): console.error\n        handleClientError(ssrError)\n\n        // If it's missing root tags, we can't recover, make it blocking.\n        if (ssrError.digest === MISSING_ROOT_TAGS_ERROR) {\n          onBlockingError()\n        }\n      }\n    }, [ssrError, onBlockingError])\n  }\n\n  return null\n}\n"],"names":["useEffect","handleClientError","isNextRouterError","MISSING_ROOT_TAGS_ERROR","readSsrError","document","ssrErrorTemplateTag","querySelector","message","getAttribute","stack","digest","error","Error","ReplaySsrOnlyErrors","onBlockingError","process","env","NODE_ENV","ssrError"],"mappings":";;;;AAAA,SAASA,SAAS,QAAQ,QAAO;AACjC,SAASC,iBAAiB,QAAQ,sBAAqB;AACvD,SAASC,iBAAiB,QAAQ,qDAAoD;AACtF,SAASC,uBAAuB,QAAQ,0CAAyC;;;;;AAEjF,SAASC;IACP,IAAI,OAAOC,aAAa,aAAa;QACnC,OAAO;IACT;IAEA,MAAMC,sBAAsBD,SAASE,aAAa,CAChD;IAEF,IAAID,qBAAqB;QACvB,MAAME,UAAkBF,oBAAoBG,YAAY,CACtD;QAEF,MAAMC,QAAQJ,oBAAoBG,YAAY,CAAC;QAC/C,MAAME,SAASL,oBAAoBG,YAAY,CAAC;QAChD,MAAMG,QAAQ,OAAA,cAAkB,CAAlB,IAAIC,MAAML,UAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAiB;QAC/B,IAAIG,QAAQ;;YACRC,MAAcD,MAAM,GAAGA;QAC3B;QACA,yFAAyF;QACzF,QAAIT,wOAAAA,EAAkBU,QAAQ;YAC5B,OAAO;QACT;QACAA,MAAMF,KAAK,GAAGA,SAAS;QACvB,OAAOE;IACT;IAEA,OAAO;AACT;AAOO,SAASE,oBAAoB,EAClCC,eAAe,EAGhB;IACC,IAAIC,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,wEAAwE;QACxE,MAAMC,WAAWf;QACjB,sDAAsD;YACtDJ,8LAAAA,EAAU;YACR,IAAImB,aAAa,MAAM;gBACrB,qDAAqD;gBACrD,wCAAwC;gBACxC,4BAA4B;oBAC5BlB,4PAAAA,EAAkBkB;gBAElB,iEAAiE;gBACjE,IAAIA,SAASR,MAAM,KAAKR,6NAAAA,EAAyB;oBAC/CY;gBACF;YACF;QACF,GAAG;YAACI;YAAUJ;SAAgB;IAChC;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 880, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/segment-explorer-node.tsx"],"sourcesContent":["'use client'\n\nimport type { ReactNode } from 'react'\nimport {\n  useState,\n  createContext,\n  useContext,\n  use,\n  useMemo,\n  useCallback,\n} from 'react'\nimport { useLayoutEffect } from 'react'\nimport { dispatcher } from 'next/dist/compiled/next-devtools'\nimport { notFound } from '../../../client/components/not-found'\n\nexport type SegmentBoundaryType =\n  | 'not-found'\n  | 'error'\n  | 'loading'\n  | 'global-error'\n\nexport const SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE =\n  'NEXT_DEVTOOLS_SIMULATED_ERROR'\n\nexport type SegmentNodeState = {\n  type: string\n  pagePath: string\n  boundaryType: string | null\n  setBoundaryType: (type: SegmentBoundaryType | null) => void\n}\n\nfunction SegmentTrieNode({\n  type,\n  pagePath,\n}: {\n  type: string\n  pagePath: string\n}): React.ReactNode {\n  const { boundaryType, setBoundaryType } = useSegmentState()\n  const nodeState: SegmentNodeState = useMemo(() => {\n    return {\n      type,\n      pagePath,\n      boundaryType,\n      setBoundaryType,\n    }\n  }, [type, pagePath, boundaryType, setBoundaryType])\n\n  // Use `useLayoutEffect` to ensure the state is updated during suspense.\n  // `useEffect` won't work as the state is preserved during suspense.\n  useLayoutEffect(() => {\n    dispatcher.segmentExplorerNodeAdd(nodeState)\n    return () => {\n      dispatcher.segmentExplorerNodeRemove(nodeState)\n    }\n  }, [nodeState])\n\n  return null\n}\n\nfunction NotFoundSegmentNode(): React.ReactNode {\n  notFound()\n}\n\nfunction ErrorSegmentNode(): React.ReactNode {\n  throw new Error(SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE)\n}\n\nconst forever = new Promise(() => {})\nfunction LoadingSegmentNode(): React.ReactNode {\n  use(forever)\n  return null\n}\n\nexport function SegmentViewStateNode({ page }: { page: string }) {\n  useLayoutEffect(() => {\n    dispatcher.segmentExplorerUpdateRouteState(page)\n    return () => {\n      dispatcher.segmentExplorerUpdateRouteState('')\n    }\n  }, [page])\n  return null\n}\n\nexport function SegmentBoundaryTriggerNode() {\n  const { boundaryType } = useSegmentState()\n  let segmentNode: React.ReactNode = null\n  if (boundaryType === 'loading') {\n    segmentNode = <LoadingSegmentNode />\n  } else if (boundaryType === 'not-found') {\n    segmentNode = <NotFoundSegmentNode />\n  } else if (boundaryType === 'error') {\n    segmentNode = <ErrorSegmentNode />\n  }\n  return segmentNode\n}\n\nexport function SegmentViewNode({\n  type,\n  pagePath,\n  children,\n}: {\n  type: string\n  pagePath: string\n  children?: ReactNode\n}): React.ReactNode {\n  const segmentNode = (\n    <SegmentTrieNode key={type} type={type} pagePath={pagePath} />\n  )\n\n  return (\n    <>\n      {segmentNode}\n      {children}\n    </>\n  )\n}\n\nconst SegmentStateContext = createContext<{\n  boundaryType: SegmentBoundaryType | null\n  setBoundaryType: (type: SegmentBoundaryType | null) => void\n}>({\n  boundaryType: null,\n  setBoundaryType: () => {},\n})\n\nexport function SegmentStateProvider({ children }: { children: ReactNode }) {\n  const [boundaryType, setBoundaryType] = useState<SegmentBoundaryType | null>(\n    null\n  )\n\n  const [errorBoundaryKey, setErrorBoundaryKey] = useState(0)\n  const reloadBoundary = useCallback(\n    () => setErrorBoundaryKey((prev) => prev + 1),\n    []\n  )\n\n  const setBoundaryTypeAndReload = useCallback(\n    (type: SegmentBoundaryType | null) => {\n      if (type === null) {\n        reloadBoundary()\n      }\n      setBoundaryType(type)\n    },\n    [reloadBoundary]\n  )\n\n  return (\n    <SegmentStateContext.Provider\n      key={errorBoundaryKey}\n      value={{\n        boundaryType,\n        setBoundaryType: setBoundaryTypeAndReload,\n      }}\n    >\n      {children}\n    </SegmentStateContext.Provider>\n  )\n}\n\nexport function useSegmentState() {\n  return useContext(SegmentStateContext)\n}\n"],"names":["useState","createContext","useContext","use","useMemo","useCallback","useLayoutEffect","dispatcher","notFound","SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","SegmentTrieNode","type","pagePath","boundaryType","setBoundaryType","useSegmentState","nodeState","segmentExplorerNodeAdd","segmentExplorerNodeRemove","NotFoundSegmentNode","ErrorSegmentNode","Error","forever","Promise","LoadingSegmentNode","SegmentViewStateNode","page","segmentExplorerUpdateRouteState","SegmentBoundaryTriggerNode","segmentNode","SegmentViewNode","children","SegmentStateContext","SegmentStateProvider","errorBoundaryKey","setErrorBoundaryKey","reloadBoundary","prev","setBoundaryTypeAndReload","Provider","value"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1013, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/app-dev-overlay-error-boundary.tsx"],"sourcesContent":["import { PureComponent } from 'react'\nimport { dispatcher } from 'next/dist/compiled/next-devtools'\nimport { RuntimeErrorHandler } from '../../../client/dev/runtime-error-handler'\nimport { ErrorBoundary } from '../../../client/components/error-boundary'\nimport DefaultGlobalError from '../../../client/components/builtin/global-error'\nimport type { GlobalErrorState } from '../../../client/components/app-router-instance'\nimport { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } from './segment-explorer-node'\n\ntype AppDevOverlayErrorBoundaryProps = {\n  children: React.ReactNode\n  globalError: GlobalErrorState\n}\n\ntype AppDevOverlayErrorBoundaryState = {\n  reactError: unknown\n}\n\nfunction ErroredHtml({\n  globalError: [GlobalError, globalErrorStyles],\n  error,\n}: {\n  globalError: GlobalErrorState\n  error: unknown\n}) {\n  if (!error) {\n    return (\n      <html>\n        <head />\n        <body />\n      </html>\n    )\n  }\n  return (\n    <ErrorBoundary errorComponent={DefaultGlobalError}>\n      {globalErrorStyles}\n      <GlobalError error={error} />\n    </ErrorBoundary>\n  )\n}\n\nexport class AppDevOverlayErrorBoundary extends PureComponent<\n  AppDevOverlayErrorBoundaryProps,\n  AppDevOverlayErrorBoundaryState\n> {\n  state = { reactError: null }\n\n  static getDerivedStateFromError(error: Error) {\n    RuntimeErrorHandler.hadRuntimeError = true\n\n    return {\n      reactError: error,\n    }\n  }\n\n  componentDidCatch(err: Error) {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      err.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE\n    ) {\n      return\n    }\n    dispatcher.openErrorOverlay()\n  }\n\n  render() {\n    const { children, globalError } = this.props\n    const { reactError } = this.state\n\n    const fallback = (\n      <ErroredHtml globalError={globalError} error={reactError} />\n    )\n\n    return reactError !== null ? fallback : children\n  }\n}\n"],"names":["PureComponent","dispatcher","RuntimeErrorHandler","ErrorBoundary","DefaultGlobalError","SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","ErroredHtml","globalError","GlobalError","globalErrorStyles","error","html","head","body","errorComponent","AppDevOverlayErrorBoundary","getDerivedStateFromError","hadRuntimeError","reactError","componentDidCatch","err","process","env","NODE_ENV","message","openErrorOverlay","render","children","props","state","fallback"],"mappings":";;;;;AAAA,SAASA,aAAa,QAAQ,QAAO;AACrC,SAASC,UAAU,QAAQ,mCAAkC;AAC7D,SAASC,mBAAmB,QAAQ,4CAA2C;AAC/E,SAASC,aAAa,QAAQ,4CAA2C;AACzE,OAAOC,wBAAwB,kDAAiD;AAEhF,SAASC,wCAAwC,QAAQ,0BAAyB;;;;;;;;AAWlF,SAASC,YAAY,EACnBC,aAAa,CAACC,aAAaC,kBAAkB,EAC7CC,KAAK,EAIN;IACC,IAAI,CAACA,OAAO;QACV,OAAA,WAAA,OACE,kMAAA,EAACC,QAAAA;;kCACC,iMAAA,EAACC,QAAAA,CAAAA;kCACD,iMAAA,EAACC,QAAAA,CAAAA;;;IAGP;IACA,OAAA,WAAA,OACE,kMAAA,EAACV,wNAAAA,EAAAA;QAAcW,gBAAgBV,2NAAAA;;YAC5BK;8BACD,iMAAA,EAACD,aAAAA;gBAAYE,OAAOA;;;;AAG1B;AAEO,MAAMK,mCAAmCf,kMAAAA;IAM9C,OAAOgB,yBAAyBN,KAAY,EAAE;QAC5CR,iOAAAA,CAAoBe,eAAe,GAAG;QAEtC,OAAO;YACLC,YAAYR;QACd;IACF;IAEAS,kBAAkBC,GAAU,EAAE;QAC5B,IACEC,QAAQC,GAAG,CAACC,QAAQ,gCAAK,iBACzBH,IAAII,OAAO,KAAKnB,6QAAAA,EAChB;YACA;QACF;QACAJ,+MAAAA,CAAWwB,gBAAgB;IAC7B;IAEAC,SAAS;QACP,MAAM,EAAEC,QAAQ,EAAEpB,WAAW,EAAE,GAAG,IAAI,CAACqB,KAAK;QAC5C,MAAM,EAAEV,UAAU,EAAE,GAAG,IAAI,CAACW,KAAK;QAEjC,MAAMC,WAAAA,WAAAA,OACJ,iMAAA,EAACxB,aAAAA;YAAYC,aAAaA;YAAaG,OAAOQ;;QAGhD,OAAOA,eAAe,OAAOY,WAAWH;IAC1C;;QAjCK,KAAA,IAAA,OAAA,IAAA,CAILE,KAAAA,GAAQ;YAAEX,YAAY;QAAK;;AA8B7B","ignoreList":[0]}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/SB/Lumen/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 1087, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/SB/Lumen/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 1094, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/next-devtools/userspace/app/segment-explorer-node.tsx"],"sourcesContent":["'use client'\n\nimport type { ReactNode } from 'react'\nimport {\n  useState,\n  createContext,\n  useContext,\n  use,\n  useMemo,\n  useCallback,\n} from 'react'\nimport { useLayoutEffect } from 'react'\nimport { dispatcher } from 'next/dist/compiled/next-devtools'\nimport { notFound } from '../../../client/components/not-found'\n\nexport type SegmentBoundaryType =\n  | 'not-found'\n  | 'error'\n  | 'loading'\n  | 'global-error'\n\nexport const SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE =\n  'NEXT_DEVTOOLS_SIMULATED_ERROR'\n\nexport type SegmentNodeState = {\n  type: string\n  pagePath: string\n  boundaryType: string | null\n  setBoundaryType: (type: SegmentBoundaryType | null) => void\n}\n\nfunction SegmentTrieNode({\n  type,\n  pagePath,\n}: {\n  type: string\n  pagePath: string\n}): React.ReactNode {\n  const { boundaryType, setBoundaryType } = useSegmentState()\n  const nodeState: SegmentNodeState = useMemo(() => {\n    return {\n      type,\n      pagePath,\n      boundaryType,\n      setBoundaryType,\n    }\n  }, [type, pagePath, boundaryType, setBoundaryType])\n\n  // Use `useLayoutEffect` to ensure the state is updated during suspense.\n  // `useEffect` won't work as the state is preserved during suspense.\n  useLayoutEffect(() => {\n    dispatcher.segmentExplorerNodeAdd(nodeState)\n    return () => {\n      dispatcher.segmentExplorerNodeRemove(nodeState)\n    }\n  }, [nodeState])\n\n  return null\n}\n\nfunction NotFoundSegmentNode(): React.ReactNode {\n  notFound()\n}\n\nfunction ErrorSegmentNode(): React.ReactNode {\n  throw new Error(SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE)\n}\n\nconst forever = new Promise(() => {})\nfunction LoadingSegmentNode(): React.ReactNode {\n  use(forever)\n  return null\n}\n\nexport function SegmentViewStateNode({ page }: { page: string }) {\n  useLayoutEffect(() => {\n    dispatcher.segmentExplorerUpdateRouteState(page)\n    return () => {\n      dispatcher.segmentExplorerUpdateRouteState('')\n    }\n  }, [page])\n  return null\n}\n\nexport function SegmentBoundaryTriggerNode() {\n  const { boundaryType } = useSegmentState()\n  let segmentNode: React.ReactNode = null\n  if (boundaryType === 'loading') {\n    segmentNode = <LoadingSegmentNode />\n  } else if (boundaryType === 'not-found') {\n    segmentNode = <NotFoundSegmentNode />\n  } else if (boundaryType === 'error') {\n    segmentNode = <ErrorSegmentNode />\n  }\n  return segmentNode\n}\n\nexport function SegmentViewNode({\n  type,\n  pagePath,\n  children,\n}: {\n  type: string\n  pagePath: string\n  children?: ReactNode\n}): React.ReactNode {\n  const segmentNode = (\n    <SegmentTrieNode key={type} type={type} pagePath={pagePath} />\n  )\n\n  return (\n    <>\n      {segmentNode}\n      {children}\n    </>\n  )\n}\n\nconst SegmentStateContext = createContext<{\n  boundaryType: SegmentBoundaryType | null\n  setBoundaryType: (type: SegmentBoundaryType | null) => void\n}>({\n  boundaryType: null,\n  setBoundaryType: () => {},\n})\n\nexport function SegmentStateProvider({ children }: { children: ReactNode }) {\n  const [boundaryType, setBoundaryType] = useState<SegmentBoundaryType | null>(\n    null\n  )\n\n  const [errorBoundaryKey, setErrorBoundaryKey] = useState(0)\n  const reloadBoundary = useCallback(\n    () => setErrorBoundaryKey((prev) => prev + 1),\n    []\n  )\n\n  const setBoundaryTypeAndReload = useCallback(\n    (type: SegmentBoundaryType | null) => {\n      if (type === null) {\n        reloadBoundary()\n      }\n      setBoundaryType(type)\n    },\n    [reloadBoundary]\n  )\n\n  return (\n    <SegmentStateContext.Provider\n      key={errorBoundaryKey}\n      value={{\n        boundaryType,\n        setBoundaryType: setBoundaryTypeAndReload,\n      }}\n    >\n      {children}\n    </SegmentStateContext.Provider>\n  )\n}\n\nexport function useSegmentState() {\n  return useContext(SegmentStateContext)\n}\n"],"names":["useState","createContext","useContext","use","useMemo","useCallback","useLayoutEffect","dispatcher","notFound","SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","SegmentTrieNode","type","pagePath","boundaryType","setBoundaryType","useSegmentState","nodeState","segmentExplorerNodeAdd","segmentExplorerNodeRemove","NotFoundSegmentNode","ErrorSegmentNode","Error","forever","Promise","LoadingSegmentNode","SegmentViewStateNode","page","segmentExplorerUpdateRouteState","SegmentBoundaryTriggerNode","segmentNode","SegmentViewNode","children","SegmentStateContext","SegmentStateProvider","errorBoundaryKey","setErrorBoundaryKey","reloadBoundary","prev","setBoundaryTypeAndReload","Provider","value"],"mappings":"","ignoreList":[0]}}]
}