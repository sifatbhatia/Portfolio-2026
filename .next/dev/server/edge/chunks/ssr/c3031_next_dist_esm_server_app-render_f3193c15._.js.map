{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(\n  // WARNING: Don't pass a named function to this argument! See: https://github.com/facebook/react/pull/34911\n  fn: T\n): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","createAsyncLocalStorage","bindSnapshot","createSnapshot","snapshot","args"],"mappings":";;;;;;;;AAEA,MAAMA,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASC;IAGd,IAAIH,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASa,aACd,AACAL,EAAK,yGADsG;IAG3G,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASM;IAId,IAAIL,8BAA8B;QAChC,OAAOA,6BAA6BM,QAAQ;IAC9C;IACA,OAAO,SAAUP,EAAO,EAAE,GAAGQ,IAAW;QACtC,OAAOR,MAAMQ;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/work-async-storage-instance.ts"],"sourcesContent":["import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","workAsyncStorageInstance"],"mappings":";;;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,+BACXD,gPAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/work-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { FetchMetrics } from '../base-http'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { LazyResult } from '../lib/lazy-result'\nimport type { DigestedError } from './create-error-handler'\nimport type { ActionRevalidationKind } from '../../shared/lib/action-revalidation-kind'\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isBuildTimePrerendering?: boolean\n\n  /**\n   * This is true when:\n   * - source maps are generated\n   * - source maps are applied\n   * - minification is disabled\n   */\n  readonly hasReadableErrorStacks?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n\n  /**\n   * Invalid dynamic usage errors might be caught in userland. We attach them to\n   * the work store to ensure we can still fail the build, or show en error in\n   * dev mode.\n   */\n  // TODO: Collect an array of errors, and throw as AggregateError when\n  // `serializeError` and the Dev Overlay support it.\n  invalidDynamicUsageError?: Error\n\n  nextFetchId?: number\n  pathWasRevalidated?: ActionRevalidationKind\n\n  /**\n   * Tags that were revalidated during the current request. They need to be sent\n   * to cache handlers to propagate their revalidation.\n   */\n  pendingRevalidatedTags?: Array<{\n    tag: string\n    profile?: string | { stale?: number; revalidate?: number; expire?: number }\n  }>\n\n  /**\n   * Tags that were previously revalidated (e.g. by a redirecting server action)\n   * and have already been sent to cache handlers. Retrieved cache entries that\n   * include any of these tags must be discarded.\n   */\n  readonly previouslyRevalidatedTags: readonly string[]\n\n  /**\n   * This map contains lazy results so that we can evaluate them when the first\n   * cache entry is read. It allows us to skip refreshing tags if no caches are\n   * read at all.\n   */\n  readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>\n\n  fetchMetrics?: FetchMetrics\n  shouldTrackFetchMetrics: boolean\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n  readonly nonce?: string\n\n  cacheComponentsEnabled: boolean\n  dev: boolean\n\n  /**\n   * Run the given function inside a clean AsyncLocalStorage snapshot. This is\n   * useful when generating cache entries, to ensure that the cache generation\n   * cannot read anything from the context we're currently executing in, which\n   * might include request-specific things like `cookies()` inside a\n   * `React.cache()`.\n   */\n  runInCleanSnapshot: <R, TArgs extends any[]>(\n    fn: (...args: TArgs) => R,\n    ...args: TArgs\n  ) => R\n\n  reactServerErrorsByDigest: Map<string, DigestedError>\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n"],"names":["workAsyncStorageInstance","workAsyncStorage"],"mappings":";AAQA,qDAAqD;AACrD,SAASA,wBAAwB,QAAQ,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/work-unit-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","workUnitAsyncStorageInstance"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAGxD,MAAMC,mCACXD,gPAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/work-unit-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { WorkStore } from './work-async-storage.external'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport type { StagedRenderingController } from './staged-rendering'\n\nexport type WorkUnitPhase = 'action' | 'render' | 'after'\n\nexport interface CommonWorkUnitStore {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n  readonly implicitTags: ImplicitTags\n}\n\nexport interface RequestStore extends CommonWorkUnitStore {\n  readonly type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  devFallbackParams?: OpaqueFallbackRouteParams | null\n  stagedRendering?: StagedRenderingController | null\n  asyncApiPromises?: DevAsyncApiPromises\n  cacheSignal?: CacheSignal | null\n  prerenderResumeDataCache?: PrerenderResumeDataCache | null\n}\n\ntype DevAsyncApiPromises = {\n  cookies: Promise<ReadonlyRequestCookies>\n  mutableCookies: Promise<ReadonlyRequestCookies>\n  headers: Promise<ReadonlyHeaders>\n\n  sharedParamsParent: Promise<string>\n  sharedSearchParamsParent: Promise<string>\n\n  connection: Promise<undefined>\n}\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport type PrerenderStoreModern =\n  | PrerenderStoreModernClient\n  | PrerenderStoreModernServer\n  | PrerenderStoreModernRuntime\n\n/** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStoreModern = Exclude<\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime\n>\n\nexport interface PrerenderStoreModernClient\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender-client'\n}\n\nexport interface PrerenderStoreModernServer\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender'\n}\n\nexport interface PrerenderStoreModernRuntime\n  extends PrerenderStoreModernCommon {\n  readonly type: 'prerender-runtime'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  readonly headers: RequestStore['headers']\n  readonly cookies: RequestStore['cookies']\n  readonly draftMode: RequestStore['draftMode']\n}\n\nexport interface RevalidateStore {\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n}\n\ninterface PrerenderStoreModernCommon\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  /**\n   * The render signal is aborted after React's `prerender` function is aborted\n   * (using a separate signal), which happens in two cases:\n   *\n   * 1. When all caches are filled during the prospective prerender.\n   * 2. When the final prerender is aborted immediately after the prerender was\n   *    started.\n   *\n   * It can be used to reject any pending I/O, including hanging promises. This\n   * allows React to properly track the async I/O in dev mode, which yields\n   * better owner stacks for dynamic validation errors.\n   */\n  readonly renderSignal: AbortSignal\n\n  /**\n   * This is the AbortController which represents the boundary between Prerender\n   * and dynamic. In some renders it is the same as the controller for React,\n   * but in others it is a separate controller. It should be aborted whenever we\n   * are no longer in the prerender phase of rendering. Typically this is after\n   * one task, or when you call a sync API which requires the prerender to end\n   * immediately.\n   */\n  readonly controller: AbortController\n\n  /**\n   * When not null, this signal is used to track cache reads during prerendering\n   * and to await all cache reads completing, before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  /**\n   * A mutable resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  /**\n   * An immutable resume data cache for this prerender. This may be provided\n   * instead of the `prerenderResumeDataCache` if the prerender is not supposed\n   * to fill caches, and only read from prefilled caches, e.g. when prerendering\n   * an optional fallback shell.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  /**\n   * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n   * warmup render to ensure that the cache keys will be identical for the\n   * subsequent dynamic render.\n   */\n  readonly hmrRefreshHash: string | undefined\n}\n\ninterface StaticPrerenderStoreCommon {\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: OpaqueFallbackRouteParams | null\n\n  /**\n   * When true, the page is prerendered as a fallback shell, while allowing any\n   * dynamic accesses to result in an empty shell. This is the case when there\n   * are also routes prerendered with a more complete set of params.\n   * Prerendering those routes would catch any invalid dynamic accesses.\n   */\n  readonly allowEmptyStaticShell: boolean\n}\n\nexport interface PrerenderStorePPR\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: OpaqueFallbackRouteParams | null\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n}\n\nexport interface PrerenderStoreLegacy\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-legacy'\n  readonly rootParams: Params\n}\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\n// /** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStore = Exclude<\n  PrerenderStore,\n  PrerenderStoreModernRuntime\n>\n\nexport interface CommonCacheStore\n  extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n  /**\n   * A cache work unit store might not always have an outer work unit store,\n   * from which implicit tags could be inherited.\n   */\n  readonly implicitTags: ImplicitTags | undefined\n  /**\n   * Draft mode is only available if the outer work unit store is a request\n   * store and draft mode is enabled.\n   */\n  readonly draftMode: DraftModeProvider | undefined\n}\n\nexport interface CommonUseCacheStore extends CommonCacheStore, RevalidateStore {\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n}\n\nexport interface PublicUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'cache'\n}\n\nexport interface PrivateUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'private-cache'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  readonly headers: ReadonlyHeaders\n  readonly cookies: ReadonlyRequestCookies\n\n  /**\n   * Private caches don't currently need to track root params in the cache key\n   * because they're not persisted anywhere, so we can allow root params access\n   * (unlike public caches)\n   */\n  readonly rootParams: Params\n}\n\nexport type UseCacheStore = PublicUseCacheStore | PrivateUseCacheStore\n\nexport interface UnstableCacheStore extends CommonCacheStore {\n  readonly type: 'unstable-cache'\n}\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or\n * unstable_cache context. A cache store shadows an outer request store (if\n * present) as a work unit, so that we never accidentally expose any request or\n * page specific information to cache functions, unless it's explicitly desired.\n * For those exceptions, the data is copied over from the request store to the\n * cache store, instead of generally making the request store available to cache\n * functions.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function throwForMissingRequestStore(callingExpression: string): never {\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function throwInvariantForMissingStore(): never {\n  throw new InvariantError('Expected workUnitAsyncStorage to have a store.')\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-ppr':\n      return workUnitStore.prerenderResumeDataCache\n    case 'prerender-client':\n      // TODO eliminate fetch caching in client scope and stop exposing this data\n      // cache during SSR.\n      return workUnitStore.prerenderResumeDataCache\n    case 'request': {\n      // In dev, we might fill caches even during a dynamic request.\n      if (workUnitStore.prerenderResumeDataCache) {\n        return workUnitStore.prerenderResumeDataCache\n      }\n      // fallthrough\n    }\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'request':\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-client':\n      if (workUnitStore.renderResumeDataCache) {\n        // If we are in a prerender, we might have a render resume data cache\n        // that is used to read from prefilled caches.\n        return workUnitStore.renderResumeDataCache\n      }\n    // fallthrough\n    case 'prerender-ppr':\n      // Otherwise we return the mutable resume data cache here as an immutable\n      // version of the cache as it can also be used for reading.\n      return workUnitStore.prerenderResumeDataCache ?? null\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case 'prerender-legacy':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getHmrRefreshHash(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n        return workUnitStore.hmrRefreshHash\n      case 'request':\n        return workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function isHmrRefresh(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): boolean {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.isHmrRefresh ?? false\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nexport function getServerComponentsHmrCache(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): ServerComponentsHmrCache | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.serverComponentsHmrCache\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a draft mode provider only if draft mode is enabled.\n */\nexport function getDraftModeProviderForCacheScope(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): DraftModeProvider | undefined {\n  if (workStore.isDraftMode) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n      case 'prerender-runtime':\n      case 'request':\n        return workUnitStore.draftMode\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function getCacheSignal(\n  workUnitStore: WorkUnitStore\n): CacheSignal | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-runtime':\n      return workUnitStore.cacheSignal\n    case 'request': {\n      // In dev, we might fill caches even during a dynamic request.\n      if (workUnitStore.cacheSignal) {\n        return workUnitStore.cacheSignal\n      }\n      // fallthrough\n    }\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRuntimeStagePromise(\n  workUnitStore: WorkUnitStore\n): Promise<void> | null {\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n    case 'private-cache':\n      return workUnitStore.runtimeStagePromise\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n"],"names":["workUnitAsyncStorageInstance","NEXT_HMR_REFRESH_HASH_COOKIE","InvariantError","workUnitAsyncStorage","throwForMissingRequestStore","callingExpression","Error","throwInvariantForMissingStore","getPrerenderResumeDataCache","workUnitStore","type","prerenderResumeDataCache","getRenderResumeDataCache","renderResumeDataCache","getHmrRefreshHash","workStore","dev","hmrRefreshHash","cookies","get","value","undefined","isHmrRefresh","getServerComponentsHmrCache","serverComponentsHmrCache","getDraftModeProviderForCacheScope","isDraftMode","draftMode","getCacheSignal","cacheSignal","getRuntimeStagePromise","runtimeStagePromise"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(\n  // WARNING: Don't pass a named function to this argument! See: https://github.com/facebook/react/pull/34911\n  fn: T\n): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","createAsyncLocalStorage","bindSnapshot","createSnapshot","snapshot","args"],"mappings":";;;;;;;;AAEA,MAAMA,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASC;IAGd,IAAIH,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASa,aACd,AACAL,EAAK,yGADsG;IAG3G,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASM;IAId,IAAIL,8BAA8B;QAChC,OAAOA,6BAA6BM,QAAQ;IAC9C;IACA,OAAO,SAAUP,EAAO,EAAE,GAAGQ,IAAW;QACtC,OAAOR,MAAMQ;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/after-task-async-storage-instance.ts"],"sourcesContent":["import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","afterTaskAsyncStorageInstance"],"mappings":";;;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,oCACXD,gPAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/after-task-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n"],"names":["afterTaskAsyncStorageInstance","afterTaskAsyncStorage"],"mappings":";AAEA,qDAAqD;AACrD,SAASA,iCAAiCC,qBAAqB,QAAQ,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/work-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { FetchMetrics } from '../base-http'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { LazyResult } from '../lib/lazy-result'\nimport type { DigestedError } from './create-error-handler'\nimport type { ActionRevalidationKind } from '../../shared/lib/action-revalidation-kind'\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isBuildTimePrerendering?: boolean\n\n  /**\n   * This is true when:\n   * - source maps are generated\n   * - source maps are applied\n   * - minification is disabled\n   */\n  readonly hasReadableErrorStacks?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n\n  /**\n   * Invalid dynamic usage errors might be caught in userland. We attach them to\n   * the work store to ensure we can still fail the build, or show en error in\n   * dev mode.\n   */\n  // TODO: Collect an array of errors, and throw as AggregateError when\n  // `serializeError` and the Dev Overlay support it.\n  invalidDynamicUsageError?: Error\n\n  nextFetchId?: number\n  pathWasRevalidated?: ActionRevalidationKind\n\n  /**\n   * Tags that were revalidated during the current request. They need to be sent\n   * to cache handlers to propagate their revalidation.\n   */\n  pendingRevalidatedTags?: Array<{\n    tag: string\n    profile?: string | { stale?: number; revalidate?: number; expire?: number }\n  }>\n\n  /**\n   * Tags that were previously revalidated (e.g. by a redirecting server action)\n   * and have already been sent to cache handlers. Retrieved cache entries that\n   * include any of these tags must be discarded.\n   */\n  readonly previouslyRevalidatedTags: readonly string[]\n\n  /**\n   * This map contains lazy results so that we can evaluate them when the first\n   * cache entry is read. It allows us to skip refreshing tags if no caches are\n   * read at all.\n   */\n  readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>\n\n  fetchMetrics?: FetchMetrics\n  shouldTrackFetchMetrics: boolean\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n  readonly nonce?: string\n\n  cacheComponentsEnabled: boolean\n  dev: boolean\n\n  /**\n   * Run the given function inside a clean AsyncLocalStorage snapshot. This is\n   * useful when generating cache entries, to ensure that the cache generation\n   * cannot read anything from the context we're currently executing in, which\n   * might include request-specific things like `cookies()` inside a\n   * `React.cache()`.\n   */\n  runInCleanSnapshot: <R, TArgs extends any[]>(\n    fn: (...args: TArgs) => R,\n    ...args: TArgs\n  ) => R\n\n  reactServerErrorsByDigest: Map<string, DigestedError>\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n"],"names":["workAsyncStorageInstance","workAsyncStorage"],"mappings":";AAQA,qDAAqD;AACrD,SAASA,wBAAwB,QAAQ,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 435, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(\n  // WARNING: Don't pass a named function to this argument! See: https://github.com/facebook/react/pull/34911\n  fn: T\n): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","createAsyncLocalStorage","bindSnapshot","createSnapshot","snapshot","args"],"mappings":";;;;;;;;AAEA,MAAMA,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASC;IAGd,IAAIH,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASa,aACd,AACAL,EAAK,yGADsG;IAG3G,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASM;IAId,IAAIL,8BAA8B;QAChC,OAAOA,6BAA6BM,QAAQ;IAC9C;IACA,OAAO,SAAUP,EAAO,EAAE,GAAGQ,IAAW;QACtC,OAAOR,MAAMQ;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/work-unit-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { WorkStore } from './work-async-storage.external'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport type { StagedRenderingController } from './staged-rendering'\n\nexport type WorkUnitPhase = 'action' | 'render' | 'after'\n\nexport interface CommonWorkUnitStore {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n  readonly implicitTags: ImplicitTags\n}\n\nexport interface RequestStore extends CommonWorkUnitStore {\n  readonly type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  devFallbackParams?: OpaqueFallbackRouteParams | null\n  stagedRendering?: StagedRenderingController | null\n  asyncApiPromises?: DevAsyncApiPromises\n  cacheSignal?: CacheSignal | null\n  prerenderResumeDataCache?: PrerenderResumeDataCache | null\n}\n\ntype DevAsyncApiPromises = {\n  cookies: Promise<ReadonlyRequestCookies>\n  mutableCookies: Promise<ReadonlyRequestCookies>\n  headers: Promise<ReadonlyHeaders>\n\n  sharedParamsParent: Promise<string>\n  sharedSearchParamsParent: Promise<string>\n\n  connection: Promise<undefined>\n}\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport type PrerenderStoreModern =\n  | PrerenderStoreModernClient\n  | PrerenderStoreModernServer\n  | PrerenderStoreModernRuntime\n\n/** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStoreModern = Exclude<\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime\n>\n\nexport interface PrerenderStoreModernClient\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender-client'\n}\n\nexport interface PrerenderStoreModernServer\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender'\n}\n\nexport interface PrerenderStoreModernRuntime\n  extends PrerenderStoreModernCommon {\n  readonly type: 'prerender-runtime'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  readonly headers: RequestStore['headers']\n  readonly cookies: RequestStore['cookies']\n  readonly draftMode: RequestStore['draftMode']\n}\n\nexport interface RevalidateStore {\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n}\n\ninterface PrerenderStoreModernCommon\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  /**\n   * The render signal is aborted after React's `prerender` function is aborted\n   * (using a separate signal), which happens in two cases:\n   *\n   * 1. When all caches are filled during the prospective prerender.\n   * 2. When the final prerender is aborted immediately after the prerender was\n   *    started.\n   *\n   * It can be used to reject any pending I/O, including hanging promises. This\n   * allows React to properly track the async I/O in dev mode, which yields\n   * better owner stacks for dynamic validation errors.\n   */\n  readonly renderSignal: AbortSignal\n\n  /**\n   * This is the AbortController which represents the boundary between Prerender\n   * and dynamic. In some renders it is the same as the controller for React,\n   * but in others it is a separate controller. It should be aborted whenever we\n   * are no longer in the prerender phase of rendering. Typically this is after\n   * one task, or when you call a sync API which requires the prerender to end\n   * immediately.\n   */\n  readonly controller: AbortController\n\n  /**\n   * When not null, this signal is used to track cache reads during prerendering\n   * and to await all cache reads completing, before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  /**\n   * A mutable resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  /**\n   * An immutable resume data cache for this prerender. This may be provided\n   * instead of the `prerenderResumeDataCache` if the prerender is not supposed\n   * to fill caches, and only read from prefilled caches, e.g. when prerendering\n   * an optional fallback shell.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  /**\n   * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n   * warmup render to ensure that the cache keys will be identical for the\n   * subsequent dynamic render.\n   */\n  readonly hmrRefreshHash: string | undefined\n}\n\ninterface StaticPrerenderStoreCommon {\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: OpaqueFallbackRouteParams | null\n\n  /**\n   * When true, the page is prerendered as a fallback shell, while allowing any\n   * dynamic accesses to result in an empty shell. This is the case when there\n   * are also routes prerendered with a more complete set of params.\n   * Prerendering those routes would catch any invalid dynamic accesses.\n   */\n  readonly allowEmptyStaticShell: boolean\n}\n\nexport interface PrerenderStorePPR\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: OpaqueFallbackRouteParams | null\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n}\n\nexport interface PrerenderStoreLegacy\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-legacy'\n  readonly rootParams: Params\n}\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\n// /** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStore = Exclude<\n  PrerenderStore,\n  PrerenderStoreModernRuntime\n>\n\nexport interface CommonCacheStore\n  extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n  /**\n   * A cache work unit store might not always have an outer work unit store,\n   * from which implicit tags could be inherited.\n   */\n  readonly implicitTags: ImplicitTags | undefined\n  /**\n   * Draft mode is only available if the outer work unit store is a request\n   * store and draft mode is enabled.\n   */\n  readonly draftMode: DraftModeProvider | undefined\n}\n\nexport interface CommonUseCacheStore extends CommonCacheStore, RevalidateStore {\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n}\n\nexport interface PublicUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'cache'\n}\n\nexport interface PrivateUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'private-cache'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  readonly headers: ReadonlyHeaders\n  readonly cookies: ReadonlyRequestCookies\n\n  /**\n   * Private caches don't currently need to track root params in the cache key\n   * because they're not persisted anywhere, so we can allow root params access\n   * (unlike public caches)\n   */\n  readonly rootParams: Params\n}\n\nexport type UseCacheStore = PublicUseCacheStore | PrivateUseCacheStore\n\nexport interface UnstableCacheStore extends CommonCacheStore {\n  readonly type: 'unstable-cache'\n}\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or\n * unstable_cache context. A cache store shadows an outer request store (if\n * present) as a work unit, so that we never accidentally expose any request or\n * page specific information to cache functions, unless it's explicitly desired.\n * For those exceptions, the data is copied over from the request store to the\n * cache store, instead of generally making the request store available to cache\n * functions.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function throwForMissingRequestStore(callingExpression: string): never {\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function throwInvariantForMissingStore(): never {\n  throw new InvariantError('Expected workUnitAsyncStorage to have a store.')\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-ppr':\n      return workUnitStore.prerenderResumeDataCache\n    case 'prerender-client':\n      // TODO eliminate fetch caching in client scope and stop exposing this data\n      // cache during SSR.\n      return workUnitStore.prerenderResumeDataCache\n    case 'request': {\n      // In dev, we might fill caches even during a dynamic request.\n      if (workUnitStore.prerenderResumeDataCache) {\n        return workUnitStore.prerenderResumeDataCache\n      }\n      // fallthrough\n    }\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'request':\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-client':\n      if (workUnitStore.renderResumeDataCache) {\n        // If we are in a prerender, we might have a render resume data cache\n        // that is used to read from prefilled caches.\n        return workUnitStore.renderResumeDataCache\n      }\n    // fallthrough\n    case 'prerender-ppr':\n      // Otherwise we return the mutable resume data cache here as an immutable\n      // version of the cache as it can also be used for reading.\n      return workUnitStore.prerenderResumeDataCache ?? null\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case 'prerender-legacy':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getHmrRefreshHash(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n        return workUnitStore.hmrRefreshHash\n      case 'request':\n        return workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function isHmrRefresh(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): boolean {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.isHmrRefresh ?? false\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nexport function getServerComponentsHmrCache(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): ServerComponentsHmrCache | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.serverComponentsHmrCache\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a draft mode provider only if draft mode is enabled.\n */\nexport function getDraftModeProviderForCacheScope(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): DraftModeProvider | undefined {\n  if (workStore.isDraftMode) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n      case 'prerender-runtime':\n      case 'request':\n        return workUnitStore.draftMode\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function getCacheSignal(\n  workUnitStore: WorkUnitStore\n): CacheSignal | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-runtime':\n      return workUnitStore.cacheSignal\n    case 'request': {\n      // In dev, we might fill caches even during a dynamic request.\n      if (workUnitStore.cacheSignal) {\n        return workUnitStore.cacheSignal\n      }\n      // fallthrough\n    }\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRuntimeStagePromise(\n  workUnitStore: WorkUnitStore\n): Promise<void> | null {\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n    case 'private-cache':\n      return workUnitStore.runtimeStagePromise\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n"],"names":["workUnitAsyncStorageInstance","NEXT_HMR_REFRESH_HASH_COOKIE","InvariantError","workUnitAsyncStorage","throwForMissingRequestStore","callingExpression","Error","throwInvariantForMissingStore","getPrerenderResumeDataCache","workUnitStore","type","prerenderResumeDataCache","getRenderResumeDataCache","renderResumeDataCache","getHmrRefreshHash","workStore","dev","hmrRefreshHash","cookies","get","value","undefined","isHmrRefresh","getServerComponentsHmrCache","serverComponentsHmrCache","getDraftModeProviderForCacheScope","isDraftMode","draftMode","getCacheSignal","cacheSignal","getRuntimeStagePromise","runtimeStagePromise"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/after-task-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n"],"names":["afterTaskAsyncStorageInstance","afterTaskAsyncStorage"],"mappings":";AAEA,qDAAqD;AACrD,SAASA,iCAAiCC,qBAAqB,QAAQ,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 727, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/action-async-storage-instance.ts"],"sourcesContent":["import type { ActionAsyncStorage } from './action-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const actionAsyncStorageInstance: ActionAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","actionAsyncStorageInstance"],"mappings":";;;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,iCACXD,gPAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/action-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { actionAsyncStorageInstance } from './action-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nexport interface ActionStore {\n  readonly isAction?: boolean\n  readonly isAppRoute?: boolean\n}\n\nexport type ActionAsyncStorage = AsyncLocalStorage<ActionStore>\n\nexport { actionAsyncStorageInstance as actionAsyncStorage }\n"],"names":["actionAsyncStorageInstance","actionAsyncStorage"],"mappings":";AAEA,qDAAqD;AACrD,SAASA,0BAA0B,QAAQ,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/flight-render-result.ts"],"sourcesContent":["import { RSC_CONTENT_TYPE_HEADER } from '../../client/components/app-router-headers'\nimport RenderResult, { type RenderResultMetadata } from '../render-result'\n\n/**\n * Flight Response is always set to RSC_CONTENT_TYPE_HEADER to ensure it does not get interpreted as HTML.\n */\nexport class FlightRenderResult extends RenderResult {\n  constructor(\n    response: string | ReadableStream<Uint8Array>,\n    metadata: RenderResultMetadata = {},\n    waitUntil?: Promise<unknown>\n  ) {\n    super(response, {\n      contentType: RSC_CONTENT_TYPE_HEADER,\n      metadata,\n      waitUntil,\n    })\n  }\n}\n"],"names":["RSC_CONTENT_TYPE_HEADER","RenderResult","FlightRenderResult","constructor","response","metadata","waitUntil","contentType"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,6CAA4C;AACpF,OAAOC,kBAAiD,mBAAkB;;;AAKnE,MAAMC,2BAA2BD,mMAAAA;IACtCE,YACEC,QAA6C,EAC7CC,WAAiC,CAAC,CAAC,EACnCC,SAA4B,CAC5B;QACA,KAAK,CAACF,UAAU;YACdG,aAAaP,yOAAAA;YACbK;YACAC;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 779, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  dynamicMetadata: null | Error\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    dynamicMetadata: null,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nexport function useDynamicSearchParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore) {\n    // We assume pages router context and just return\n    return\n  }\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(expression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-client': {\n      React.use(\n        makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      )\n      break\n    }\n    case 'prerender-legacy':\n    case 'prerender-ppr': {\n      if (workStore.forceStatic) {\n        return\n      }\n      throw new BailoutToCSRError(expression)\n    }\n    case 'prerender':\n    case 'prerender-runtime':\n      throw new InvariantError(\n        `\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'cache':\n    case 'unstable-cache':\n    case 'private-cache':\n      throw new InvariantError(\n        `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'request':\n      return\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message =\n      `Route \"${workStore.route}\": Uncached data was accessed outside of ` +\n      '<Suspense>. This delays the entire page from rendering, resulting in a ' +\n      'slow user experience. Learn more: ' +\n      'https://nextjs.org/docs/messages/blocking-route'\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nexport function trackDynamicHoleInRuntimeShell(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed inside \\`generateMetadata\\`. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicMetadata = error\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed inside \\`generateViewport\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed outside of \\`<Suspense>\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nexport function trackDynamicHoleInStaticShell(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed inside \\`generateMetadata\\` or you have file-based metadata such as icons that depend on dynamic params segments. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicMetadata = error\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed inside \\`generateViewport\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed outside of \\`<Suspense>\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  // TODO go back to owner stack here if available. This is temporarily using componentStack to get the right\n  //\n  error.stack = error.name + ': ' + message + (ownerStack || componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    logDisallowedDynamicError(\n      workStore,\n      serverDynamic.syncDynamicErrorWithStack\n    )\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function getStaticShellDisallowedDynamicReasons(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState\n): Array<Error> {\n  if (dynamicValidation.hasSuspenseAboveBody) {\n    // This route has opted into allowing fully dynamic rendering\n    // by including a Suspense boundary above the body. In this case\n    // a lack of a shell is not considered disallowed so we simply return\n    return []\n  }\n\n  if (prelude !== PreludeState.Full) {\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      return dynamicErrors\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      return [\n        new InvariantError(\n          `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason.`\n        ),\n      ]\n    }\n  } else {\n    // We have a prelude but we might still have dynamic metadata without any other dynamic access\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.dynamicErrors.length === 0 &&\n      dynamicValidation.dynamicMetadata\n    ) {\n      return [dynamicValidation.dynamicMetadata]\n    }\n  }\n  // We had a non-empty prelude and there are no dynamic holes\n  return []\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n"],"names":["React","DynamicServerError","StaticGenBailoutError","getRuntimeStagePromise","throwForMissingRequestStore","workUnitAsyncStorage","workAsyncStorage","makeHangingPromise","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","scheduleOnNextTick","BailoutToCSRError","InvariantError","hasPostpone","unstable_postpone","createDynamicTrackingState","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","createDynamicValidationState","hasSuspenseAboveBody","hasDynamicMetadata","dynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","getFirstDynamicReason","trackingState","expression","markCurrentScopeAsDynamic","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","route","postponeWithTracking","dynamicTracking","revalidate","err","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","throwToInterruptStaticGeneration","prerenderStore","trackDynamicDataInDynamicRender","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","undefined","abortOnSynchronousPlatformIOAccess","errorWithStack","abortAndThrowOnSynchronousRequestDataAccess","prerenderSignal","signal","aborted","Postpone","getStore","assertPostpone","createPostponeReason","isDynamicPostpone","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","isPrerenderInterruptedError","accessedDynamicData","length","consumeDynamicAccess","serverDynamic","clientDynamic","formatDynamicAPIAccesses","filter","access","map","split","slice","line","join","createRenderInBrowserAbortSignal","AbortController","createHangingInputAbortSignal","cacheSignal","inputReady","then","runtimeStagePromise","annotateDynamicAccess","useDynamicRouteParams","workStore","fallbackParams","fallbackRouteParams","size","use","renderSignal","useDynamicSearchParams","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","hasMetadataRegex","hasViewportRegex","hasOutletRegex","trackAllowedDynamicAccess","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","trackDynamicHoleInRuntimeShell","trackDynamicHoleInStaticShell","ownerStack","captureOwnerStack","name","PreludeState","logDisallowedDynamicError","console","dev","hasReadableErrorStacks","throwIfDisallowedDynamic","prelude","i","getStaticShellDisallowedDynamicReasons","delayUntilRuntimeStage","result"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1549, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/react-large-shell-error.ts"],"sourcesContent":["// TODO: isWellKnownError -> isNextInternalError\n// isReactLargeShellError -> isWarning\nexport function isReactLargeShellError(\n  error: unknown\n): error is Error & { digest?: string } {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof error.message === 'string' &&\n    error.message.startsWith('This rendered a large document (>')\n  )\n}\n"],"names":["isReactLargeShellError","error","message","startsWith"],"mappings":"AAAA,gDAAgD;AAChD,sCAAsC;;;;;AAC/B,SAASA,uBACdC,KAAc;IAEd,OACE,OAAOA,UAAU,YACjBA,UAAU,QACV,aAAaA,SACb,OAAOA,MAAMC,OAAO,KAAK,YACzBD,MAAMC,OAAO,CAACC,UAAU,CAAC;AAE7B","ignoreList":[0]}},
    {"offset": {"line": 1562, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/create-error-handler.tsx"],"sourcesContent":["import type { ErrorInfo } from 'react'\nimport stringHash from 'next/dist/compiled/string-hash'\n\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\n\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\nimport { isReactLargeShellError } from './react-large-shell-error'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string; environmentName?: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  // If this is a prerender interrupted error, we don't need to log the error.\n  if (isPrerenderInterruptedError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  onReactServerRenderError: (err: DigestedError, silenceLog: boolean) => void,\n  spanToRecordOn?: any\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let err = getProperError(thrownValue) as DigestedError\n    let silenceLog = false\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (\n        process.env.NODE_ENV === 'production' &&\n        reactServerErrors.has(err.digest)\n      ) {\n        // This error is likely an obfuscated error from another react-server\n        // environment (e.g. 'use cache'). We recover the original error here\n        // for reporting purposes.\n        err = reactServerErrors.get(err.digest)!\n        // We don't log it again though, as it was already logged in the\n        // original environment.\n        silenceLog = true\n      } else {\n        // Either we're in development (where we want to keep the transported\n        // error with environmentName), or the error is not in reactServerErrors\n        // but has a digest from other means. Keep the error as-is.\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n        stringHash(err.message + (err.stack || '')).toString()\n      )\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception on the provided span if available, otherwise try active span.\n      const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setAttribute('error.type', err.name)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      onReactServerRenderError(err, silenceLog)\n    }\n\n    return err.digest\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void,\n  spanToRecordOn?: any\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        stringHash(\n          err.message + (errorInfo?.componentStack || err.stack || '')\n        ).toString()\n      )\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // HTML errors contain RSC errors as well, filter them out before reporting\n      if (isSSRError) {\n        // Record exception on the provided span if available, otherwise try active span.\n        const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n        if (span) {\n          span.recordException(err)\n          span.setAttribute('error.type', err.name)\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message,\n          })\n        }\n\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return err.digest\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n"],"names":["stringHash","formatServerError","SpanStatusCode","getTracer","isAbortError","isBailoutToCSRError","isDynamicServerError","isNextRouterError","isPrerenderInterruptedError","getProperError","createDigestWithErrorCode","isReactLargeShellError","getDigestForWellKnownError","error","digest","undefined","createReactServerErrorHandler","shouldFormatError","isNextExport","reactServerErrors","onReactServerRenderError","spanToRecordOn","thrownValue","err","toString","console","silenceLog","process","env","NODE_ENV","has","get","message","stack","set","includes","span","getActiveScopeSpan","recordException","setAttribute","name","setStatus","code","ERROR","createHTMLErrorHandler","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","push","componentStack","isUserLandError"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1730, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/get-short-dynamic-param-type.tsx"],"sourcesContent":["import type {\n  DynamicParamTypes,\n  DynamicParamTypesShort,\n} from '../../shared/lib/app-router-types'\n\nexport const dynamicParamTypes: Record<\n  DynamicParamTypes,\n  DynamicParamTypesShort\n> = {\n  catchall: 'c',\n  'catchall-intercepted-(..)(..)': 'ci(..)(..)',\n  'catchall-intercepted-(.)': 'ci(.)',\n  'catchall-intercepted-(..)': 'ci(..)',\n  'catchall-intercepted-(...)': 'ci(...)',\n  'optional-catchall': 'oc',\n  dynamic: 'd',\n  'dynamic-intercepted-(..)(..)': 'di(..)(..)',\n  'dynamic-intercepted-(.)': 'di(.)',\n  'dynamic-intercepted-(..)': 'di(..)',\n  'dynamic-intercepted-(...)': 'di(...)',\n}\n"],"names":["dynamicParamTypes","catchall","dynamic"],"mappings":";;;;AAKO,MAAMA,oBAGT;IACFC,UAAU;IACV,iCAAiC;IACjC,4BAA4B;IAC5B,6BAA6B;IAC7B,8BAA8B;IAC9B,qBAAqB;IACrBC,SAAS;IACT,gCAAgC;IAChC,2BAA2B;IAC3B,4BAA4B;IAC5B,6BAA6B;AAC/B,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1751, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/get-script-nonce-from-header.tsx"],"sourcesContent":["import { ESCAPE_REGEX } from '../htmlescape'\n\nexport function getScriptNonceFromHeader(\n  cspHeaderValue: string\n): string | undefined {\n  const directives = cspHeaderValue\n    // Directives are split by ';'.\n    .split(';')\n    .map((directive) => directive.trim())\n\n  // First try to find the directive for the 'script-src', otherwise try to\n  // fallback to the 'default-src'.\n  const directive =\n    directives.find((dir) => dir.startsWith('script-src')) ||\n    directives.find((dir) => dir.startsWith('default-src'))\n\n  // If no directive could be found, then we're done.\n  if (!directive) {\n    return\n  }\n\n  // Extract the nonce from the directive\n  const nonce = directive\n    .split(' ')\n    // Remove the 'strict-src'/'default-src' string, this can't be the nonce.\n    .slice(1)\n    .map((source) => source.trim())\n    // Find the first source with the 'nonce-' prefix.\n    .find(\n      (source) =>\n        source.startsWith(\"'nonce-\") &&\n        source.length > 8 &&\n        source.endsWith(\"'\")\n    )\n    // Grab the nonce by trimming the 'nonce-' prefix.\n    ?.slice(7, -1)\n\n  // If we could't find the nonce, then we're done.\n  if (!nonce) {\n    return\n  }\n\n  // Don't accept the nonce value if it contains HTML escape characters.\n  // Technically, the spec requires a base64'd value, but this is just an\n  // extra layer.\n  if (ESCAPE_REGEX.test(nonce)) {\n    throw new Error(\n      'Nonce value from Content-Security-Policy contained HTML escape characters.\\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters'\n    )\n  }\n\n  return nonce\n}\n"],"names":["ESCAPE_REGEX","getScriptNonceFromHeader","cspHeaderValue","directive","directives","split","map","trim","find","dir","startsWith","nonce","slice","source","length","endsWith","test","Error"],"mappings":";;;;AAAA,SAASA,YAAY,QAAQ,gBAAe;;AAErC,SAASC,yBACdC,cAAsB;QAmBRC;IAjBd,MAAMC,aAAaF,eACjB,+BAA+B;KAC9BG,KAAK,CAAC,KACNC,GAAG,CAAC,CAACH,YAAcA,UAAUI,IAAI;IAEpC,yEAAyE;IACzE,iCAAiC;IACjC,MAAMJ,YACJC,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC,kBACxCN,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC;IAE1C,mDAAmD;IACnD,IAAI,CAACP,WAAW;QACd;IACF;IAEA,uCAAuC;IACvC,MAAMQ,QAAAA,CAAQR,kCAAAA,UACXE,KAAK,CAAC,KACP,yEAAyE;KACxEO,KAAK,CAAC,GACNN,GAAG,CAAC,CAACO,SAAWA,OAAON,IAAI,IAC5B,kDAAkD;KACjDC,IAAI,CACH,CAACK,SACCA,OAAOH,UAAU,CAAC,cAClBG,OAAOC,MAAM,GAAG,KAChBD,OAAOE,QAAQ,CAAC,KAAA,KAAA,OAAA,KAAA,IAVRZ,gCAaVS,KAAK,CAAC,GAAG,CAAC;IAEd,iDAAiD;IACjD,IAAI,CAACD,OAAO;QACV;IACF;IAEA,sEAAsE;IACtE,uEAAuE;IACvE,eAAe;IACf,IAAIX,kMAAAA,CAAagB,IAAI,CAACL,QAAQ;QAC5B,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,gKADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAON;AACT","ignoreList":[0]}},
    {"offset": {"line": 1792, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/types.ts"],"sourcesContent":["import type { LoadComponentsReturnType } from '../load-components'\nimport type { ServerRuntime, SizeLimit } from '../../types'\nimport type {\n  ExperimentalConfig,\n  NextConfigComplete,\n} from '../../server/config-shared'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { ImageConfigComplete } from '../../shared/lib/image-config'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport s from 'next/dist/compiled/superstruct'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { InstrumentationOnRequestError } from '../instrumentation/types'\nimport type { NextRequestHint } from '../web/adapter'\nimport type { BaseNextRequest } from '../base-http'\nimport type { IncomingMessage } from 'http'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\nimport type { ServerCacheStatus } from '../../next-devtools/dev-overlay/cache-indicator'\n\nconst dynamicParamTypesSchema = s.enums([\n  'c',\n  'ci(..)(..)',\n  'ci(.)',\n  'ci(..)',\n  'ci(...)',\n  'oc',\n  'd',\n  'di(..)(..)',\n  'di(.)',\n  'di(..)',\n  'di(...)',\n])\n\nconst segmentSchema = s.union([\n  s.string(),\n\n  s.tuple([\n    // Param name\n    s.string(),\n    // Param cache key (almost the same as the value, but arrays are\n    // concatenated into strings)\n    // TODO: We should change this to just be the value. Currently we convert\n    // it back to a value when passing to useParams. It only needs to be\n    // a string when converted to a a cache key, but that doesn't mean we\n    // need to store it as that representation.\n    s.string(),\n    // Dynamic param type\n    dynamicParamTypesSchema,\n  ]),\n])\n\n// unfortunately the tuple is not understood well by Describe so we have to\n// use any here. This does not have any impact on the runtime type since the validation\n// does work correctly.\nexport const flightRouterStateSchema: s.Describe<any> = s.tuple([\n  segmentSchema,\n  s.record(\n    s.string(),\n    s.lazy(() => flightRouterStateSchema)\n  ),\n  s.optional(s.nullable(s.string())),\n  s.optional(\n    s.nullable(\n      s.union([\n        s.literal('refetch'),\n        s.literal('refresh'),\n        s.literal('inside-shared-layout'),\n        s.literal('metadata-only'),\n      ])\n    )\n  ),\n  s.optional(s.boolean()),\n])\n\nexport type ServerOnInstrumentationRequestError = (\n  error: unknown,\n  // The request could be middleware, node server or web server request,\n  // we normalized them into an aligned format to `onRequestError` API later.\n  request: NextRequestHint | BaseNextRequest | IncomingMessage,\n  errorContext: Parameters<InstrumentationOnRequestError>[2],\n  silenceLog: boolean\n) => void | Promise<void>\n\nexport interface RenderOptsPartial {\n  dir?: string\n  previewProps: __ApiPreviewProps | undefined\n  err?: Error | null\n  dev?: boolean\n  basePath: string\n  cacheComponents: boolean\n  trailingSlash: boolean\n  images: ImageConfigComplete\n  supportsDynamicResponse: boolean\n  runtime?: ServerRuntime\n  serverComponents?: boolean\n  enableTainting?: boolean\n  assetPrefix?: string\n  crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined\n  nextFontManifest?: DeepReadonly<NextFontManifest>\n  botType?: 'dom' | 'html' | undefined\n  serveStreamingMetadata?: boolean\n  incrementalCache?: import('../lib/incremental-cache').IncrementalCache\n  cacheLifeProfiles?: {\n    [profile: string]: import('../use-cache/cache-life').CacheLife\n  }\n  isOnDemandRevalidate?: boolean\n  isPossibleServerAction?: boolean\n  setCacheStatus?: (status: ServerCacheStatus, htmlRequestId: string) => void\n  setIsrStatus?: (key: string, value: boolean | undefined) => void\n  setReactDebugChannel?: (\n    debugChannel: { readable: ReadableStream<Uint8Array> },\n    htmlRequestId: string,\n    requestId: string\n  ) => void\n  sendErrorsToBrowser?: (\n    errorsRscStream: ReadableStream<Uint8Array>,\n    htmlRequestId: string\n  ) => void\n  nextExport?: boolean\n  nextConfigOutput?: 'standalone' | 'export'\n  onInstrumentationRequestError?: ServerOnInstrumentationRequestError\n  isDraftMode?: boolean\n  deploymentId?: string\n  onUpdateCookies?: (cookies: string[]) => void\n  loadConfig?: (\n    phase: string,\n    dir: string,\n    customConfig?: object | null,\n    rawConfig?: boolean,\n    silent?: boolean\n  ) => Promise<NextConfigComplete>\n  serverActions?: {\n    bodySizeLimit?: SizeLimit\n    allowedOrigins?: string[]\n  }\n  params?: ParsedUrlQuery\n  isPrefetch?: boolean\n  htmlLimitedBots: string | undefined\n  experimental: {\n    /**\n     * When true, it indicates that the current page supports partial\n     * prerendering.\n     */\n    isRoutePPREnabled?: boolean\n    expireTime: number | undefined\n    staleTimes: ExperimentalConfig['staleTimes'] | undefined\n    clientTraceMetadata: string[] | undefined\n\n    /**\n     * The origins that are allowed to write the rewritten headers when\n     * performing a non-relative rewrite. When undefined, no non-relative\n     * rewrites will get the rewrite headers.\n     */\n    clientParamParsingOrigins: string[] | undefined\n    dynamicOnHover: boolean\n    inlineCss: boolean\n    authInterrupts: boolean\n\n    /**\n     * The maximum size (in bytes) of the postponed state body for PPR resume\n     * requests. Used to calculate decompression limits (5x this value).\n     */\n    maxPostponedStateSizeBytes: number | undefined\n  }\n  postponed?: string\n\n  /**\n   * Should wait for react stream allReady to resolve all suspense boundaries,\n   * in order to perform a full page render.\n   */\n  shouldWaitOnAllReady?: boolean\n\n  /**\n   * A prefilled resume data cache. This was either generated for this page\n   * during dev warmup, or when a page with defined params was previously\n   * prerendered, and now its matching optional fallback shell is prerendered.\n   */\n  renderResumeDataCache?: RenderResumeDataCache\n\n  /**\n   * When true, the page will be rendered using the static rendering to detect\n   * any dynamic API's that would have stopped the page from being fully\n   * statically generated.\n   */\n  isDebugDynamicAccesses?: boolean\n\n  /**\n   * This is true when:\n   * - source maps are generated\n   * - source maps are applied\n   * - minification is disabled\n   */\n  hasReadableErrorStacks?: boolean\n\n  /**\n   * The maximum length of the headers that are emitted by React and added to\n   * the response.\n   */\n  reactMaxHeadersLength: number | undefined\n\n  isStaticGeneration?: boolean\n\n  /**\n   * When true, the page is prerendered as a fallback shell, while allowing any\n   * dynamic accesses to result in an empty shell. This is the case when there\n   * are also routes prerendered with a more complete set of params.\n   * Prerendering those routes would catch any invalid dynamic accesses.\n   */\n  allowEmptyStaticShell?: boolean\n}\n\nexport type RenderOpts = LoadComponentsReturnType<AppPageModule> &\n  RenderOptsPartial &\n  RequestLifecycleOpts\n\nexport type PreloadCallbacks = (() => void)[]\n"],"names":["s","dynamicParamTypesSchema","enums","segmentSchema","union","string","tuple","flightRouterStateSchema","record","lazy","optional","nullable","literal","boolean"],"mappings":";;;;AAaA,OAAOA,OAAO,iCAAgC;;AAS9C,MAAMC,0BAA0BD,mMAAAA,CAAEE,KAAK,CAAC;IACtC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,MAAMC,gBAAgBH,mMAAAA,CAAEI,KAAK,CAAC;IAC5BJ,mMAAAA,CAAEK,MAAM;IAERL,mMAAAA,CAAEM,KAAK,CAAC;QACN,aAAa;QACbN,mMAAAA,CAAEK,MAAM;QACR,gEAAgE;QAChE,6BAA6B;QAC7B,yEAAyE;QACzE,oEAAoE;QACpE,qEAAqE;QACrE,2CAA2C;QAC3CL,mMAAAA,CAAEK,MAAM;QACR,qBAAqB;QACrBJ;KACD;CACF;AAKM,MAAMM,0BAA2CP,mMAAAA,CAAEM,KAAK,CAAC;IAC9DH;IACAH,mMAAAA,CAAEQ,MAAM,CACNR,mMAAAA,CAAEK,MAAM,IACRL,mMAAAA,CAAES,IAAI,CAAC,IAAMF;IAEfP,mMAAAA,CAAEU,QAAQ,CAACV,mMAAAA,CAAEW,QAAQ,CAACX,mMAAAA,CAAEK,MAAM;IAC9BL,mMAAAA,CAAEU,QAAQ,CACRV,mMAAAA,CAAEW,QAAQ,CACRX,mMAAAA,CAAEI,KAAK,CAAC;QACNJ,mMAAAA,CAAEY,OAAO,CAAC;QACVZ,mMAAAA,CAAEY,OAAO,CAAC;QACVZ,mMAAAA,CAAEY,OAAO,CAAC;QACVZ,mMAAAA,CAAEY,OAAO,CAAC;KACX;IAGLZ,mMAAAA,CAAEU,QAAQ,CAACV,mMAAAA,CAAEa,OAAO;CACrB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1843, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/parse-and-validate-flight-router-state.tsx"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport { flightRouterStateSchema } from './types'\nimport { assert } from 'next/dist/compiled/superstruct'\n\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[]\n): FlightRouterState\nexport function parseAndValidateFlightRouterState(\n  stateHeader: undefined\n): undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined {\n  if (typeof stateHeader === 'undefined') {\n    return undefined\n  }\n  if (Array.isArray(stateHeader)) {\n    throw new Error(\n      'Multiple router state headers were sent. This is not allowed.'\n    )\n  }\n\n  // We limit the size of the router state header to ~40kb. This is to prevent\n  // a malicious user from sending a very large header and slowing down the\n  // resolving of the router state.\n  // This is around 2,000 nested or parallel route segment states:\n  // '{\"children\":[\"\",{}]}'.length === 20.\n  if (stateHeader.length > 20 * 2000) {\n    throw new Error('The router state header was too large.')\n  }\n\n  try {\n    const state = JSON.parse(decodeURIComponent(stateHeader))\n    assert(state, flightRouterStateSchema)\n    return state\n  } catch {\n    throw new Error('The router state header was sent but could not be parsed.')\n  }\n}\n"],"names":["flightRouterStateSchema","assert","parseAndValidateFlightRouterState","stateHeader","undefined","Array","isArray","Error","length","state","JSON","parse","decodeURIComponent"],"mappings":";;;;AACA,SAASA,uBAAuB,QAAQ,UAAS;AACjD,SAASC,MAAM,QAAQ,iCAAgC;;;AAWhD,SAASC,kCACdC,WAA0C;IAE1C,IAAI,OAAOA,gBAAgB,aAAa;QACtC,OAAOC;IACT;IACA,IAAIC,MAAMC,OAAO,CAACH,cAAc;QAC9B,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4EAA4E;IAC5E,yEAAyE;IACzE,iCAAiC;IACjC,gEAAgE;IAChE,wCAAwC;IACxC,IAAIJ,YAAYK,MAAM,GAAG,KAAK,MAAM;QAClC,MAAM,OAAA,cAAmD,CAAnD,IAAID,MAAM,2CAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAkD;IAC1D;IAEA,IAAI;QACF,MAAME,QAAQC,KAAKC,KAAK,CAACC,mBAAmBT;YAC5CF,kMAAAA,EAAOQ,OAAOT,yNAAAA;QACd,OAAOS;IACT,EAAE,OAAM;QACN,MAAM,OAAA,cAAsE,CAAtE,IAAIF,MAAM,8DAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAqE;IAC7E;AACF","ignoreList":[0]}},
    {"offset": {"line": 1890, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/create-flight-router-state-from-loader-tree.ts"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\nimport {\n  HasLoadingBoundary,\n  type FlightRouterState,\n} from '../../shared/lib/app-router-types'\nimport type { GetDynamicParamFromSegment } from './app-render'\nimport { addSearchParamsIfPageSegment } from '../../shared/lib/segment'\n\nfunction createFlightRouterStateFromLoaderTreeImpl(\n  [segment, parallelRoutes, { layout, loading }]: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  searchParams: any,\n  includeHasLoadingBoundary: boolean,\n  didFindRootLayout: boolean\n): FlightRouterState {\n  const dynamicParam = getDynamicParamFromSegment(segment)\n  const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment\n\n  const segmentTree: FlightRouterState = [\n    addSearchParamsIfPageSegment(treeSegment, searchParams),\n    {},\n  ]\n\n  // Mark the first segment that has a layout as the \"root\" layout\n  if (!didFindRootLayout && typeof layout !== 'undefined') {\n    didFindRootLayout = true\n    segmentTree[4] = true\n  }\n\n  let childHasLoadingBoundary = false\n  const children: FlightRouterState[1] = {}\n  Object.keys(parallelRoutes).forEach((parallelRouteKey) => {\n    const child = createFlightRouterStateFromLoaderTreeImpl(\n      parallelRoutes[parallelRouteKey],\n      getDynamicParamFromSegment,\n      searchParams,\n      includeHasLoadingBoundary,\n      didFindRootLayout\n    )\n    if (\n      includeHasLoadingBoundary &&\n      child[5] !== HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n    ) {\n      childHasLoadingBoundary = true\n    }\n    children[parallelRouteKey] = child\n  })\n  segmentTree[1] = children\n\n  if (includeHasLoadingBoundary) {\n    // During a route tree prefetch, the FlightRouterState includes whether a\n    // tree has a loading boundary. The client uses this to determine if it can\n    // skip the data prefetch request  if `hasLoadingBoundary` is `false`, the\n    // data prefetch response will be empty, so there's no reason to request it.\n    // NOTE: It would be better to accumulate this while building the loader\n    // tree so we don't have to keep re-deriving it, but since this won't be\n    // once PPR is enabled everywhere, it's not that important.\n    segmentTree[5] = loading\n      ? HasLoadingBoundary.SegmentHasLoadingBoundary\n      : childHasLoadingBoundary\n        ? HasLoadingBoundary.SubtreeHasLoadingBoundary\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n  }\n\n  return segmentTree\n}\n\nexport function createFlightRouterStateFromLoaderTree(\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  searchParams: any\n) {\n  const includeHasLoadingBoundary = false\n  const didFindRootLayout = false\n  return createFlightRouterStateFromLoaderTreeImpl(\n    loaderTree,\n    getDynamicParamFromSegment,\n    searchParams,\n    includeHasLoadingBoundary,\n    didFindRootLayout\n  )\n}\n\nexport function createRouteTreePrefetch(\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): FlightRouterState {\n  // Search params should not be added to page segment's cache key during a\n  // route tree prefetch request, because they do not affect the structure of\n  // the route. The client cache has its own logic to handle search params.\n  const searchParams = {}\n  // During a route tree prefetch, we include `hasLoadingBoundary` in\n  // the response.\n  const includeHasLoadingBoundary = true\n  const didFindRootLayout = false\n  return createFlightRouterStateFromLoaderTreeImpl(\n    loaderTree,\n    getDynamicParamFromSegment,\n    searchParams,\n    includeHasLoadingBoundary,\n    didFindRootLayout\n  )\n}\n"],"names":["HasLoadingBoundary","addSearchParamsIfPageSegment","createFlightRouterStateFromLoaderTreeImpl","segment","parallelRoutes","layout","loading","getDynamicParamFromSegment","searchParams","includeHasLoadingBoundary","didFindRootLayout","dynamicParam","treeSegment","segmentTree","childHasLoadingBoundary","children","Object","keys","forEach","parallelRouteKey","child","SubtreeHasNoLoadingBoundary","SegmentHasLoadingBoundary","SubtreeHasLoadingBoundary","createFlightRouterStateFromLoaderTree","loaderTree","createRouteTreePrefetch"],"mappings":";;;;;;AACA,SACEA,kBAAkB,QAEb,oCAAmC;AAE1C,SAASC,4BAA4B,QAAQ,2BAA0B;;;AAEvE,SAASC,0CACP,CAACC,SAASC,gBAAgB,EAAEC,MAAM,EAAEC,OAAO,EAAE,CAAa,EAC1DC,0BAAsD,EACtDC,YAAiB,EACjBC,yBAAkC,EAClCC,iBAA0B;IAE1B,MAAMC,eAAeJ,2BAA2BJ;IAChD,MAAMS,cAAcD,eAAeA,aAAaC,WAAW,GAAGT;IAE9D,MAAMU,cAAiC;YACrCZ,sNAAAA,EAA6BW,aAAaJ;QAC1C,CAAC;KACF;IAED,gEAAgE;IAChE,IAAI,CAACE,qBAAqB,OAAOL,WAAW,aAAa;QACvDK,oBAAoB;QACpBG,WAAW,CAAC,EAAE,GAAG;IACnB;IAEA,IAAIC,0BAA0B;IAC9B,MAAMC,WAAiC,CAAC;IACxCC,OAAOC,IAAI,CAACb,gBAAgBc,OAAO,CAAC,CAACC;QACnC,MAAMC,QAAQlB,0CACZE,cAAc,CAACe,iBAAiB,EAChCZ,4BACAC,cACAC,2BACAC;QAEF,IACED,6BACAW,KAAK,CAAC,EAAE,KAAKpB,2NAAAA,CAAmBqB,2BAA2B,EAC3D;YACAP,0BAA0B;QAC5B;QACAC,QAAQ,CAACI,iBAAiB,GAAGC;IAC/B;IACAP,WAAW,CAAC,EAAE,GAAGE;IAEjB,IAAIN,2BAA2B;QAC7B,yEAAyE;QACzE,2EAA2E;QAC3E,2EAA2E;QAC3E,4EAA4E;QAC5E,wEAAwE;QACxE,wEAAwE;QACxE,2DAA2D;QAC3DI,WAAW,CAAC,EAAE,GAAGP,UACbN,2NAAAA,CAAmBsB,yBAAyB,GAC5CR,0BACEd,2NAAAA,CAAmBuB,yBAAyB,GAC5CvB,2NAAAA,CAAmBqB,2BAA2B;IACtD;IAEA,OAAOR;AACT;AAEO,SAASW,sCACdC,UAAsB,EACtBlB,0BAAsD,EACtDC,YAAiB;IAEjB,MAAMC,4BAA4B;IAClC,MAAMC,oBAAoB;IAC1B,OAAOR,0CACLuB,YACAlB,4BACAC,cACAC,2BACAC;AAEJ;AAEO,SAASgB,wBACdD,UAAsB,EACtBlB,0BAAsD;IAEtD,yEAAyE;IACzE,2EAA2E;IAC3E,yEAAyE;IACzE,MAAMC,eAAe,CAAC;IACtB,mEAAmE;IACnE,gBAAgB;IAChB,MAAMC,4BAA4B;IAClC,MAAMC,oBAAoB;IAC1B,OAAOR,0CACLuB,YACAlB,4BACAC,cACAC,2BACAC;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 1954, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/csrf-protection.ts"],"sourcesContent":["// micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function\n// can be run from edge. This is a simple implementation that safely achieves the required functionality.\n// the goal is to match the functionality for remotePatterns as defined here -\n// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns\n// TODO - retrofit micromatch to work in edge and use that instead\nfunction matchWildcardDomain(domain: string, pattern: string) {\n  const domainParts = domain.split('.')\n  const patternParts = pattern.split('.')\n\n  if (patternParts.length < 1) {\n    // pattern is empty and therefore invalid to match against\n    return false\n  }\n\n  if (domainParts.length < patternParts.length) {\n    // domain has too few segments and thus cannot match\n    return false\n  }\n\n  // Prevent wildcards from matching entire domains (e.g. '**' or '*.com')\n  // This ensures wildcards can only match subdomains, not the main domain\n  if (\n    patternParts.length === 1 &&\n    (patternParts[0] === '*' || patternParts[0] === '**')\n  ) {\n    return false\n  }\n\n  while (patternParts.length) {\n    const patternPart = patternParts.pop()\n    const domainPart = domainParts.pop()\n\n    switch (patternPart) {\n      case '': {\n        // invalid pattern. pattern segments must be non empty\n        return false\n      }\n      case '*': {\n        // wildcard matches anything so we continue if the domain part is non-empty\n        if (domainPart) {\n          continue\n        } else {\n          return false\n        }\n      }\n      case '**': {\n        // if this is not the last item in the pattern the pattern is invalid\n        if (patternParts.length > 0) {\n          return false\n        }\n        // recursive wildcard matches anything so we terminate here if the domain part is non empty\n        return domainPart !== undefined\n      }\n      case undefined:\n      default: {\n        if (domainPart !== patternPart) {\n          return false\n        }\n      }\n    }\n  }\n\n  // We exhausted the pattern. If we also exhausted the domain we have a match\n  return domainParts.length === 0\n}\n\nexport const isCsrfOriginAllowed = (\n  originDomain: string,\n  allowedOrigins: string[] = []\n): boolean => {\n  return allowedOrigins.some(\n    (allowedOrigin) =>\n      allowedOrigin &&\n      (allowedOrigin === originDomain ||\n        matchWildcardDomain(originDomain, allowedOrigin))\n  )\n}\n"],"names":["matchWildcardDomain","domain","pattern","domainParts","split","patternParts","length","patternPart","pop","domainPart","undefined","isCsrfOriginAllowed","originDomain","allowedOrigins","some","allowedOrigin"],"mappings":";;;;AAAA,uHAAuH;AACvH,yGAAyG;AACzG,8EAA8E;AAC9E,4EAA4E;AAC5E,kEAAkE;AAClE,SAASA,oBAAoBC,MAAc,EAAEC,OAAe;IAC1D,MAAMC,cAAcF,OAAOG,KAAK,CAAC;IACjC,MAAMC,eAAeH,QAAQE,KAAK,CAAC;IAEnC,IAAIC,aAAaC,MAAM,GAAG,GAAG;QAC3B,0DAA0D;QAC1D,OAAO;IACT;IAEA,IAAIH,YAAYG,MAAM,GAAGD,aAAaC,MAAM,EAAE;QAC5C,oDAAoD;QACpD,OAAO;IACT;IAEA,wEAAwE;IACxE,wEAAwE;IACxE,IACED,aAAaC,MAAM,KAAK,KACvBD,CAAAA,YAAY,CAAC,EAAE,KAAK,OAAOA,YAAY,CAAC,EAAE,KAAK,IAAG,GACnD;QACA,OAAO;IACT;IAEA,MAAOA,aAAaC,MAAM,CAAE;QAC1B,MAAMC,cAAcF,aAAaG,GAAG;QACpC,MAAMC,aAAaN,YAAYK,GAAG;QAElC,OAAQD;YACN,KAAK;gBAAI;oBACP,sDAAsD;oBACtD,OAAO;gBACT;YACA,KAAK;gBAAK;oBACR,2EAA2E;oBAC3E,IAAIE,YAAY;wBACd;oBACF,OAAO;wBACL,OAAO;oBACT;gBACF;YACA,KAAK;gBAAM;oBACT,qEAAqE;oBACrE,IAAIJ,aAAaC,MAAM,GAAG,GAAG;wBAC3B,OAAO;oBACT;oBACA,2FAA2F;oBAC3F,OAAOG,eAAeC;gBACxB;YACA,KAAKA;YACL;gBAAS;oBACP,IAAID,eAAeF,aAAa;wBAC9B,OAAO;oBACT;gBACF;QACF;IACF;IAEA,4EAA4E;IAC5E,OAAOJ,YAAYG,MAAM,KAAK;AAChC;AAEO,MAAMK,sBAAsB,CACjCC,cACAC,iBAA2B,EAAE;IAE7B,OAAOA,eAAeC,IAAI,CACxB,CAACC,gBACCA,iBACCA,CAAAA,kBAAkBH,gBACjBZ,oBAAoBY,cAAcG,cAAa;AAEvD,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2025, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/manifests-singleton.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nexport interface ServerModuleMap {\n  readonly [name: string]: {\n    readonly id: string | number\n    readonly name: string\n    readonly chunks: Readonly<Array<string>> // currently not used\n    readonly async?: boolean\n  }\n}\n\n// This is a global singleton that is, among other things, also used to\n// encode/decode bound args of server function closures. This can't be using a\n// AsyncLocalStorage as it might happen at the module level.\nconst MANIFESTS_SINGLETON = Symbol.for('next.server.manifests')\n\ninterface ManifestsSingleton {\n  readonly clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n  readonly proxiedClientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: ServerModuleMap\n}\n\ntype GlobalThisWithManifests = typeof globalThis & {\n  [MANIFESTS_SINGLETON]?: ManifestsSingleton\n}\n\ntype ClientReferenceManifestMappingProp =\n  | 'clientModules'\n  | 'rscModuleMapping'\n  | 'edgeRscModuleMapping'\n  | 'ssrModuleMapping'\n  | 'edgeSSRModuleMapping'\n\nconst globalThisWithManifests = globalThis as GlobalThisWithManifests\n\nfunction createProxiedClientReferenceManifest(\n  clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n): DeepReadonly<ClientReferenceManifest> {\n  const createMappingProxy = (prop: ClientReferenceManifestMappingProp) => {\n    return new Proxy(\n      {},\n      {\n        get(_, id: string) {\n          const workStore = workAsyncStorage.getStore()\n\n          if (workStore) {\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (currentManifest?.[prop][id]) {\n              return currentManifest[prop][id]\n            }\n\n            // In development, we also check all other manifests to see if the\n            // module exists there. This is to support a scenario where React's\n            // I/O tracking (dev-only) creates a connection from one page to\n            // another through an emitted async I/O node that references client\n            // components from the other page, e.g. in owner props.\n            // TODO: Maybe we need to add a `debugBundlerConfig` option to React\n            // to avoid this workaround. The current workaround has the\n            // disadvantage that one might accidentally or intentionally share\n            // client references across pages (e.g. by storing them in a global\n            // variable), which would then only be caught in production.\n            if (process.env.NODE_ENV !== 'production') {\n              for (const [\n                route,\n                manifest,\n              ] of clientReferenceManifestsPerRoute) {\n                if (route === workStore.route) {\n                  continue\n                }\n\n                const entry = manifest[prop][id]\n\n                if (entry !== undefined) {\n                  return entry\n                }\n              }\n            }\n          } else {\n            // If there's no work store defined, we can assume that a client\n            // reference manifest is needed during module evaluation, e.g. to\n            // create a server function using a higher-order function. This\n            // might also use client components which need to be serialized by\n            // Flight, and therefore client references need to be resolvable. In\n            // that case we search all page manifests to find the module.\n            for (const manifest of clientReferenceManifestsPerRoute.values()) {\n              const entry = manifest[prop][id]\n\n              if (entry !== undefined) {\n                return entry\n              }\n            }\n          }\n\n          return undefined\n        },\n      }\n    )\n  }\n\n  const mappingProxies = new Map<\n    ClientReferenceManifestMappingProp,\n    ReturnType<typeof createMappingProxy>\n  >()\n\n  return new Proxy(\n    {},\n    {\n      get(_, prop) {\n        const workStore = workAsyncStorage.getStore()\n\n        switch (prop) {\n          case 'moduleLoading':\n          case 'entryCSSFiles':\n          case 'entryJSFiles': {\n            if (!workStore) {\n              throw new InvariantError(\n                `Cannot access \"${prop}\" without a work store.`\n              )\n            }\n\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (!currentManifest) {\n              throw new InvariantError(\n                `The client reference manifest for route \"${workStore.route}\" does not exist.`\n              )\n            }\n\n            return currentManifest[prop]\n          }\n          case 'clientModules':\n          case 'rscModuleMapping':\n          case 'edgeRscModuleMapping':\n          case 'ssrModuleMapping':\n          case 'edgeSSRModuleMapping': {\n            let proxy = mappingProxies.get(prop)\n\n            if (!proxy) {\n              proxy = createMappingProxy(prop)\n              mappingProxies.set(prop, proxy)\n            }\n\n            return proxy\n          }\n          default: {\n            throw new InvariantError(\n              `This is a proxied client reference manifest. The property \"${String(prop)}\" is not handled.`\n            )\n          }\n        }\n      },\n    }\n  ) as DeepReadonly<ClientReferenceManifest>\n}\n\n/**\n * This function creates a Flight-acceptable server module map proxy from our\n * Server Reference Manifest similar to our client module map. This is because\n * our manifest contains a lot of internal Next.js data that are relevant to the\n * runtime, workers, etc. that React doesn't need to know.\n */\nfunction createServerModuleMap(): ServerModuleMap {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          getServerActionsManifest()[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ]?.[id]?.workers\n\n        if (!workers) {\n          return undefined\n        }\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n * with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page\n * name.\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string\n): string | undefined {\n  const serverActionsManifest = getServerActionsManifest()\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n\n  // There are no workers to handle this action, nothing to forward to.\n  if (!workers) {\n    return\n  }\n\n  // If there is an entry for the current page, we don't need to forward.\n  if (workers[normalizeWorkerPageName(pageName)]) {\n    return\n  }\n\n  // Otherwise, grab the first worker that has a handler for this action id.\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\nexport function setManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n}) {\n  const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (existingSingleton) {\n    existingSingleton.clientReferenceManifestsPerRoute.set(\n      normalizeAppPath(page),\n      clientReferenceManifest\n    )\n\n    existingSingleton.serverActionsManifest = serverActionsManifest\n  } else {\n    const clientReferenceManifestsPerRoute = new Map<\n      string,\n      DeepReadonly<ClientReferenceManifest>\n    >([[normalizeAppPath(page), clientReferenceManifest]])\n\n    const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(\n      clientReferenceManifestsPerRoute\n    )\n\n    globalThisWithManifests[MANIFESTS_SINGLETON] = {\n      clientReferenceManifestsPerRoute,\n      proxiedClientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap(),\n    }\n  }\n}\n\nfunction getManifestsSingleton(): ManifestsSingleton {\n  const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (!manifestSingleton) {\n    throw new InvariantError('The manifests singleton was not initialized.')\n  }\n\n  return manifestSingleton\n}\n\nexport function getClientReferenceManifest(): DeepReadonly<ClientReferenceManifest> {\n  return getManifestsSingleton().proxiedClientReferenceManifest\n}\n\nexport function getServerActionsManifest(): DeepReadonly<ActionManifest> {\n  return getManifestsSingleton().serverActionsManifest\n}\n\nexport function getServerModuleMap() {\n  return getManifestsSingleton().serverModuleMap\n}\n"],"names":["InvariantError","normalizeAppPath","pathHasPrefix","removePathPrefix","workAsyncStorage","MANIFESTS_SINGLETON","Symbol","for","globalThisWithManifests","globalThis","createProxiedClientReferenceManifest","clientReferenceManifestsPerRoute","createMappingProxy","prop","Proxy","get","_","id","workStore","getStore","currentManifest","route","process","env","NODE_ENV","manifest","entry","undefined","values","mappingProxies","Map","proxy","set","String","createServerModuleMap","getServerActionsManifest","workers","NEXT_RUNTIME","workerEntry","normalizeWorkerPageName","page","Object","at","moduleId","async","name","chunks","pageName","denormalizeWorkerPageName","bundlePath","selectWorkerForForwarding","actionId","serverActionsManifest","keys","setManifestsSingleton","clientReferenceManifest","existingSingleton","proxiedClientReferenceManifest","serverModuleMap","getManifestsSingleton","manifestSingleton","getClientReferenceManifest","getServerModuleMap"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2268, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/action-handler.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'node:http'\nimport type { SizeLimit } from '../../types'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { AppRenderContext, GenerateFlight } from './app-render'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\n\nimport {\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_URL,\n  NEXT_ACTION_REVALIDATED_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getRedirectTypeFromError,\n  getURLFromRedirectError,\n} from '../../client/components/redirect'\nimport {\n  isRedirectError,\n  type RedirectType,\n} from '../../client/components/redirect-error'\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n} from '../render-result'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  filterReqHeaders,\n  actionsForbiddenHeaders,\n} from '../lib/server-ipc/utils'\nimport { getModifiedCookieValues } from '../web/spec-extension/adapters/request-cookies'\n\nimport {\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n} from '../../lib/constants'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { isCsrfOriginAllowed } from './csrf-protection'\nimport { warn } from '../../build/output/log'\nimport { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport { fromNodeOutgoingHttpHeaders } from '../web/utils'\nimport {\n  selectWorkerForForwarding,\n  type ServerModuleMap,\n  getServerActionsManifest,\n  getServerModuleMap,\n} from './manifests-singleton'\nimport { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { synchronizeMutableCookies } from '../async-storage/request-store'\nimport type { TemporaryReferenceSet } from 'react-server-dom-webpack/server'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { executeRevalidates } from '../revalidation-utils'\nimport { getRequestMeta } from '../request-meta'\nimport { setCacheBustingSearchParam } from '../../client/components/router-reducer/set-cache-busting-search-param'\nimport {\n  ActionDidNotRevalidate,\n  ActionDidRevalidateStaticAndDynamic,\n} from '../../shared/lib/action-revalidation-kind'\n\n/**\n * Checks if the app has any server actions defined in any runtime.\n */\nfunction hasServerActions() {\n  const serverActionsManifest = getServerActionsManifest()\n\n  return (\n    Object.keys(serverActionsManifest.node).length > 0 ||\n    Object.keys(serverActionsManifest.edge).length > 0\n  )\n}\n\nfunction nodeHeadersToRecord(\n  headers: IncomingHttpHeaders | OutgoingHttpHeaders\n) {\n  const record: Record<string, string> = {}\n  for (const [key, value] of Object.entries(headers)) {\n    if (value !== undefined) {\n      record[key] = Array.isArray(value) ? value.join(', ') : `${value}`\n    }\n  }\n  return record\n}\n\nfunction getForwardedHeaders(\n  req: BaseNextRequest,\n  res: BaseNextResponse\n): Headers {\n  // Get request headers and cookies\n  const requestHeaders = req.headers\n  const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders))\n\n  // Get response headers and cookies\n  const responseHeaders = res.getHeaders()\n  const responseCookies = new ResponseCookies(\n    fromNodeOutgoingHttpHeaders(responseHeaders)\n  )\n\n  // Merge request and response headers\n  const mergedHeaders = filterReqHeaders(\n    {\n      ...nodeHeadersToRecord(requestHeaders),\n      ...nodeHeadersToRecord(responseHeaders),\n    },\n    actionsForbiddenHeaders\n  ) as Record<string, string>\n\n  // Merge cookies into requestCookies, so responseCookies always take precedence\n  // and overwrite/delete those from requestCookies.\n  responseCookies.getAll().forEach((cookie) => {\n    if (typeof cookie.value === 'undefined') {\n      requestCookies.delete(cookie.name)\n    } else {\n      requestCookies.set(cookie)\n    }\n  })\n\n  // Update the 'cookie' header with the merged cookies\n  mergedHeaders['cookie'] = requestCookies.toString()\n\n  // Remove headers that should not be forwarded\n  delete mergedHeaders['transfer-encoding']\n\n  return new Headers(mergedHeaders)\n}\n\nfunction addRevalidationHeader(\n  res: BaseNextResponse,\n  {\n    workStore,\n    requestStore,\n  }: {\n    workStore: WorkStore\n    requestStore: RequestStore\n  }\n) {\n  // If a tag was revalidated, the client router needs to invalidate all the\n  // client router cache as they may be stale. And if a path was revalidated, the\n  // client needs to invalidate all subtrees below that path.\n\n  // TODO: Currently we don't send the specific tags or paths to the client,\n  // we just send a flag indicating that all the static data on the client\n  // should be invalidated. In the future, this will likely be a Bloom filter\n  // or bitmask of some kind.\n\n  // TODO-APP: Currently the prefetch cache doesn't have subtree information,\n  // so we need to invalidate the entire cache if a path was revalidated.\n  // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n  // is always empty.\n\n  const isTagRevalidated = workStore.pendingRevalidatedTags?.length ? 1 : 0\n  const isCookieRevalidated = getModifiedCookieValues(\n    requestStore.mutableCookies\n  ).length\n    ? 1\n    : 0\n\n  // First check if a tag, cookie, or path was revalidated.\n  if (isTagRevalidated || isCookieRevalidated) {\n    res.setHeader(\n      NEXT_ACTION_REVALIDATED_HEADER,\n      JSON.stringify(ActionDidRevalidateStaticAndDynamic)\n    )\n  } else if (\n    // Check for refresh() actions. This will invalidate only the dynamic data.\n    workStore.pathWasRevalidated !== undefined &&\n    workStore.pathWasRevalidated !== ActionDidNotRevalidate\n  ) {\n    res.setHeader(\n      NEXT_ACTION_REVALIDATED_HEADER,\n      JSON.stringify(workStore.pathWasRevalidated)\n    )\n  }\n}\n\n/**\n * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.\n */\nasync function createForwardedActionResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  host: Host,\n  workerPathname: string,\n  basePath: string\n) {\n  if (!host) {\n    throw new Error(\n      'Invariant: Missing `host` header from a forwarded Server Actions request.'\n    )\n  }\n\n  const forwardedHeaders = getForwardedHeaders(req, res)\n\n  // indicate that this action request was forwarded from another worker\n  // we use this to skip rendering the flight tree so that we don't update the UI\n  // with the response from the forwarded worker\n  forwardedHeaders.set('x-action-forwarded', '1')\n\n  const proto =\n    getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'\n\n  // For standalone or the serverful mode, use the internal origin directly\n  // other than the host headers from the request.\n  const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`\n\n  const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`)\n\n  try {\n    let body: BodyInit | ReadableStream<Uint8Array> | undefined\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME === 'edge' &&\n      isWebNextRequest(req)\n    ) {\n      if (!req.body) {\n        throw new Error('Invariant: missing request body.')\n      }\n\n      body = req.body\n    } else if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      body = req.stream()\n    } else {\n      throw new Error('Invariant: Unknown request type.')\n    }\n\n    // Forward the request to the new worker\n    const response = await fetch(fetchUrl, {\n      method: 'POST',\n      body,\n      duplex: 'half',\n      headers: forwardedHeaders,\n      redirect: 'manual',\n      next: {\n        // @ts-ignore\n        internal: 1,\n      },\n    })\n\n    if (\n      response.headers.get('content-type')?.startsWith(RSC_CONTENT_TYPE_HEADER)\n    ) {\n      // copy the headers from the redirect response to the response we're sending\n      for (const [key, value] of response.headers) {\n        if (!actionsForbiddenHeaders.includes(key)) {\n          res.setHeader(key, value)\n        }\n      }\n\n      return new FlightRenderResult(response.body!)\n    } else {\n      // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n      response.body?.cancel()\n    }\n  } catch (err) {\n    // we couldn't stream the forwarded response, so we'll just return an empty response\n    console.error(`failed to forward action response`, err)\n  }\n\n  return RenderResult.fromStatic('{}', JSON_CONTENT_TYPE_HEADER)\n}\n\n/**\n * Returns the parsed redirect URL if we deem that it is hosted by us.\n *\n * We handle both relative and absolute redirect URLs.\n *\n * In case the redirect URL is not relative to the application we return `null`.\n */\nfunction getAppRelativeRedirectUrl(\n  basePath: string,\n  host: Host,\n  redirectUrl: string,\n  currentPathname?: string\n): URL | null {\n  if (redirectUrl.startsWith('/')) {\n    // Absolute path - just add basePath\n    return new URL(`${basePath}${redirectUrl}`, 'http://n')\n  } else if (redirectUrl.startsWith('.')) {\n    // Relative path - resolve relative to current pathname\n    let base = currentPathname || '/'\n    // Ensure the base path ends with a slash so relative resolution works correctly\n    // e.g., \"./subpage\" from \"/subdir\" should resolve to \"/subdir/subpage\"\n    // not \"/subpage\"\n    if (!base.endsWith('/')) {\n      base = base + '/'\n    }\n    const resolved = new URL(redirectUrl, `http://n${base}`)\n    // Include basePath in the final URL\n    return new URL(\n      `${basePath}${resolved.pathname}${resolved.search}${resolved.hash}`,\n      'http://n'\n    )\n  }\n\n  const parsedRedirectUrl = new URL(redirectUrl)\n\n  if (host?.value !== parsedRedirectUrl.host) {\n    return null\n  }\n\n  // At this point the hosts are the same, just confirm we\n  // are routing to a path underneath the `basePath`\n  return parsedRedirectUrl.pathname.startsWith(basePath)\n    ? parsedRedirectUrl\n    : null\n}\n\nasync function createRedirectRenderResult(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  originalHost: Host,\n  redirectUrl: string,\n  redirectType: RedirectType,\n  basePath: string,\n  workStore: WorkStore,\n  currentPathname?: string\n) {\n  res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)\n\n  // If we're redirecting to another route of this Next.js application, we'll\n  // try to stream the response from the other worker path. When that works,\n  // we can save an extra roundtrip and avoid a full page reload.\n  // When the redirect URL starts with a `/` or is to the same host, under the\n  // `basePath` we treat it as an app-relative redirect;\n  const appRelativeRedirectUrl = getAppRelativeRedirectUrl(\n    basePath,\n    originalHost,\n    redirectUrl,\n    currentPathname\n  )\n\n  if (appRelativeRedirectUrl) {\n    if (!originalHost) {\n      throw new Error(\n        'Invariant: Missing `host` header from a forwarded Server Actions request.'\n      )\n    }\n\n    const forwardedHeaders = getForwardedHeaders(req, res)\n    forwardedHeaders.set(RSC_HEADER, '1')\n\n    const proto =\n      getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'\n\n    // For standalone or the serverful mode, use the internal origin directly\n    // other than the host headers from the request.\n    const origin =\n      process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`\n\n    const fetchUrl = new URL(\n      `${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`\n    )\n\n    if (workStore.pendingRevalidatedTags) {\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n        workStore.pendingRevalidatedTags.map((item) => item.tag).join(',')\n      )\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n        workStore.incrementalCache?.prerenderManifest?.preview?.previewModeId ||\n          ''\n      )\n    }\n\n    // Ensures that when the path was revalidated we don't return a partial response on redirects\n    forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER)\n    // When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request\n    // to the requested URL. We should remove the `next-action` header so that it's not treated as an action\n    forwardedHeaders.delete(ACTION_HEADER)\n\n    try {\n      setCacheBustingSearchParam(fetchUrl, {\n        [NEXT_ROUTER_PREFETCH_HEADER]: forwardedHeaders.get(\n          NEXT_ROUTER_PREFETCH_HEADER\n        )\n          ? ('1' as const)\n          : undefined,\n        [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]:\n          forwardedHeaders.get(NEXT_ROUTER_SEGMENT_PREFETCH_HEADER) ??\n          undefined,\n        [NEXT_ROUTER_STATE_TREE_HEADER]:\n          forwardedHeaders.get(NEXT_ROUTER_STATE_TREE_HEADER) ?? undefined,\n        [NEXT_URL]: forwardedHeaders.get(NEXT_URL) ?? undefined,\n      })\n\n      const response = await fetch(fetchUrl, {\n        method: 'GET',\n        headers: forwardedHeaders,\n        next: {\n          // @ts-ignore\n          internal: 1,\n        },\n      })\n\n      if (\n        response.headers\n          .get('content-type')\n          ?.startsWith(RSC_CONTENT_TYPE_HEADER)\n      ) {\n        // copy the headers from the redirect response to the response we're sending\n        for (const [key, value] of response.headers) {\n          if (!actionsForbiddenHeaders.includes(key)) {\n            res.setHeader(key, value)\n          }\n        }\n\n        return new FlightRenderResult(response.body!)\n      } else {\n        // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n        response.body?.cancel()\n      }\n    } catch (err) {\n      // we couldn't stream the redirect response, so we'll just do a normal redirect\n      console.error(`failed to get redirect response`, err)\n    }\n  }\n\n  return RenderResult.EMPTY\n}\n\n// Used to compare Host header and Origin header.\nconst enum HostType {\n  XForwardedHost = 'x-forwarded-host',\n  Host = 'host',\n}\ntype Host =\n  | {\n      type: HostType.XForwardedHost\n      value: string\n    }\n  | {\n      type: HostType.Host\n      value: string\n    }\n  | undefined\n\n/**\n * Ensures the value of the header can't create long logs.\n */\nfunction limitUntrustedHeaderValueForLogs(value: string) {\n  return value.length > 100 ? value.slice(0, 100) + '...' : value\n}\n\nexport function parseHostHeader(\n  headers: IncomingHttpHeaders,\n  originDomain?: string\n) {\n  const forwardedHostHeader = headers['x-forwarded-host']\n  const forwardedHostHeaderValue =\n    forwardedHostHeader && Array.isArray(forwardedHostHeader)\n      ? forwardedHostHeader[0]\n      : forwardedHostHeader?.split(',')?.[0]?.trim()\n  const hostHeader = headers['host']\n\n  if (originDomain) {\n    return forwardedHostHeaderValue === originDomain\n      ? {\n          type: HostType.XForwardedHost,\n          value: forwardedHostHeaderValue,\n        }\n      : hostHeader === originDomain\n        ? {\n            type: HostType.Host,\n            value: hostHeader,\n          }\n        : undefined\n  }\n\n  return forwardedHostHeaderValue\n    ? {\n        type: HostType.XForwardedHost,\n        value: forwardedHostHeaderValue,\n      }\n    : hostHeader\n      ? {\n          type: HostType.Host,\n          value: hostHeader,\n        }\n      : undefined\n}\n\ntype ServerActionsConfig = {\n  bodySizeLimit?: SizeLimit\n  allowedOrigins?: string[]\n}\n\ntype HandleActionResult =\n  | {\n      /** An MPA action threw notFound(), and we need to render the appropriate HTML */\n      type: 'not-found'\n    }\n  | {\n      type: 'done'\n      result: RenderResult | undefined\n      formState?: any\n    }\n  /** The request turned out not to be a server action. */\n  | null\n\nexport async function handleAction({\n  req,\n  res,\n  ComponentMod,\n  generateFlight,\n  workStore,\n  requestStore,\n  serverActions,\n  ctx,\n  metadata,\n}: {\n  req: BaseNextRequest\n  res: BaseNextResponse\n  ComponentMod: AppPageModule\n  generateFlight: GenerateFlight\n  workStore: WorkStore\n  requestStore: RequestStore\n  serverActions?: ServerActionsConfig\n  ctx: AppRenderContext\n  metadata: AppPageRenderResultMetadata\n}): Promise<HandleActionResult> {\n  const contentType = req.headers['content-type']\n  const { page } = ctx.renderOpts\n  const serverModuleMap = getServerModuleMap()\n\n  const {\n    actionId,\n    isMultipartAction,\n    isFetchAction,\n    isURLEncodedAction,\n    isPossibleServerAction,\n  } = getServerActionRequestMetadata(req)\n\n  const handleUnrecognizedFetchAction = (err: unknown): HandleActionResult => {\n    // If the deployment doesn't have skew protection, this is expected to occasionally happen,\n    // so we use a warning instead of an error.\n    console.warn(err)\n\n    // Return an empty response with a header that the client router will interpret.\n    // We don't need to waste time encoding a flight response, and using a blank body + header\n    // means that unrecognized actions can also be handled at the infra level\n    // (i.e. without needing to invoke a lambda)\n    res.setHeader(NEXT_ACTION_NOT_FOUND_HEADER, '1')\n    res.setHeader('content-type', 'text/plain')\n    res.statusCode = 404\n    return {\n      type: 'done',\n      result: RenderResult.fromStatic('Server action not found.', 'text/plain'),\n    }\n  }\n\n  // If it can't be a Server Action, skip handling.\n  // Note that this can be a false positive -- any multipart/urlencoded POST can get us here,\n  // But won't know if it's an MPA action or not until we call `decodeAction` below.\n  if (!isPossibleServerAction) {\n    return null\n  }\n\n  // We don't currently support URL encoded actions, so we bail out early.\n  // Depending on if it's a fetch action or an MPA, we return a different response.\n  if (isURLEncodedAction) {\n    if (isFetchAction) {\n      return {\n        type: 'not-found',\n      }\n    } else {\n      // This is an MPA action, so we return null\n      return null\n    }\n  }\n\n  // If the app has no server actions at all, we can 404 early.\n  if (!hasServerActions()) {\n    return handleUnrecognizedFetchAction(getActionNotFoundError(actionId))\n  }\n\n  if (workStore.isStaticGeneration) {\n    throw new Error(\n      \"Invariant: server actions can't be handled during static rendering\"\n    )\n  }\n\n  let temporaryReferences: TemporaryReferenceSet | undefined\n\n  // When running actions the default is no-store, you can still `cache: 'force-cache'`\n  workStore.fetchCache = 'default-no-store'\n\n  const originHeader = req.headers['origin']\n  const originDomain =\n    typeof originHeader === 'string' && originHeader !== 'null'\n      ? new URL(originHeader).host\n      : undefined\n  const host = parseHostHeader(req.headers)\n\n  let warning: string | undefined = undefined\n\n  function warnBadServerActionRequest() {\n    if (warning) {\n      warn(warning)\n    }\n  }\n  // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to\n  // ensure that the request is coming from the same host.\n  if (!originDomain) {\n    // This might be an old browser that doesn't send `host` header. We ignore\n    // this case.\n    warning = 'Missing `origin` header from a forwarded Server Actions request.'\n  } else if (!host || originDomain !== host.value) {\n    // If the customer sets a list of allowed origins, we'll allow the request.\n    // These are considered safe but might be different from forwarded host set\n    // by the infra (i.e. reverse proxies).\n    if (isCsrfOriginAllowed(originDomain, serverActions?.allowedOrigins)) {\n      // Ignore it\n    } else {\n      if (host) {\n        // This seems to be an CSRF attack. We should not proceed the action.\n        console.error(\n          `\\`${\n            host.type\n          }\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            host.value\n          )}\\` does not match \\`origin\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            originDomain\n          )}\\` from a forwarded Server Actions request. Aborting the action.`\n        )\n      } else {\n        // This is an attack. We should not proceed the action.\n        console.error(\n          `\\`x-forwarded-host\\` or \\`host\\` headers are not provided. One of these is needed to compare the \\`origin\\` header from a forwarded Server Actions request. Aborting the action.`\n        )\n      }\n\n      const error = new Error('Invalid Server Actions request.')\n\n      if (isFetchAction) {\n        res.statusCode = 500\n        metadata.statusCode = 500\n\n        const promise = Promise.reject(error)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n\n        return {\n          type: 'done',\n          result: await generateFlight(req, ctx, requestStore, {\n            actionResult: promise,\n            // We didn't execute an action, so no revalidations could have\n            // occurred. We can skip rendering the page.\n            skipPageRendering: true,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      throw error\n    }\n  }\n\n  // ensure we avoid caching server actions unexpectedly\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  const { actionAsyncStorage } = ComponentMod\n\n  const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])\n\n  if (actionId) {\n    const forwardedWorker = selectWorkerForForwarding(actionId, page)\n\n    // If forwardedWorker is truthy, it means there isn't a worker for the action\n    // in the current handler, so we forward the request to a worker that has the action.\n    if (forwardedWorker) {\n      return {\n        type: 'done',\n        result: await createForwardedActionResponse(\n          req,\n          res,\n          host,\n          forwardedWorker,\n          ctx.renderOpts.basePath\n        ),\n      }\n    }\n  }\n\n  try {\n    return await actionAsyncStorage.run(\n      { isAction: true },\n      async (): Promise<HandleActionResult> => {\n        // We only use these for fetch actions -- MPA actions handle them inside `decodeAction`.\n        let actionModId: string | number | undefined\n        let boundActionArguments: unknown[] = []\n\n        if (\n          // The type check here ensures that `req` is correctly typed, and the\n          // environment variable check provides dead code elimination.\n          process.env.NEXT_RUNTIME === 'edge' &&\n          isWebNextRequest(req)\n        ) {\n          if (!req.body) {\n            throw new Error('invariant: Missing request body.')\n          }\n\n          // TODO: add body limit\n\n          // Use react-server-dom-webpack/server\n          const {\n            createTemporaryReferenceSet,\n            decodeReply,\n            decodeAction,\n            decodeFormState,\n          } = ComponentMod\n\n          temporaryReferences = createTemporaryReferenceSet()\n\n          if (isMultipartAction) {\n            // TODO-APP: Add streaming support\n            const formData = await req.request.formData()\n            if (isFetchAction) {\n              // A fetch action with a multipart body.\n\n              try {\n                actionModId = getActionModIdOrError(actionId, serverModuleMap)\n              } catch (err) {\n                return handleUnrecognizedFetchAction(err)\n              }\n\n              boundActionArguments = await decodeReply(\n                formData,\n                serverModuleMap,\n                { temporaryReferences }\n              )\n            } else {\n              // Multipart POST, but not a fetch action.\n              // Potentially an MPA action, we have to try decoding it to check.\n              if (areAllActionIdsValid(formData, serverModuleMap) === false) {\n                // TODO: This can be from skew or manipulated input. We should handle this case\n                // more gracefully but this preserves the prior behavior where decodeAction would throw instead.\n                throw new Error(\n                  `Failed to find Server Action. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n                )\n              }\n\n              const action = await decodeAction(formData, serverModuleMap)\n              if (typeof action === 'function') {\n                // an MPA action.\n\n                // Only warn if it's a server action, otherwise skip for other post requests\n                warnBadServerActionRequest()\n\n                const { actionResult } = await executeActionAndPrepareForRender(\n                  action as () => Promise<unknown>,\n                  [],\n                  workStore,\n                  requestStore,\n                  actionWasForwarded\n                )\n\n                const formState = await decodeFormState(\n                  actionResult,\n                  formData,\n                  serverModuleMap\n                )\n\n                // Skip the fetch path.\n                // We need to render a full HTML version of the page for the response, we'll handle that in app-render.\n                return {\n                  type: 'done',\n                  result: undefined,\n                  formState,\n                }\n              } else {\n                // We couldn't decode an action, so this POST request turned out not to be a server action request.\n                return null\n              }\n            }\n          } else {\n            // POST with non-multipart body.\n\n            // If it's not multipart AND not a fetch action,\n            // then it can't be an action request.\n            if (!isFetchAction) {\n              return null\n            }\n\n            try {\n              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n            } catch (err) {\n              return handleUnrecognizedFetchAction(err)\n            }\n\n            // A fetch action with a non-multipart body.\n            // In practice, this happens if `encodeReply` returned a string instead of FormData,\n            // which can happen for very simple JSON-like values that don't need multiple flight rows.\n\n            const chunks: Buffer[] = []\n            const reader = req.body.getReader()\n            while (true) {\n              const { done, value } = await reader.read()\n              if (done) {\n                break\n              }\n\n              chunks.push(value)\n            }\n\n            const actionData = Buffer.concat(chunks).toString('utf-8')\n\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        } else if (\n          // The type check here ensures that `req` is correctly typed, and the\n          // environment variable check provides dead code elimination.\n          process.env.NEXT_RUNTIME !== 'edge' &&\n          isNodeNextRequest(req)\n        ) {\n          // Use react-server-dom-webpack/server.node which supports streaming\n          const {\n            createTemporaryReferenceSet,\n            decodeReply,\n            decodeReplyFromBusboy,\n            decodeAction,\n            decodeFormState,\n          } = require(\n            `./react-server.node`\n          ) as typeof import('./react-server.node')\n\n          temporaryReferences = createTemporaryReferenceSet()\n\n          const { PassThrough, Readable, Transform } =\n            require('node:stream') as typeof import('node:stream')\n          const { pipeline } =\n            require('node:stream/promises') as typeof import('node:stream/promises')\n\n          const defaultBodySizeLimit = '1 MB'\n          const bodySizeLimit =\n            serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n          const bodySizeLimitBytes =\n            bodySizeLimit !== defaultBodySizeLimit\n              ? (\n                  require('next/dist/compiled/bytes') as typeof import('next/dist/compiled/bytes')\n                ).parse(bodySizeLimit)\n              : 1024 * 1024 // 1 MB\n\n          let size = 0\n          const sizeLimitTransform = new Transform({\n            transform(chunk, encoding, callback) {\n              size += Buffer.byteLength(chunk, encoding)\n              if (size > bodySizeLimitBytes) {\n                const { ApiError } =\n                  require('../api-utils') as typeof import('../api-utils')\n\n                callback(\n                  new ApiError(\n                    413,\n                    `Body exceeded ${bodySizeLimit} limit.\\n` +\n                      `To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n                  )\n                )\n                return\n              }\n\n              callback(null, chunk)\n            },\n          })\n\n          if (isMultipartAction) {\n            if (isFetchAction) {\n              // A fetch action with a multipart body.\n\n              try {\n                actionModId = getActionModIdOrError(actionId, serverModuleMap)\n              } catch (err) {\n                return handleUnrecognizedFetchAction(err)\n              }\n\n              const busboy = (\n                require('next/dist/compiled/busboy') as typeof import('next/dist/compiled/busboy')\n              )({\n                defParamCharset: 'utf8',\n                headers: req.headers,\n                limits: { fieldSize: bodySizeLimitBytes },\n              })\n\n              const abortController = new AbortController()\n              try {\n                ;[, boundActionArguments] = await Promise.all([\n                  pipeline(req.body, sizeLimitTransform, busboy, {\n                    signal: abortController.signal,\n                  }),\n                  decodeReplyFromBusboy(busboy, serverModuleMap, {\n                    temporaryReferences,\n                  }),\n                ])\n              } catch (err) {\n                abortController.abort()\n                throw err\n              }\n            } else {\n              // Multipart POST, but not a fetch action.\n              // Potentially an MPA action, we have to try decoding it to check.\n\n              const sizeLimitedBody = new PassThrough()\n\n              // React doesn't yet publish a busboy version of decodeAction\n              // so we polyfill the parsing of FormData.\n              const fakeRequest = new Request('http://localhost', {\n                method: 'POST',\n                // @ts-expect-error\n                headers: { 'Content-Type': contentType },\n                body: Readable.toWeb(\n                  sizeLimitedBody\n                ) as ReadableStream<Uint8Array>,\n                duplex: 'half',\n              })\n\n              let formData: FormData\n              const abortController = new AbortController()\n              try {\n                ;[, formData] = await Promise.all([\n                  pipeline(req.body, sizeLimitTransform, sizeLimitedBody, {\n                    signal: abortController.signal,\n                  }),\n                  fakeRequest.formData(),\n                ])\n              } catch (err) {\n                abortController.abort()\n                throw err\n              }\n\n              if (areAllActionIdsValid(formData, serverModuleMap) === false) {\n                // TODO: This can be from skew or manipulated input. We should handle this case\n                // more gracefully but this preserves the prior behavior where decodeAction would throw instead.\n                throw new Error(\n                  `Failed to find Server Action. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n                )\n              }\n\n              // TODO: Refactor so it is harder to accidentally decode an action before you have validated that the\n              // action referred to is available.\n              const action = await decodeAction(formData, serverModuleMap)\n              if (typeof action === 'function') {\n                // an MPA action.\n\n                // Only warn if it's a server action, otherwise skip for other post requests\n                warnBadServerActionRequest()\n\n                const { actionResult } = await executeActionAndPrepareForRender(\n                  action as () => Promise<unknown>,\n                  [],\n                  workStore,\n                  requestStore,\n                  actionWasForwarded\n                )\n\n                const formState = await decodeFormState(\n                  actionResult,\n                  formData,\n                  serverModuleMap\n                )\n\n                // Skip the fetch path.\n                // We need to render a full HTML version of the page for the response, we'll handle that in app-render.\n                return {\n                  type: 'done',\n                  result: undefined,\n                  formState,\n                }\n              } else {\n                // We couldn't decode an action, so this POST request turned out not to be a server action request.\n                return null\n              }\n            }\n          } else {\n            // POST with non-multipart body.\n\n            // If it's not multipart AND not a fetch action,\n            // then it can't be an action request.\n            if (!isFetchAction) {\n              return null\n            }\n\n            try {\n              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n            } catch (err) {\n              return handleUnrecognizedFetchAction(err)\n            }\n\n            // A fetch action with a non-multipart body.\n            // In practice, this happens if `encodeReply` returned a string instead of FormData,\n            // which can happen for very simple JSON-like values that don't need multiple flight rows.\n\n            const sizeLimitedBody = new PassThrough()\n\n            const chunks: Buffer[] = []\n            await Promise.all([\n              pipeline(req.body, sizeLimitTransform, sizeLimitedBody),\n              (async () => {\n                for await (const chunk of sizeLimitedBody) {\n                  chunks.push(Buffer.from(chunk))\n                }\n              })(),\n            ])\n\n            const actionData = Buffer.concat(chunks).toString('utf-8')\n\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        } else {\n          throw new Error('Invariant: Unknown request type.')\n        }\n\n        // actions.js\n        // app/page.js\n        //   action worker1\n        //     appRender1\n\n        // app/foo/page.js\n        //   action worker2\n        //     appRender\n\n        // / -> fire action -> POST / -> appRender1 -> modId for the action file\n        // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n\n        const actionMod = (await ComponentMod.__next_app__.require(\n          actionModId\n        )) as Record<string, (...args: unknown[]) => Promise<unknown>>\n        const actionHandler =\n          actionMod[\n            // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n            actionId!\n          ]\n\n        const { actionResult, skipPageRendering } =\n          await executeActionAndPrepareForRender(\n            actionHandler,\n            boundActionArguments,\n            workStore,\n            requestStore,\n            actionWasForwarded\n          ).finally(() => {\n            addRevalidationHeader(res, { workStore, requestStore })\n          })\n\n        // For form actions, we need to continue rendering the page.\n        if (isFetchAction) {\n          return {\n            type: 'done',\n            result: await generateFlight(req, ctx, requestStore, {\n              actionResult: Promise.resolve(actionResult),\n              skipPageRendering,\n              temporaryReferences,\n              // If we skip page rendering, we need to ensure pending\n              // revalidates are awaited before closing the response. Otherwise,\n              // this will be done after rendering the page.\n              waitUntil: skipPageRendering\n                ? executeRevalidates(workStore)\n                : undefined,\n            }),\n          }\n        } else {\n          // TODO: this shouldn't be reachable, because all non-fetch codepaths return early.\n          // this will be handled in a follow-up refactor PR.\n          return null\n        }\n      }\n    )\n  } catch (err) {\n    if (isRedirectError(err)) {\n      const redirectUrl = getURLFromRedirectError(err)\n      const redirectType = getRedirectTypeFromError(err)\n\n      // if it's a fetch action, we'll set the status code for logging/debugging purposes\n      // but we won't set a Location header, as the redirect will be handled by the client router\n      res.statusCode = RedirectStatusCode.SeeOther\n      metadata.statusCode = RedirectStatusCode.SeeOther\n\n      if (isFetchAction) {\n        return {\n          type: 'done',\n          result: await createRedirectRenderResult(\n            req,\n            res,\n            host,\n            redirectUrl,\n            redirectType,\n            ctx.renderOpts.basePath,\n            workStore,\n            requestStore.url.pathname\n          ),\n        }\n      }\n\n      // For an MPA action, the redirect doesn't need a body, just a Location header.\n      res.setHeader('Location', redirectUrl)\n      return {\n        type: 'done',\n        result: RenderResult.EMPTY,\n      }\n    } else if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      metadata.statusCode = res.statusCode\n\n      if (isFetchAction) {\n        const promise = Promise.reject(err)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n        return {\n          type: 'done',\n          result: await generateFlight(req, ctx, requestStore, {\n            skipPageRendering: false,\n            actionResult: promise,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      // For an MPA action, we need to render a HTML response. We'll handle that in app-render.\n      return {\n        type: 'not-found',\n      }\n    }\n\n    // An error that didn't come from `redirect()` or `notFound()`, likely thrown from user code\n    // (but it could also be a bug in our code!)\n\n    if (isFetchAction) {\n      // TODO: consider checking if the error is an `ApiError` and change status code\n      // so that we can respond with a 413 to requests that break the body size limit\n      // (but if we do that, we also need to make sure that whatever handles the non-fetch error path below does the same)\n      res.statusCode = 500\n      metadata.statusCode = 500\n      const promise = Promise.reject(err)\n      try {\n        // we need to await the promise to trigger the rejection early\n        // so that it's already handled by the time we call\n        // the RSC runtime. Otherwise, it will throw an unhandled\n        // promise rejection error in the renderer.\n        await promise\n      } catch {\n        // swallow error, it's gonna be handled on the client\n      }\n\n      return {\n        type: 'done',\n        result: await generateFlight(req, ctx, requestStore, {\n          actionResult: promise,\n          // If the page was not revalidated, or if the action was forwarded\n          // from another worker, we can skip rendering the page.\n          skipPageRendering:\n            workStore.pathWasRevalidated === undefined ||\n            workStore.pathWasRevalidated === ActionDidNotRevalidate ||\n            actionWasForwarded,\n          temporaryReferences,\n        }),\n      }\n    }\n\n    // For an MPA action, we need to render a HTML response. We'll rethrow the error and let it be handled above.\n    throw err\n  }\n}\n\nasync function executeActionAndPrepareForRender<\n  TFn extends (...args: any[]) => Promise<any>,\n>(\n  action: TFn,\n  args: Parameters<TFn>,\n  workStore: WorkStore,\n  requestStore: RequestStore,\n  actionWasForwarded: boolean\n): Promise<{\n  actionResult: Awaited<ReturnType<TFn>>\n  skipPageRendering: boolean\n}> {\n  requestStore.phase = 'action'\n  let skipPageRendering = actionWasForwarded\n\n  try {\n    const actionResult = await workUnitAsyncStorage.run(requestStore, () =>\n      action.apply(null, args)\n    )\n\n    // If the page was not revalidated, or if the action was forwarded from\n    // another worker, we can skip rendering the page.\n    skipPageRendering ||=\n      workStore.pathWasRevalidated === undefined ||\n      workStore.pathWasRevalidated === ActionDidNotRevalidate\n\n    return { actionResult, skipPageRendering }\n  } finally {\n    if (!skipPageRendering) {\n      requestStore.phase = 'render'\n\n      // When we switch to the render phase, cookies() will return\n      // `workUnitStore.cookies` instead of\n      // `workUnitStore.userspaceMutableCookies`. We want the render to see any\n      // cookie writes that we performed during the action, so we need to update\n      // the immutable cookies to reflect the changes.\n      synchronizeMutableCookies(requestStore)\n\n      // The server action might have toggled draft mode, so we need to reflect\n      // that in the work store to be up-to-date for subsequent rendering.\n      workStore.isDraftMode = requestStore.draftMode.isEnabled\n\n      // If the action called revalidateTag/revalidatePath, then that might\n      // affect data used by the subsequent render, so we need to make sure all\n      // revalidations are applied before that.\n      await executeRevalidates(workStore)\n    }\n  }\n}\n\n/**\n * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.\n * In either case, we'll throw an error to be handled by the caller.\n */\nfunction getActionModIdOrError(\n  actionId: string | null,\n  serverModuleMap: ServerModuleMap\n): string | number {\n  // if we're missing the action ID header, we can't do any further processing\n  if (!actionId) {\n    throw new InvariantError(\"Missing 'next-action' header.\")\n  }\n\n  const actionModId = serverModuleMap[actionId]?.id\n\n  if (!actionModId) {\n    throw getActionNotFoundError(actionId)\n  }\n\n  return actionModId\n}\n\nfunction getActionNotFoundError(actionId: string | null): Error {\n  return new Error(\n    `Failed to find Server Action${actionId ? ` \"${actionId}\"` : ''}. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n  )\n}\n\nconst $ACTION_ = '$ACTION_'\nconst $ACTION_REF_ = '$ACTION_REF_'\nconst $ACTION_ID_ = '$ACTION_ID_'\nconst ACTION_ID_EXPECTED_LENGTH = 42\n\n/**\n * This function mirrors logic inside React's decodeAction and should be kept in sync with that.\n * It pre-parses the FormData to ensure that any action IDs referred to are actual action IDs for\n * this Next.js application.\n */\nfunction areAllActionIdsValid(\n  mpaFormData: FormData,\n  serverModuleMap: ServerModuleMap\n): boolean {\n  let hasAtLeastOneAction = false\n  // Before we attempt to decode the payload for a possible MPA action, assert that all\n  // action IDs are valid IDs. If not we should disregard the payload\n  for (let key of mpaFormData.keys()) {\n    if (!key.startsWith($ACTION_)) {\n      // not a relevant field\n      continue\n    }\n\n    if (key.startsWith($ACTION_ID_)) {\n      // No Bound args case\n      if (isInvalidActionIdFieldName(key, serverModuleMap)) {\n        return false\n      }\n\n      hasAtLeastOneAction = true\n    } else if (key.startsWith($ACTION_REF_)) {\n      // Bound args case\n      const actionDescriptorField =\n        $ACTION_ + key.slice($ACTION_REF_.length) + ':0'\n      const actionFields = mpaFormData.getAll(actionDescriptorField)\n      if (actionFields.length !== 1) {\n        return false\n      }\n      const actionField = actionFields[0]\n      if (typeof actionField !== 'string') {\n        return false\n      }\n\n      if (isInvalidStringActionDescriptor(actionField, serverModuleMap)) {\n        return false\n      }\n      hasAtLeastOneAction = true\n    }\n  }\n  return hasAtLeastOneAction\n}\n\nconst ACTION_DESCRIPTOR_ID_PREFIX = '{\"id\":\"'\nfunction isInvalidStringActionDescriptor(\n  actionDescriptor: string,\n  serverModuleMap: ServerModuleMap\n): unknown {\n  if (actionDescriptor.startsWith(ACTION_DESCRIPTOR_ID_PREFIX) === false) {\n    return true\n  }\n\n  const from = ACTION_DESCRIPTOR_ID_PREFIX.length\n  const to = from + ACTION_ID_EXPECTED_LENGTH\n\n  // We expect actionDescriptor to be '{\"id\":\"<actionId>\",...}'\n  const actionId = actionDescriptor.slice(from, to)\n  if (\n    actionId.length !== ACTION_ID_EXPECTED_LENGTH ||\n    actionDescriptor[to] !== '\"'\n  ) {\n    return true\n  }\n\n  const entry = serverModuleMap[actionId]\n\n  if (entry == null) {\n    return true\n  }\n\n  return false\n}\n\nfunction isInvalidActionIdFieldName(\n  actionIdFieldName: string,\n  serverModuleMap: ServerModuleMap\n): boolean {\n  // The field name must always start with $ACTION_ID_ but since it is\n  // the id is extracted from the key of the field we have already validated\n  // this before entering this function\n  if (\n    actionIdFieldName.length !==\n    $ACTION_ID_.length + ACTION_ID_EXPECTED_LENGTH\n  ) {\n    // this field name has too few or too many characters\n    return true\n  }\n\n  const actionId = actionIdFieldName.slice($ACTION_ID_.length)\n  const entry = serverModuleMap[actionId]\n\n  if (entry == null) {\n    return true\n  }\n\n  return false\n}\n"],"names":["RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","ACTION_HEADER","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","NEXT_ACTION_REVALIDATED_HEADER","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getRedirectTypeFromError","getURLFromRedirectError","isRedirectError","RenderResult","FlightRenderResult","filterReqHeaders","actionsForbiddenHeaders","getModifiedCookieValues","JSON_CONTENT_TYPE_HEADER","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","getServerActionRequestMetadata","isCsrfOriginAllowed","warn","RequestCookies","ResponseCookies","HeadersAdapter","fromNodeOutgoingHttpHeaders","selectWorkerForForwarding","getServerActionsManifest","getServerModuleMap","isNodeNextRequest","isWebNextRequest","RedirectStatusCode","synchronizeMutableCookies","workUnitAsyncStorage","InvariantError","executeRevalidates","getRequestMeta","setCacheBustingSearchParam","ActionDidNotRevalidate","ActionDidRevalidateStaticAndDynamic","hasServerActions","serverActionsManifest","Object","keys","node","length","edge","nodeHeadersToRecord","headers","record","key","value","entries","undefined","Array","isArray","join","getForwardedHeaders","req","res","requestHeaders","requestCookies","from","responseHeaders","getHeaders","responseCookies","mergedHeaders","getAll","forEach","cookie","delete","name","set","toString","Headers","addRevalidationHeader","workStore","requestStore","isTagRevalidated","pendingRevalidatedTags","isCookieRevalidated","mutableCookies","setHeader","JSON","stringify","pathWasRevalidated","createForwardedActionResponse","host","workerPathname","basePath","Error","forwardedHeaders","proto","replace","origin","process","env","__NEXT_PRIVATE_ORIGIN","fetchUrl","URL","response","body","NEXT_RUNTIME","stream","fetch","method","duplex","redirect","next","internal","get","startsWith","includes","cancel","err","console","error","fromStatic","getAppRelativeRedirectUrl","redirectUrl","currentPathname","base","endsWith","resolved","pathname","search","hash","parsedRedirectUrl","createRedirectRenderResult","originalHost","redirectType","appRelativeRedirectUrl","map","item","tag","incrementalCache","prerenderManifest","preview","previewModeId","EMPTY","limitUntrustedHeaderValueForLogs","slice","parseHostHeader","originDomain","forwardedHostHeader","forwardedHostHeaderValue","split","trim","hostHeader","type","handleAction","ComponentMod","generateFlight","serverActions","ctx","metadata","contentType","page","renderOpts","serverModuleMap","actionId","isMultipartAction","isFetchAction","isURLEncodedAction","isPossibleServerAction","handleUnrecognizedFetchAction","statusCode","result","getActionNotFoundError","isStaticGeneration","temporaryReferences","fetchCache","originHeader","warning","warnBadServerActionRequest","allowedOrigins","promise","Promise","reject","actionResult","skipPageRendering","actionAsyncStorage","actionWasForwarded","Boolean","forwardedWorker","run","isAction","actionModId","boundActionArguments","createTemporaryReferenceSet","decodeReply","decodeAction","decodeFormState","formData","request","getActionModIdOrError","areAllActionIdsValid","action","executeActionAndPrepareForRender","formState","chunks","reader","getReader","done","read","push","actionData","Buffer","concat","decodeReplyFromBusboy","require","PassThrough","Readable","Transform","pipeline","defaultBodySizeLimit","bodySizeLimit","bodySizeLimitBytes","parse","size","sizeLimitTransform","transform","chunk","encoding","callback","byteLength","ApiError","busboy","defParamCharset","limits","fieldSize","abortController","AbortController","all","signal","abort","sizeLimitedBody","fakeRequest","Request","toWeb","actionMod","__next_app__","actionHandler","finally","resolve","waitUntil","SeeOther","url","args","phase","apply","isDraftMode","draftMode","isEnabled","id","$ACTION_","$ACTION_REF_","$ACTION_ID_","ACTION_ID_EXPECTED_LENGTH","mpaFormData","hasAtLeastOneAction","isInvalidActionIdFieldName","actionDescriptorField","actionFields","actionField","isInvalidStringActionDescriptor","ACTION_DESCRIPTOR_ID_PREFIX","actionDescriptor","to","entry","actionIdFieldName"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3078, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/server-inserted-html.tsx"],"sourcesContent":["/* eslint-disable @next/internal/no-ambiguous-jsx -- whole module is used in React Client */\n// Provider for the `useServerInsertedHTML` API to register callbacks to insert\n// elements into the HTML stream.\n\nimport type { JSX, ReactNode } from 'react'\nimport * as ReactClient from 'react'\nimport { ServerInsertedHTMLContext } from '../../shared/lib/server-inserted-html.shared-runtime'\n\nexport function createServerInsertedHTML() {\n  const serverInsertedHTMLCallbacks: (() => ReactNode)[] = []\n  const addInsertedHtml = (handler: () => ReactNode) => {\n    serverInsertedHTMLCallbacks.push(handler)\n  }\n\n  return {\n    ServerInsertedHTMLProvider({ children }: { children: JSX.Element }) {\n      return (\n        <ServerInsertedHTMLContext.Provider value={addInsertedHtml}>\n          {children}\n        </ServerInsertedHTMLContext.Provider>\n      )\n    },\n    renderServerInsertedHTML() {\n      return serverInsertedHTMLCallbacks.map((callback, index) => (\n        <ReactClient.Fragment key={'__next_server_inserted__' + index}>\n          {callback()}\n        </ReactClient.Fragment>\n      ))\n    },\n  }\n}\n"],"names":["ReactClient","ServerInsertedHTMLContext","createServerInsertedHTML","serverInsertedHTMLCallbacks","addInsertedHtml","handler","push","ServerInsertedHTMLProvider","children","Provider","value","renderServerInsertedHTML","map","callback","index","Fragment"],"mappings":";;;;AAAA,0FAA0F,GAC1F,+EAA+E;AAC/E,iCAAiC;;AAGjC,YAAYA,iBAAiB,QAAO;AACpC,SAASC,yBAAyB,QAAQ,uDAAsD;;;;AAEzF,SAASC;IACd,MAAMC,8BAAmD,EAAE;IAC3D,MAAMC,kBAAkB,CAACC;QACvBF,4BAA4BG,IAAI,CAACD;IACnC;IAEA,OAAO;QACLE,4BAA2B,EAAEC,QAAQ,EAA6B;YAChE,OAAA,WAAA,OACE,iMAAA,EAACP,oPAAAA,CAA0BQ,QAAQ,EAAA;gBAACC,OAAON;0BACxCI;;QAGP;QACAG;YACE,OAAOR,4BAA4BS,GAAG,CAAC,CAACC,UAAUC,QAAAA,WAAAA,OAChD,iMAAA,EAACd,YAAYe,iLAAQ,EAAA;8BAClBF;mBADwB,6BAA6BC;QAI5D;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3113, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/required-scripts.tsx"],"sourcesContent":["import { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { BuildManifest } from '../get-page-files'\n\nimport ReactDOM from 'react-dom'\n\nexport function getRequiredScripts(\n  buildManifest: BuildManifest,\n  assetPrefix: string,\n  crossOrigin: undefined | '' | 'anonymous' | 'use-credentials',\n  SRIManifest: undefined | Record<string, string>,\n  qs: string,\n  nonce: string | undefined,\n  pagePath: string\n): [\n  () => void,\n  { src: string; integrity?: string; crossOrigin?: string | undefined },\n] {\n  let preinitScripts: () => void\n  let preinitScriptCommands: string[] = []\n  const bootstrapScript: {\n    src: string\n    integrity?: string\n    crossOrigin?: string | undefined\n  } = {\n    src: '',\n    crossOrigin,\n  }\n\n  const files = (\n    buildManifest.rootMainFilesTree?.[pagePath] || buildManifest.rootMainFiles\n  ).map(encodeURIPath)\n  if (files.length === 0) {\n    throw new Error(\n      'Invariant: missing bootstrap script. This is a bug in Next.js'\n    )\n  }\n  if (SRIManifest) {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n    bootstrapScript.integrity = SRIManifest[files[0]]\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      const integrity = SRIManifest[files[i]]\n      preinitScriptCommands.push(src, integrity)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a double indexed array of src/integrity pairs\n      for (let i = 0; i < preinitScriptCommands.length; i += 2) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          integrity: preinitScriptCommands[i + 1],\n          crossOrigin,\n          nonce,\n        })\n      }\n    }\n  } else {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      preinitScriptCommands.push(src)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a singled indexed array of src values\n      for (let i = 0; i < preinitScriptCommands.length; i++) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          nonce,\n          crossOrigin,\n        })\n      }\n    }\n  }\n\n  return [preinitScripts, bootstrapScript]\n}\n"],"names":["encodeURIPath","ReactDOM","getRequiredScripts","buildManifest","assetPrefix","crossOrigin","SRIManifest","qs","nonce","pagePath","preinitScripts","preinitScriptCommands","bootstrapScript","src","files","rootMainFilesTree","rootMainFiles","map","length","Error","integrity","i","push","preinit","as"],"mappings":";;;;AAAA,SAASA,aAAa,QAAQ,mCAAkC;AAGhE,OAAOC,cAAc,YAAW;;;AAEzB,SAASC,mBACdC,aAA4B,EAC5BC,WAAmB,EACnBC,WAA6D,EAC7DC,WAA+C,EAC/CC,EAAU,EACVC,KAAyB,EACzBC,QAAgB;QAiBdN;IAZF,IAAIO;IACJ,IAAIC,wBAAkC,EAAE;IACxC,MAAMC,kBAIF;QACFC,KAAK;QACLR;IACF;IAEA,MAAMS,QACJX,CAAAA,CAAAA,CAAAA,mCAAAA,cAAcY,iBAAiB,KAAA,OAAA,KAAA,IAA/BZ,gCAAiC,CAACM,SAAS,KAAIN,cAAca,aAAY,EACzEC,GAAG,CAACjB,qNAAAA;IACN,IAAIc,MAAMI,MAAM,KAAK,GAAG;QACtB,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACA,IAAIb,aAAa;QACfM,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAC3DK,gBAAgBQ,SAAS,GAAGd,WAAW,CAACQ,KAAK,CAAC,EAAE,CAAC;QAEjD,IAAK,IAAIO,IAAI,GAAGA,IAAIP,MAAMI,MAAM,EAAEG,IAAK;YACrC,MAAMR,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACO,EAAE,GAAGd;YACjD,MAAMa,YAAYd,WAAW,CAACQ,KAAK,CAACO,EAAE,CAAC;YACvCV,sBAAsBW,IAAI,CAACT,KAAKO;QAClC;QACAV,iBAAiB;YACf,yEAAyE;YACzE,IAAK,IAAIW,IAAI,GAAGA,IAAIV,sBAAsBO,MAAM,EAAEG,KAAK,EAAG;gBACxDpB,mMAAAA,CAASsB,OAAO,CAACZ,qBAAqB,CAACU,EAAE,EAAE;oBACzCG,IAAI;oBACJJ,WAAWT,qBAAqB,CAACU,IAAI,EAAE;oBACvChB;oBACAG;gBACF;YACF;QACF;IACF,OAAO;QACLI,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAE3D,IAAK,IAAIc,IAAI,GAAGA,IAAIP,MAAMI,MAAM,EAAEG,IAAK;YACrC,MAAMR,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACO,EAAE,GAAGd;YACjDI,sBAAsBW,IAAI,CAACT;QAC7B;QACAH,iBAAiB;YACf,iEAAiE;YACjE,IAAK,IAAIW,IAAI,GAAGA,IAAIV,sBAAsBO,MAAM,EAAEG,IAAK;gBACrDpB,mMAAAA,CAASsB,OAAO,CAACZ,qBAAqB,CAACU,EAAE,EAAE;oBACzCG,IAAI;oBACJhB;oBACAH;gBACF;YACF;QACF;IACF;IAEA,OAAO;QAACK;QAAgBE;KAAgB;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 3182, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/make-get-server-inserted-html.tsx"],"sourcesContent":["/* eslint-disable @next/internal/no-ambiguous-jsx -- whole module is used in React Client */\nimport React, { type JSX } from 'react'\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { renderToReadableStream } from 'react-dom/server'\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport type { ClientTraceDataEntry } from '../lib/trace/tracer'\n\nexport function makeGetServerInsertedHTML({\n  polyfills,\n  renderServerInsertedHTML,\n  serverCapturedErrors,\n  tracingMetadata,\n  basePath,\n}: {\n  polyfills: JSX.IntrinsicElements['script'][]\n  renderServerInsertedHTML: () => React.ReactNode\n  tracingMetadata: ClientTraceDataEntry[] | undefined\n  serverCapturedErrors: Array<unknown>\n  basePath: string\n}) {\n  let flushedErrorMetaTagsUntilIndex = 0\n\n  // These only need to be rendered once, they'll be set to empty arrays once flushed.\n  let polyfillTags = polyfills.map((polyfill) => {\n    return <script key={polyfill.src} {...polyfill} />\n  })\n  let traceMetaTags = (tracingMetadata || []).map(({ key, value }, index) => (\n    <meta key={`next-trace-data-${index}`} name={key} content={value} />\n  ))\n\n  return async function getServerInsertedHTML() {\n    // Loop through all the errors that have been captured but not yet\n    // flushed.\n    const errorMetaTags = []\n    while (flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length) {\n      const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex]\n      flushedErrorMetaTagsUntilIndex++\n\n      if (isHTTPAccessFallbackError(error)) {\n        errorMetaTags.push(\n          <meta name=\"robots\" content=\"noindex\" key={error.digest} />,\n          process.env.NODE_ENV === 'development' ? (\n            <meta name=\"next-error\" content=\"not-found\" key=\"next-error\" />\n          ) : null\n        )\n      } else if (isRedirectError(error)) {\n        const redirectUrl = addPathPrefix(\n          getURLFromRedirectError(error),\n          basePath\n        )\n        const statusCode = getRedirectStatusCodeFromError(error)\n        const isPermanent =\n          statusCode === RedirectStatusCode.PermanentRedirect ? true : false\n        if (redirectUrl) {\n          errorMetaTags.push(\n            <meta\n              id=\"__next-page-redirect\"\n              httpEquiv=\"refresh\"\n              content={`${isPermanent ? 0 : 1};url=${redirectUrl}`}\n              key={error.digest}\n            />\n          )\n        }\n      }\n    }\n\n    const serverInsertedHTML = renderServerInsertedHTML()\n\n    // Skip React rendering if we know the content is empty.\n    if (\n      polyfillTags.length === 0 &&\n      traceMetaTags.length === 0 &&\n      errorMetaTags.length === 0 &&\n      Array.isArray(serverInsertedHTML) &&\n      serverInsertedHTML.length === 0\n    ) {\n      return ''\n    }\n\n    const stream = await renderToReadableStream(\n      <>\n        {polyfillTags}\n        {serverInsertedHTML}\n        {traceMetaTags}\n        {errorMetaTags}\n      </>,\n      {\n        // Larger chunk because this isn't sent over the network.\n        // Let's set it to 1MB.\n        progressiveChunkSize: 1024 * 1024,\n      }\n    )\n\n    // The polyfills and trace metadata have been flushed, so they don't need to be rendered again\n    polyfillTags = []\n    traceMetaTags = []\n\n    // There's no need to wait for the stream to be ready\n    // e.g. calling `await stream.allReady` because `streamToString` will\n    // wait and decode the stream progressively with better parallelism.\n    return streamToString(stream)\n  }\n}\n"],"names":["React","isHTTPAccessFallbackError","getURLFromRedirectError","getRedirectStatusCodeFromError","isRedirectError","renderToReadableStream","streamToString","RedirectStatusCode","addPathPrefix","makeGetServerInsertedHTML","polyfills","renderServerInsertedHTML","serverCapturedErrors","tracingMetadata","basePath","flushedErrorMetaTagsUntilIndex","polyfillTags","map","polyfill","script","src","traceMetaTags","key","value","index","meta","name","content","getServerInsertedHTML","errorMetaTags","length","error","push","digest","process","env","NODE_ENV","redirectUrl","statusCode","isPermanent","PermanentRedirect","id","httpEquiv","serverInsertedHTML","Array","isArray","stream","progressiveChunkSize"],"mappings":";;;;AAAA,0FAA0F,GAAA;AAC1F,OAAOA,WAAyB,QAAO;AACvC,SAASC,yBAAyB,QAAQ,oEAAmE;AAC7G,SACEC,uBAAuB,EACvBC,8BAA8B,QACzB,mCAAkC;AACzC,SAASC,eAAe,QAAQ,yCAAwC;AACxE,SAASC,sBAAsB,QAAQ,mBAAkB;AACzD,SAASC,cAAc,QAAQ,0CAAyC;AACxE,SAASC,kBAAkB,QAAQ,+CAA8C;AACjF,SAASC,aAAa,QAAQ,gDAA+C;;;;;;;;;;AAGtE,SAASC,0BAA0B,EACxCC,SAAS,EACTC,wBAAwB,EACxBC,oBAAoB,EACpBC,eAAe,EACfC,QAAQ,EAOT;IACC,IAAIC,iCAAiC;IAErC,oFAAoF;IACpF,IAAIC,eAAeN,UAAUO,GAAG,CAAC,CAACC;QAChC,OAAA,WAAA,OAAO,iMAAA,EAACC,UAAAA;YAA2B,GAAGD,QAAQ;WAA1BA,SAASE,GAAG;IAClC;IACA,IAAIC,gBAAiBR,CAAAA,mBAAmB,EAAC,EAAGI,GAAG,CAAC,CAAC,EAAEK,GAAG,EAAEC,KAAK,EAAE,EAAEC,QAAAA,WAAAA,OAC/D,iMAAA,EAACC,QAAAA;YAAsCC,MAAMJ;YAAKK,SAASJ;WAAhD,CAAC,gBAAgB,EAAEC,OAAO;IAGvC,OAAO,eAAeI;QACpB,kEAAkE;QAClE,WAAW;QACX,MAAMC,gBAAgB,EAAE;QACxB,MAAOd,iCAAiCH,qBAAqBkB,MAAM,CAAE;YACnE,MAAMC,QAAQnB,oBAAoB,CAACG,+BAA+B;YAClEA;YAEA,QAAId,2QAAAA,EAA0B8B,QAAQ;gBACpCF,cAAcG,IAAI,CAAA,WAAA,OAChB,iMAAA,EAACP,QAAAA;oBAAKC,MAAK;oBAASC,SAAQ;mBAAeI,MAAME,MAAM,GACvDC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAA,WAAA,OACvB,iMAAA,EAACX,QAAAA;oBAAKC,MAAK;oBAAaC,SAAQ;mBAAgB,gBAC9C;YAER,OAAO,QAAIvB,0NAAAA,EAAgB2B,QAAQ;gBACjC,MAAMM,kBAAc7B,wOAAAA,MAClBN,yNAAAA,EAAwB6B,QACxBjB;gBAEF,MAAMwB,iBAAanC,gOAAAA,EAA+B4B;gBAClD,MAAMQ,cACJD,eAAe/B,sOAAAA,CAAmBiC,iBAAiB,GAAG,OAAO;gBAC/D,IAAIH,aAAa;oBACfR,cAAcG,IAAI,CAAA,WAAA,OAChB,iMAAA,EAACP,QAAAA;wBACCgB,IAAG;wBACHC,WAAU;wBACVf,SAAS,GAAGY,cAAc,IAAI,EAAE,KAAK,EAAEF,aAAa;uBAC/CN,MAAME,MAAM;gBAGvB;YACF;QACF;QAEA,MAAMU,qBAAqBhC;QAE3B,wDAAwD;QACxD,IACEK,aAAac,MAAM,KAAK,KACxBT,cAAcS,MAAM,KAAK,KACzBD,cAAcC,MAAM,KAAK,KACzBc,MAAMC,OAAO,CAACF,uBACdA,mBAAmBb,MAAM,KAAK,GAC9B;YACA,OAAO;QACT;QAEA,MAAMgB,SAAS,UAAMzC,2NAAAA,EAAAA,WAAAA,OACnB,kMAAA,EAAA,sMAAA,EAAA;;gBACGW;gBACA2B;gBACAtB;gBACAQ;;YAEH;YACE,yDAAyD;YACzD,uBAAuB;YACvBkB,sBAAsB,OAAO;QAC/B;QAGF,8FAA8F;QAC9F/B,eAAe,EAAE;QACjBK,gBAAgB,EAAE;QAElB,qDAAqD;QACrD,qEAAqE;QACrE,oEAAoE;QACpE,WAAOf,6OAAAA,EAAewC;IACxB;AACF","ignoreList":[0]}},
    {"offset": {"line": 3274, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/get-css-inlined-link-tags.tsx"],"sourcesContent":["import type { CssResource } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport { getClientReferenceManifest } from './manifests-singleton'\n\n/**\n * Get external stylesheet link hrefs based on server CSS manifest.\n */\nexport function getLinkAndScriptTags(\n  filePath: string,\n  injectedCSS: Set<string>,\n  injectedScripts: Set<string>,\n  collectNewImports?: boolean\n): { styles: CssResource[]; scripts: string[] } {\n  const filePathWithoutExt = filePath.replace(/\\.[^.]+$/, '')\n  const cssChunks = new Set<CssResource>()\n  const jsChunks = new Set<string>()\n  const { entryCSSFiles, entryJSFiles } = getClientReferenceManifest()\n  const cssFiles = entryCSSFiles[filePathWithoutExt]\n  const jsFiles = entryJSFiles?.[filePathWithoutExt]\n\n  if (cssFiles) {\n    for (const css of cssFiles) {\n      if (!injectedCSS.has(css.path)) {\n        if (collectNewImports) {\n          injectedCSS.add(css.path)\n        }\n        cssChunks.add(css)\n      }\n    }\n  }\n\n  if (jsFiles) {\n    for (const file of jsFiles) {\n      if (!injectedScripts.has(file)) {\n        if (collectNewImports) {\n          injectedScripts.add(file)\n        }\n        jsChunks.add(file)\n      }\n    }\n  }\n\n  return { styles: [...cssChunks], scripts: [...jsChunks] }\n}\n"],"names":["getClientReferenceManifest","getLinkAndScriptTags","filePath","injectedCSS","injectedScripts","collectNewImports","filePathWithoutExt","replace","cssChunks","Set","jsChunks","entryCSSFiles","entryJSFiles","cssFiles","jsFiles","css","has","path","add","file","styles","scripts"],"mappings":";;;;AACA,SAASA,0BAA0B,QAAQ,wBAAuB;;AAK3D,SAASC,qBACdC,QAAgB,EAChBC,WAAwB,EACxBC,eAA4B,EAC5BC,iBAA2B;IAE3B,MAAMC,qBAAqBJ,SAASK,OAAO,CAAC,YAAY;IACxD,MAAMC,YAAY,IAAIC;IACtB,MAAMC,WAAW,IAAID;IACrB,MAAM,EAAEE,aAAa,EAAEC,YAAY,EAAE,OAAGZ,6OAAAA;IACxC,MAAMa,WAAWF,aAAa,CAACL,mBAAmB;IAClD,MAAMQ,UAAUF,gBAAAA,OAAAA,KAAAA,IAAAA,YAAc,CAACN,mBAAmB;IAElD,IAAIO,UAAU;QACZ,KAAK,MAAME,OAAOF,SAAU;YAC1B,IAAI,CAACV,YAAYa,GAAG,CAACD,IAAIE,IAAI,GAAG;gBAC9B,IAAIZ,mBAAmB;oBACrBF,YAAYe,GAAG,CAACH,IAAIE,IAAI;gBAC1B;gBACAT,UAAUU,GAAG,CAACH;YAChB;QACF;IACF;IAEA,IAAID,SAAS;QACX,KAAK,MAAMK,QAAQL,QAAS;YAC1B,IAAI,CAACV,gBAAgBY,GAAG,CAACG,OAAO;gBAC9B,IAAId,mBAAmB;oBACrBD,gBAAgBc,GAAG,CAACC;gBACtB;gBACAT,SAASQ,GAAG,CAACC;YACf;QACF;IACF;IAEA,OAAO;QAAEC,QAAQ;eAAIZ;SAAU;QAAEa,SAAS;eAAIX;SAAS;IAAC;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 3320, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/get-preloadable-fonts.tsx"],"sourcesContent":["import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\n/**\n * Get hrefs for fonts to preload\n * Returns null if there are no fonts at all.\n * Returns string[] if there are fonts to preload (font paths)\n * Returns empty string[] if there are fonts but none to preload and no other fonts have been preloaded\n * Returns null if there are fonts but none to preload and at least some were previously preloaded\n */\nexport function getPreloadableFonts(\n  nextFontManifest: DeepReadonly<NextFontManifest> | undefined,\n  filePath: string | undefined,\n  injectedFontPreloadTags: Set<string>\n): string[] | null {\n  if (!nextFontManifest || !filePath) {\n    return null\n  }\n  const filepathWithoutExtension = filePath.replace(/\\.[^.]+$/, '')\n  const fontFiles = new Set<string>()\n  let foundFontUsage = false\n\n  const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension]\n  if (preloadedFontFiles) {\n    foundFontUsage = true\n    for (const fontFile of preloadedFontFiles) {\n      if (!injectedFontPreloadTags.has(fontFile)) {\n        fontFiles.add(fontFile)\n        injectedFontPreloadTags.add(fontFile)\n      }\n    }\n  }\n\n  if (fontFiles.size) {\n    return [...fontFiles].sort()\n  } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {\n    return []\n  } else {\n    return null\n  }\n}\n"],"names":["getPreloadableFonts","nextFontManifest","filePath","injectedFontPreloadTags","filepathWithoutExtension","replace","fontFiles","Set","foundFontUsage","preloadedFontFiles","app","fontFile","has","add","size","sort"],"mappings":"AAGA;;;;;;CAMC,GACD;;;;AAAO,SAASA,oBACdC,gBAA4D,EAC5DC,QAA4B,EAC5BC,uBAAoC;IAEpC,IAAI,CAACF,oBAAoB,CAACC,UAAU;QAClC,OAAO;IACT;IACA,MAAME,2BAA2BF,SAASG,OAAO,CAAC,YAAY;IAC9D,MAAMC,YAAY,IAAIC;IACtB,IAAIC,iBAAiB;IAErB,MAAMC,qBAAqBR,iBAAiBS,GAAG,CAACN,yBAAyB;IACzE,IAAIK,oBAAoB;QACtBD,iBAAiB;QACjB,KAAK,MAAMG,YAAYF,mBAAoB;YACzC,IAAI,CAACN,wBAAwBS,GAAG,CAACD,WAAW;gBAC1CL,UAAUO,GAAG,CAACF;gBACdR,wBAAwBU,GAAG,CAACF;YAC9B;QACF;IACF;IAEA,IAAIL,UAAUQ,IAAI,EAAE;QAClB,OAAO;eAAIR;SAAU,CAACS,IAAI;IAC5B,OAAO,IAAIP,kBAAkBL,wBAAwBW,IAAI,KAAK,GAAG;QAC/D,OAAO,EAAE;IACX,OAAO;QACL,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 3361, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/has-loading-component-in-tree.tsx"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\n\nexport function hasLoadingComponentInTree(tree: LoaderTree): boolean {\n  const [, parallelRoutes, { loading }] = tree\n\n  if (loading) {\n    return true\n  }\n\n  return Object.values(parallelRoutes).some((parallelRoute) =>\n    hasLoadingComponentInTree(parallelRoute)\n  ) as boolean\n}\n"],"names":["hasLoadingComponentInTree","tree","parallelRoutes","loading","Object","values","some","parallelRoute"],"mappings":";;;;AAEO,SAASA,0BAA0BC,IAAgB;IACxD,MAAM,GAAGC,gBAAgB,EAAEC,OAAO,EAAE,CAAC,GAAGF;IAExC,IAAIE,SAAS;QACX,OAAO;IACT;IAEA,OAAOC,OAAOC,MAAM,CAACH,gBAAgBI,IAAI,CAAC,CAACC,gBACzCP,0BAA0BO;AAE9B","ignoreList":[0]}},
    {"offset": {"line": 3376, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/interop-default.ts"],"sourcesContent":["/**\n * Interop between \"export default\" and \"module.exports\".\n */\nexport function interopDefault(mod: any) {\n  return mod.default || mod\n}\n"],"names":["interopDefault","mod","default"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA,eAAeC,GAAQ;IACrC,OAAOA,IAAIC,OAAO,IAAID;AACxB","ignoreList":[0]}},
    {"offset": {"line": 3389, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/get-asset-query-string.ts"],"sourcesContent":["import type { AppRenderContext } from './app-render'\n\nconst isDev = process.env.NODE_ENV === 'development'\nconst isTurbopack = !!process.env.TURBOPACK\n\nexport function getAssetQueryString(\n  ctx: AppRenderContext,\n  addTimestamp: boolean\n) {\n  let qs = ''\n\n  // In development we add the request timestamp to allow react to\n  // reload assets when a new RSC response is received.\n  // Turbopack handles HMR of assets itself and react doesn't need to reload them\n  // so this approach is not needed for Turbopack.\n  const shouldAddVersion = isDev && !isTurbopack && addTimestamp\n  if (shouldAddVersion) {\n    qs += `?v=${ctx.requestTimestamp}`\n  }\n\n  if (ctx.renderOpts.deploymentId) {\n    qs += `${shouldAddVersion ? '&' : '?'}dpl=${ctx.renderOpts.deploymentId}`\n  }\n  return qs\n}\n"],"names":["isDev","process","env","NODE_ENV","isTurbopack","TURBOPACK","getAssetQueryString","ctx","addTimestamp","qs","shouldAddVersion","requestTimestamp","renderOpts","deploymentId"],"mappings":";;;;AAEA,MAAMA,QAAQC,QAAQC,GAAG,CAACC,QAAQ,gCAAK;AACvC,MAAMC,cAAc,CAAC,CAACH,QAAQC,GAAG,CAACG,SAAS;AAEpC,SAASC,oBACdC,GAAqB,EACrBC,YAAqB;IAErB,IAAIC,KAAK;IAET,gEAAgE;IAChE,qDAAqD;IACrD,+EAA+E;IAC/E,gDAAgD;IAChD,MAAMC,mBAAmBV,SAAS,CAACI,eAAeI;IAClD,IAAIE,kBAAkB;;IAItB,IAAIH,IAAIK,UAAU,CAACC,YAAY,EAAE;QAC/BJ,MAAM,GAAGC,sCAAmB,0BAAM,IAAI,IAAI,EAAEH,IAAIK,UAAU,CAACC,YAAY,EAAE;IAC3E;IACA,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 3413, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/render-css-resource.tsx"],"sourcesContent":["import type { CssResource } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport type { PreloadCallbacks } from './types'\n\n/**\n * Abstracts the rendering of CSS files based on whether they are inlined or not.\n * For inlined CSS, renders a <style> tag with the CSS content directly embedded.\n * For external CSS files, renders a <link> tag pointing to the CSS file.\n */\nexport function renderCssResource(\n  entryCssFiles: CssResource[],\n  ctx: AppRenderContext,\n  preloadCallbacks?: PreloadCallbacks\n) {\n  const {\n    componentMod: { createElement },\n  } = ctx\n  return entryCssFiles.map((entryCssFile, index) => {\n    // `Precedence` is an opt-in signal for React to handle resource\n    // loading and deduplication, etc. It's also used as the key to sort\n    // resources so they will be injected in the correct order.\n    // During HMR, it's critical to use different `precedence` values\n    // for different stylesheets, so their order will be kept.\n    // https://github.com/facebook/react/pull/25060\n    const precedence =\n      process.env.NODE_ENV === 'development'\n        ? 'next_' + entryCssFile.path\n        : 'next'\n\n    // In dev, Safari and Firefox will cache the resource during HMR:\n    // - https://github.com/vercel/next.js/issues/5860\n    // - https://bugs.webkit.org/show_bug.cgi?id=187726\n    // Because of this, we add a `?v=` query to bypass the cache during\n    // development. We need to also make sure that the number is always\n    // increasing.\n    const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(\n      entryCssFile.path\n    )}${getAssetQueryString(ctx, true)}`\n\n    if (entryCssFile.inlined && !ctx.parsedRequestHeaders.isRSCRequest) {\n      return createElement(\n        'style',\n        {\n          key: index,\n          nonce: ctx.nonce,\n          precedence: precedence,\n          href: fullHref,\n        },\n        entryCssFile.content\n      )\n    }\n\n    preloadCallbacks?.push(() => {\n      ctx.componentMod.preloadStyle(\n        fullHref,\n        ctx.renderOpts.crossOrigin,\n        ctx.nonce\n      )\n    })\n\n    return createElement('link', {\n      key: index,\n      rel: 'stylesheet',\n      href: fullHref,\n      precedence: precedence,\n      crossOrigin: ctx.renderOpts.crossOrigin,\n      nonce: ctx.nonce,\n    })\n  })\n}\n"],"names":["encodeURIPath","getAssetQueryString","renderCssResource","entryCssFiles","ctx","preloadCallbacks","componentMod","createElement","map","entryCssFile","index","precedence","process","env","NODE_ENV","path","fullHref","assetPrefix","inlined","parsedRequestHeaders","isRSCRequest","key","nonce","href","content","push","preloadStyle","renderOpts","crossOrigin","rel"],"mappings":";;;;AACA,SAASA,aAAa,QAAQ,mCAAkC;AAEhE,SAASC,mBAAmB,QAAQ,2BAA0B;;;AAQvD,SAASC,kBACdC,aAA4B,EAC5BC,GAAqB,EACrBC,gBAAmC;IAEnC,MAAM,EACJC,cAAc,EAAEC,aAAa,EAAE,EAChC,GAAGH;IACJ,OAAOD,cAAcK,GAAG,CAAC,CAACC,cAAcC;QACtC,gEAAgE;QAChE,oEAAoE;QACpE,2DAA2D;QAC3D,iEAAiE;QACjE,0DAA0D;QAC1D,+CAA+C;QAC/C,MAAMC,aACJC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cACrB,UAAUL,aAAaM,IAAI,GAC3B;QAEN,iEAAiE;QACjE,kDAAkD;QAClD,mDAAmD;QACnD,mEAAmE;QACnE,mEAAmE;QACnE,cAAc;QACd,MAAMC,WAAW,GAAGZ,IAAIa,WAAW,CAAC,OAAO,MAAEjB,qNAAAA,EAC3CS,aAAaM,IAAI,QACfd,+OAAAA,EAAoBG,KAAK,OAAO;QAEpC,IAAIK,aAAaS,OAAO,IAAI,CAACd,IAAIe,oBAAoB,CAACC,YAAY,EAAE;YAClE,OAAOb,cACL,SACA;gBACEc,KAAKX;gBACLY,OAAOlB,IAAIkB,KAAK;gBAChBX,YAAYA;gBACZY,MAAMP;YACR,GACAP,aAAae,OAAO;QAExB;QAEAnB,oBAAAA,OAAAA,KAAAA,IAAAA,iBAAkBoB,IAAI,CAAC;YACrBrB,IAAIE,YAAY,CAACoB,YAAY,CAC3BV,UACAZ,IAAIuB,UAAU,CAACC,WAAW,EAC1BxB,IAAIkB,KAAK;QAEb;QAEA,OAAOf,cAAc,QAAQ;YAC3Bc,KAAKX;YACLmB,KAAK;YACLN,MAAMP;YACNL,YAAYA;YACZiB,aAAaxB,IAAIuB,UAAU,CAACC,WAAW;YACvCN,OAAOlB,IAAIkB,KAAK;QAClB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3463, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/create-component-styles-and-scripts.tsx"],"sourcesContent":["import { interopDefault } from './interop-default'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport { renderCssResource } from './render-css-resource'\n\nexport async function createComponentStylesAndScripts({\n  filePath,\n  getComponent,\n  injectedCSS,\n  injectedJS,\n  ctx,\n}: {\n  filePath: string\n  getComponent: () => any\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  ctx: AppRenderContext\n}): Promise<[React.ComponentType<any>, React.ReactNode, React.ReactNode]> {\n  const {\n    componentMod: { createElement },\n  } = ctx\n  const { styles: entryCssFiles, scripts: jsHrefs } = getLinkAndScriptTags(\n    filePath,\n    injectedCSS,\n    injectedJS\n  )\n\n  const styles = renderCssResource(entryCssFiles, ctx)\n\n  const scripts = jsHrefs\n    ? jsHrefs.map((href, index) =>\n        createElement('script', {\n          src: `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`,\n          async: true,\n          key: `script-${index}`,\n        })\n      )\n    : null\n\n  const Comp = interopDefault(await getComponent())\n\n  return [Comp, styles, scripts]\n}\n"],"names":["interopDefault","getLinkAndScriptTags","getAssetQueryString","encodeURIPath","renderCssResource","createComponentStylesAndScripts","filePath","getComponent","injectedCSS","injectedJS","ctx","componentMod","createElement","styles","entryCssFiles","scripts","jsHrefs","map","href","index","src","assetPrefix","async","key","Comp"],"mappings":";;;;AAAA,SAASA,cAAc,QAAQ,oBAAmB;AAClD,SAASC,oBAAoB,QAAQ,8BAA6B;AAElE,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,aAAa,QAAQ,mCAAkC;AAChE,SAASC,iBAAiB,QAAQ,wBAAuB;;;;;;AAElD,eAAeC,gCAAgC,EACpDC,QAAQ,EACRC,YAAY,EACZC,WAAW,EACXC,UAAU,EACVC,GAAG,EAOJ;IACC,MAAM,EACJC,cAAc,EAAEC,aAAa,EAAE,EAChC,GAAGF;IACJ,MAAM,EAAEG,QAAQC,aAAa,EAAEC,SAASC,OAAO,EAAE,OAAGf,sPAAAA,EAClDK,UACAE,aACAC;IAGF,MAAMI,aAAST,uOAAAA,EAAkBU,eAAeJ;IAEhD,MAAMK,UAAUC,UACZA,QAAQC,GAAG,CAAC,CAACC,MAAMC,QACjBP,cAAc,UAAU;YACtBQ,KAAK,GAAGV,IAAIW,WAAW,CAAC,OAAO,MAAElB,qNAAAA,EAAce,YAAQhB,+OAAAA,EAAoBQ,KAAK,OAAO;YACvFY,OAAO;YACPC,KAAK,CAAC,OAAO,EAAEJ,OAAO;QACxB,MAEF;IAEJ,MAAMK,WAAOxB,6NAAAA,EAAe,MAAMO;IAElC,OAAO;QAACiB;QAAMX;QAAQE;KAAQ;AAChC","ignoreList":[0]}},
    {"offset": {"line": 3497, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/get-layer-assets.tsx"],"sourcesContent":["import { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { PreloadCallbacks } from './types'\nimport { renderCssResource } from './render-css-resource'\n\nexport function getLayerAssets({\n  ctx,\n  layoutOrPagePath,\n  injectedCSS: injectedCSSWithCurrentLayout,\n  injectedJS: injectedJSWithCurrentLayout,\n  injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  preloadCallbacks,\n}: {\n  layoutOrPagePath: string | undefined\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n}): React.ReactNode {\n  const {\n    componentMod: { createElement },\n  } = ctx\n  const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath\n    ? getLinkAndScriptTags(\n        layoutOrPagePath,\n        injectedCSSWithCurrentLayout,\n        injectedJSWithCurrentLayout,\n        true\n      )\n    : { styles: [], scripts: [] }\n\n  const preloadedFontFiles = layoutOrPagePath\n    ? getPreloadableFonts(\n        ctx.renderOpts.nextFontManifest,\n        layoutOrPagePath,\n        injectedFontPreloadTagsWithCurrentLayout\n      )\n    : null\n\n  if (preloadedFontFiles) {\n    if (preloadedFontFiles.length) {\n      for (let i = 0; i < preloadedFontFiles.length; i++) {\n        const fontFilename = preloadedFontFiles[i]\n        const ext = /\\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)![1]\n        const type = `font/${ext}`\n        const href = `${ctx.assetPrefix}/_next/${encodeURIPath(fontFilename)}`\n\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preloadFont(\n            href,\n            type,\n            ctx.renderOpts.crossOrigin,\n            ctx.nonce\n          )\n        })\n      }\n    } else {\n      try {\n        let url = new URL(ctx.assetPrefix)\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect(url.origin, 'anonymous', ctx.nonce)\n        })\n      } catch (error) {\n        // assetPrefix must not be a fully qualified domain name. We assume\n        // we should preconnect to same origin instead\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect('/', 'anonymous', ctx.nonce)\n        })\n      }\n    }\n  }\n\n  const styles = renderCssResource(styleTags, ctx, preloadCallbacks)\n\n  const scripts = scriptTags\n    ? scriptTags.map((href, index) => {\n        const fullSrc = `${ctx.assetPrefix}/_next/${encodeURIPath(\n          href\n        )}${getAssetQueryString(ctx, true)}`\n\n        return createElement('script', {\n          src: fullSrc,\n          async: true,\n          key: `script-${index}`,\n          nonce: ctx.nonce,\n        })\n      })\n    : []\n\n  return styles.length || scripts.length ? [...styles, ...scripts] : null\n}\n"],"names":["getLinkAndScriptTags","getPreloadableFonts","getAssetQueryString","encodeURIPath","renderCssResource","getLayerAssets","ctx","layoutOrPagePath","injectedCSS","injectedCSSWithCurrentLayout","injectedJS","injectedJSWithCurrentLayout","injectedFontPreloadTags","injectedFontPreloadTagsWithCurrentLayout","preloadCallbacks","componentMod","createElement","styles","styleTags","scripts","scriptTags","preloadedFontFiles","renderOpts","nextFontManifest","length","i","fontFilename","ext","exec","type","href","assetPrefix","push","preloadFont","crossOrigin","nonce","url","URL","preconnect","origin","error","map","index","fullSrc","src","async","key"],"mappings":";;;;AAAA,SAASA,oBAAoB,QAAQ,8BAA6B;AAClE,SAASC,mBAAmB,QAAQ,0BAAyB;AAE7D,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,aAAa,QAAQ,mCAAkC;AAEhE,SAASC,iBAAiB,QAAQ,wBAAuB;;;;;;AAElD,SAASC,eAAe,EAC7BC,GAAG,EACHC,gBAAgB,EAChBC,aAAaC,4BAA4B,EACzCC,YAAYC,2BAA2B,EACvCC,yBAAyBC,wCAAwC,EACjEC,gBAAgB,EAQjB;IACC,MAAM,EACJC,cAAc,EAAEC,aAAa,EAAE,EAChC,GAAGV;IACJ,MAAM,EAAEW,QAAQC,SAAS,EAAEC,SAASC,UAAU,EAAE,GAAGb,uBAC/CP,sPAAAA,EACEO,kBACAE,8BACAE,6BACA,QAEF;QAAEM,QAAQ,EAAE;QAAEE,SAAS,EAAE;IAAC;IAE9B,MAAME,qBAAqBd,uBACvBN,2OAAAA,EACEK,IAAIgB,UAAU,CAACC,gBAAgB,EAC/BhB,kBACAM,4CAEF;IAEJ,IAAIQ,oBAAoB;QACtB,IAAIA,mBAAmBG,MAAM,EAAE;YAC7B,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,mBAAmBG,MAAM,EAAEC,IAAK;gBAClD,MAAMC,eAAeL,kBAAkB,CAACI,EAAE;gBAC1C,MAAME,MAAM,8BAA8BC,IAAI,CAACF,aAAc,CAAC,EAAE;gBAChE,MAAMG,OAAO,CAAC,KAAK,EAAEF,KAAK;gBAC1B,MAAMG,OAAO,GAAGxB,IAAIyB,WAAW,CAAC,OAAO,MAAE5B,qNAAAA,EAAcuB,eAAe;gBAEtEZ,iBAAiBkB,IAAI,CAAC;oBACpB1B,IAAIS,YAAY,CAACkB,WAAW,CAC1BH,MACAD,MACAvB,IAAIgB,UAAU,CAACY,WAAW,EAC1B5B,IAAI6B,KAAK;gBAEb;YACF;QACF,OAAO;YACL,IAAI;gBACF,IAAIC,MAAM,IAAIC,IAAI/B,IAAIyB,WAAW;gBACjCjB,iBAAiBkB,IAAI,CAAC;oBACpB1B,IAAIS,YAAY,CAACuB,UAAU,CAACF,IAAIG,MAAM,EAAE,aAAajC,IAAI6B,KAAK;gBAChE;YACF,EAAE,OAAOK,OAAO;gBACd,mEAAmE;gBACnE,8CAA8C;gBAC9C1B,iBAAiBkB,IAAI,CAAC;oBACpB1B,IAAIS,YAAY,CAACuB,UAAU,CAAC,KAAK,aAAahC,IAAI6B,KAAK;gBACzD;YACF;QACF;IACF;IAEA,MAAMlB,aAASb,uOAAAA,EAAkBc,WAAWZ,KAAKQ;IAEjD,MAAMK,UAAUC,aACZA,WAAWqB,GAAG,CAAC,CAACX,MAAMY;QACpB,MAAMC,UAAU,GAAGrC,IAAIyB,WAAW,CAAC,OAAO,MAAE5B,qNAAAA,EAC1C2B,YACE5B,+OAAAA,EAAoBI,KAAK,OAAO;QAEpC,OAAOU,cAAc,UAAU;YAC7B4B,KAAKD;YACLE,OAAO;YACPC,KAAK,CAAC,OAAO,EAAEJ,OAAO;YACtBP,OAAO7B,IAAI6B,KAAK;QAClB;IACF,KACA,EAAE;IAEN,OAAOlB,OAAOO,MAAM,IAAIL,QAAQK,MAAM,GAAG;WAAIP;WAAWE;KAAQ,GAAG;AACrE","ignoreList":[0]}},
    {"offset": {"line": 3563, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/staged-rendering.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n\nexport enum RenderStage {\n  Before = 1,\n  Static = 2,\n  Runtime = 3,\n  Dynamic = 4,\n  Abandoned = 5,\n}\n\nexport type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n\nexport class StagedRenderingController {\n  currentStage: RenderStage = RenderStage.Before\n\n  staticInterruptReason: Error | null = null\n  runtimeInterruptReason: Error | null = null\n  staticStageEndTime: number = Infinity\n  runtimeStageEndTime: number = Infinity\n\n  private runtimeStageListeners: Array<() => void> = []\n  private dynamicStageListeners: Array<() => void> = []\n\n  private runtimeStagePromise = createPromiseWithResolvers<void>()\n  private dynamicStagePromise = createPromiseWithResolvers<void>()\n\n  private mayAbandon: boolean = false\n\n  constructor(\n    private abortSignal: AbortSignal | null = null,\n    private hasRuntimePrefetch: boolean\n  ) {\n    if (abortSignal) {\n      abortSignal.addEventListener(\n        'abort',\n        () => {\n          const { reason } = abortSignal\n          if (this.currentStage < RenderStage.Runtime) {\n            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.runtimeStagePromise.reject(reason)\n          }\n          if (\n            this.currentStage < RenderStage.Dynamic ||\n            this.currentStage === RenderStage.Abandoned\n          ) {\n            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.dynamicStagePromise.reject(reason)\n          }\n        },\n        { once: true }\n      )\n\n      this.mayAbandon = true\n    }\n  }\n\n  onStage(stage: NonStaticRenderStage, callback: () => void) {\n    if (this.currentStage >= stage) {\n      callback()\n    } else if (stage === RenderStage.Runtime) {\n      this.runtimeStageListeners.push(callback)\n    } else if (stage === RenderStage.Dynamic) {\n      this.dynamicStageListeners.push(callback)\n    } else {\n      // This should never happen\n      throw new InvariantError(`Invalid render stage: ${stage}`)\n    }\n  }\n\n  canSyncInterrupt() {\n    // If we haven't started the render yet, it can't be interrupted.\n    if (this.currentStage === RenderStage.Before) {\n      return false\n    }\n\n    const boundaryStage = this.hasRuntimePrefetch\n      ? RenderStage.Dynamic\n      : RenderStage.Runtime\n    return this.currentStage < boundaryStage\n  }\n\n  syncInterruptCurrentStageWithReason(reason: Error) {\n    if (this.currentStage === RenderStage.Before) {\n      return\n    }\n\n    // If Sync IO occurs during the initial (abandonable) render, we'll retry it,\n    // so we want a slightly different flow.\n    // See the implementation of `abandonRenderImpl` for more explanation.\n    if (this.mayAbandon) {\n      return this.abandonRenderImpl()\n    }\n\n    // If we're in the final render, we cannot abandon it. We need to advance to the Dynamic stage\n    // and capture the interruption reason.\n    switch (this.currentStage) {\n      case RenderStage.Static: {\n        this.staticInterruptReason = reason\n        this.advanceStage(RenderStage.Dynamic)\n        return\n      }\n      case RenderStage.Runtime: {\n        // We only error for Sync IO in the runtime stage if the route\n        // is configured to use runtime prefetching.\n        // We do this to reflect the fact that during a runtime prefetch,\n        // Sync IO aborts aborts the render.\n        // Note that `canSyncInterrupt` should prevent us from getting here at all\n        // if runtime prefetching isn't enabled.\n        if (this.hasRuntimePrefetch) {\n          this.runtimeInterruptReason = reason\n          this.advanceStage(RenderStage.Dynamic)\n        }\n        return\n      }\n      case RenderStage.Dynamic:\n      case RenderStage.Abandoned:\n      default:\n    }\n  }\n\n  getStaticInterruptReason() {\n    return this.staticInterruptReason\n  }\n\n  getRuntimeInterruptReason() {\n    return this.runtimeInterruptReason\n  }\n\n  getStaticStageEndTime() {\n    return this.staticStageEndTime\n  }\n\n  getRuntimeStageEndTime() {\n    return this.runtimeStageEndTime\n  }\n\n  abandonRender() {\n    if (!this.mayAbandon) {\n      throw new InvariantError(\n        '`abandonRender` called on a stage controller that cannot be abandoned.'\n      )\n    }\n\n    this.abandonRenderImpl()\n  }\n\n  private abandonRenderImpl() {\n    // In staged rendering, only the initial render is abandonable.\n    // We can abandon the initial render if\n    //   1. We notice a cache miss, and need to wait for caches to fill\n    //   2. A sync IO error occurs, and the render should be interrupted\n    //      (this might be a lazy intitialization of a module,\n    //       so we still want to restart in this case and see if it still occurs)\n    // In either case, we'll be doing another render after this one,\n    // so we only want to unblock the Runtime stage, not Dynamic, because\n    // unblocking the dynamic stage would likely lead to wasted (uncached) IO.\n    const { currentStage } = this\n    switch (currentStage) {\n      case RenderStage.Static: {\n        this.currentStage = RenderStage.Abandoned\n        this.resolveRuntimeStage()\n        return\n      }\n      case RenderStage.Runtime: {\n        this.currentStage = RenderStage.Abandoned\n        return\n      }\n      case RenderStage.Dynamic:\n      case RenderStage.Before:\n      case RenderStage.Abandoned:\n        break\n      default: {\n        currentStage satisfies never\n      }\n    }\n  }\n\n  advanceStage(\n    stage: RenderStage.Static | RenderStage.Runtime | RenderStage.Dynamic\n  ) {\n    // If we're already at the target stage or beyond, do nothing.\n    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n    if (stage <= this.currentStage) {\n      return\n    }\n\n    let currentStage = this.currentStage\n    this.currentStage = stage\n\n    if (currentStage < RenderStage.Runtime && stage >= RenderStage.Runtime) {\n      this.staticStageEndTime = performance.now() + performance.timeOrigin\n      this.resolveRuntimeStage()\n    }\n    if (currentStage < RenderStage.Dynamic && stage >= RenderStage.Dynamic) {\n      this.runtimeStageEndTime = performance.now() + performance.timeOrigin\n      this.resolveDynamicStage()\n      return\n    }\n  }\n\n  /** Fire the `onStage` listeners for the runtime stage and unblock any promises waiting for it. */\n  private resolveRuntimeStage() {\n    const runtimeListeners = this.runtimeStageListeners\n    for (let i = 0; i < runtimeListeners.length; i++) {\n      runtimeListeners[i]()\n    }\n    runtimeListeners.length = 0\n    this.runtimeStagePromise.resolve()\n  }\n\n  /** Fire the `onStage` listeners for the dynamic stage and unblock any promises waiting for it. */\n  private resolveDynamicStage() {\n    const dynamicListeners = this.dynamicStageListeners\n    for (let i = 0; i < dynamicListeners.length; i++) {\n      dynamicListeners[i]()\n    }\n    dynamicListeners.length = 0\n    this.dynamicStagePromise.resolve()\n  }\n\n  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n    switch (stage) {\n      case RenderStage.Runtime: {\n        return this.runtimeStagePromise.promise\n      }\n      case RenderStage.Dynamic: {\n        return this.dynamicStagePromise.promise\n      }\n      default: {\n        stage satisfies never\n        throw new InvariantError(`Invalid render stage: ${stage}`)\n      }\n    }\n  }\n\n  waitForStage(stage: NonStaticRenderStage) {\n    return this.getStagePromise(stage)\n  }\n\n  delayUntilStage<T>(\n    stage: NonStaticRenderStage,\n    displayName: string | undefined,\n    resolvedValue: T\n  ) {\n    const ioTriggerPromise = this.getStagePromise(stage)\n\n    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n      ioTriggerPromise,\n      displayName,\n      resolvedValue\n    )\n\n    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n    if (this.abortSignal) {\n      promise.catch(ignoreReject)\n    }\n    return promise\n  }\n}\n\nfunction ignoreReject() {}\n\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger<T>(\n  ioTrigger: Promise<any>,\n  displayName: string | undefined,\n  resolvedValue: T\n): Promise<T> {\n  // If we create a `new Promise` and give it a displayName\n  // (with no userspace code above us in the stack)\n  // React Devtools will use it as the IO cause when determining \"suspended by\".\n  // In particular, it should shadow any inner IO that resolved/rejected the promise\n  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n  const promise = new Promise<T>((resolve, reject) => {\n    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n  })\n  if (displayName !== undefined) {\n    // @ts-expect-error\n    promise.displayName = displayName\n  }\n  return promise\n}\n"],"names":["InvariantError","createPromiseWithResolvers","RenderStage","StagedRenderingController","constructor","abortSignal","hasRuntimePrefetch","currentStage","staticInterruptReason","runtimeInterruptReason","staticStageEndTime","Infinity","runtimeStageEndTime","runtimeStageListeners","dynamicStageListeners","runtimeStagePromise","dynamicStagePromise","mayAbandon","addEventListener","reason","promise","catch","ignoreReject","reject","once","onStage","stage","callback","push","canSyncInterrupt","boundaryStage","syncInterruptCurrentStageWithReason","abandonRenderImpl","advanceStage","getStaticInterruptReason","getRuntimeInterruptReason","getStaticStageEndTime","getRuntimeStageEndTime","abandonRender","resolveRuntimeStage","performance","now","timeOrigin","resolveDynamicStage","runtimeListeners","i","length","resolve","dynamicListeners","getStagePromise","waitForStage","delayUntilStage","displayName","resolvedValue","ioTriggerPromise","makeDevtoolsIOPromiseFromIOTrigger","ioTrigger","Promise","then","bind","undefined"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3824, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/segment-explorer-path.ts"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\n\nexport const BUILTIN_PREFIX = '__next_builtin__'\n\nconst nextInternalPrefixRegex =\n  /^(.*[\\\\/])?next[\\\\/]dist[\\\\/]client[\\\\/]components[\\\\/]builtin[\\\\/]/\n\nexport function normalizeConventionFilePath(\n  projectDir: string,\n  conventionPath: string | undefined\n) {\n  // Turbopack project path is formed as: \"<project root>/<cwd>\".\n  // When project root is not the working directory, we can extract the relative project root path.\n  // This is mostly used for running Next.js inside a monorepo.\n  const cwd = process.env.NEXT_RUNTIME === 'edge' ? '' : process.cwd()\n  const relativeProjectRoot = projectDir.replace(cwd, '')\n\n  let relativePath = (conventionPath || '')\n    // remove turbopack [project] prefix\n    .replace(/^\\[project\\]/, '')\n    // remove turbopack relative project path, everything after [project] and before the working directory.\n    .replace(relativeProjectRoot, '')\n    // remove the project root from the path\n    .replace(projectDir, '')\n    // remove cwd prefix\n    .replace(cwd, '')\n    // remove /(src/)?app/ dir prefix\n    .replace(/^([\\\\/])*(src[\\\\/])?app[\\\\/]/, '')\n\n  // If it's internal file only keep the filename, strip nextjs internal prefix\n  if (nextInternalPrefixRegex.test(relativePath)) {\n    relativePath = relativePath.replace(nextInternalPrefixRegex, '')\n    // Add a special prefix to let segment explorer know it's a built-in component\n    relativePath = `${BUILTIN_PREFIX}${relativePath}`\n  }\n\n  return relativePath.replace(/\\\\/g, '/')\n}\n\n// if a filepath is a builtin file. e.g.\n// .../project/node_modules/next/dist/client/components/builtin/global-error.js -> true\n// .../project/app/global-error.js -> false\nexport const isNextjsBuiltinFilePath = (filePath: string) => {\n  return nextInternalPrefixRegex.test(filePath)\n}\n\nexport const BOUNDARY_SUFFIX = '@boundary'\nexport function normalizeBoundaryFilename(filename: string) {\n  return filename\n    .replace(new RegExp(`^${BUILTIN_PREFIX}`), '')\n    .replace(new RegExp(`${BOUNDARY_SUFFIX}$`), '')\n}\n\nexport const BOUNDARY_PREFIX = 'boundary:'\nexport function isBoundaryFile(fileType: string) {\n  return fileType.startsWith(BOUNDARY_PREFIX)\n}\n\n// if a filename is a builtin file.\n// __next_builtin__global-error.js -> true\n// page.js -> false\nexport function isBuiltinBoundaryFile(fileType: string) {\n  return fileType.startsWith(BUILTIN_PREFIX)\n}\n\nexport function getBoundaryOriginFileType(fileType: string) {\n  return fileType.replace(BOUNDARY_PREFIX, '')\n}\n\nexport function getConventionPathByType(\n  tree: LoaderTree,\n  dir: string,\n  conventionType:\n    | 'layout'\n    | 'template'\n    | 'page'\n    | 'not-found'\n    | 'error'\n    | 'loading'\n    | 'forbidden'\n    | 'unauthorized'\n    | 'defaultPage'\n    | 'global-error'\n) {\n  const modules = tree[2]\n  const conventionPath = modules[conventionType]\n    ? modules[conventionType][1]\n    : undefined\n  if (conventionPath) {\n    return normalizeConventionFilePath(dir, conventionPath)\n  }\n  return undefined\n}\n"],"names":["BUILTIN_PREFIX","nextInternalPrefixRegex","normalizeConventionFilePath","projectDir","conventionPath","cwd","process","env","NEXT_RUNTIME","relativeProjectRoot","replace","relativePath","test","isNextjsBuiltinFilePath","filePath","BOUNDARY_SUFFIX","normalizeBoundaryFilename","filename","RegExp","BOUNDARY_PREFIX","isBoundaryFile","fileType","startsWith","isBuiltinBoundaryFile","getBoundaryOriginFileType","getConventionPathByType","tree","dir","conventionType","modules","undefined"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEO,MAAMA,iBAAiB,mBAAkB;AAEhD,MAAMC,0BACJ;AAEK,SAASC,4BACdC,UAAkB,EAClBC,cAAkC;IAElC,+DAA+D;IAC/D,iGAAiG;IACjG,6DAA6D;IAC7D,MAAMC,MAAMC,QAAQC,GAAG,CAACC,YAAY,KAAK,UAAS,KAAKF,QAAQD,GAAG;IAClE,MAAMI,sBAAsBN,WAAWO,OAAO,CAACL,KAAK;IAEpD,IAAIM,eAAgBP,CAAAA,kBAAkB,EAAC,EACrC,oCAAoC;KACnCM,OAAO,CAAC,gBAAgB,IACzB,uGAAuG;KACtGA,OAAO,CAACD,qBAAqB,IAC9B,wCAAwC;KACvCC,OAAO,CAACP,YAAY,IACrB,oBAAoB;KACnBO,OAAO,CAACL,KAAK,IACd,iCAAiC;KAChCK,OAAO,CAAC,gCAAgC;IAE3C,6EAA6E;IAC7E,IAAIT,wBAAwBW,IAAI,CAACD,eAAe;QAC9CA,eAAeA,aAAaD,OAAO,CAACT,yBAAyB;QAC7D,8EAA8E;QAC9EU,eAAe,GAAGX,iBAAiBW,cAAc;IACnD;IAEA,OAAOA,aAAaD,OAAO,CAAC,OAAO;AACrC;AAKO,MAAMG,0BAA0B,CAACC;IACtC,OAAOb,wBAAwBW,IAAI,CAACE;AACtC,EAAC;AAEM,MAAMC,kBAAkB,YAAW;AACnC,SAASC,0BAA0BC,QAAgB;IACxD,OAAOA,SACJP,OAAO,CAAC,IAAIQ,OAAO,CAAC,CAAC,EAAElB,gBAAgB,GAAG,IAC1CU,OAAO,CAAC,IAAIQ,OAAO,GAAGH,gBAAgB,CAAC,CAAC,GAAG;AAChD;AAEO,MAAMI,kBAAkB,YAAW;AACnC,SAASC,eAAeC,QAAgB;IAC7C,OAAOA,SAASC,UAAU,CAACH;AAC7B;AAKO,SAASI,sBAAsBF,QAAgB;IACpD,OAAOA,SAASC,UAAU,CAACtB;AAC7B;AAEO,SAASwB,0BAA0BH,QAAgB;IACxD,OAAOA,SAASX,OAAO,CAACS,iBAAiB;AAC3C;AAEO,SAASM,wBACdC,IAAgB,EAChBC,GAAW,EACXC,cAUkB;IAElB,MAAMC,UAAUH,IAAI,CAAC,EAAE;IACvB,MAAMtB,iBAAiByB,OAAO,CAACD,eAAe,GAC1CC,OAAO,CAACD,eAAe,CAAC,EAAE,GAC1BE;IACJ,IAAI1B,gBAAgB;QAClB,OAAOF,4BAA4ByB,KAAKvB;IAC1C;IACA,OAAO0B;AACT","ignoreList":[0]}},
    {"offset": {"line": 3897, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/create-component-tree.tsx"],"sourcesContent":["import type { ComponentType } from 'react'\nimport type {\n  CacheNodeSeedData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-types'\nimport type { PreloadCallbacks } from './types'\nimport {\n  isClientReference,\n  isUseCacheFunction,\n} from '../../lib/client-and-server-references'\nimport { getLayoutOrPageModule } from '../lib/app-dir-module'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { interopDefault } from './interop-default'\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\nimport type { AppRenderContext, GetDynamicParamFromSegment } from './app-render'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { getLayerAssets } from './get-layer-assets'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { validateRevalidate } from '../lib/patch-fetch'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/builtin/default'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NextNodeServerSpan } from '../lib/trace/constants'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport type { Params } from '../request/params'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport type {\n  UseCacheLayoutProps,\n  UseCachePageProps,\n} from '../use-cache/use-cache-wrapper'\nimport { DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\nimport {\n  BOUNDARY_PREFIX,\n  BOUNDARY_SUFFIX,\n  BUILTIN_PREFIX,\n  getConventionPathByType,\n  isNextjsBuiltinFilePath,\n} from './segment-explorer-path'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\n\n/**\n * Use the provided loader tree to create the React Component tree.\n */\nexport function createComponentTree(props: {\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n  authInterrupts: boolean\n  MetadataOutlet: ComponentType\n}): Promise<CacheNodeSeedData> {\n  return getTracer().trace(\n    NextNodeServerSpan.createComponentTree,\n    {\n      spanName: 'build component tree',\n    },\n    () => createComponentTreeInternal(props, true)\n  )\n}\n\nfunction errorMissingDefaultExport(\n  pagePath: string,\n  convention: string\n): never {\n  const normalizedPagePath = pagePath === '/' ? '' : pagePath\n  throw new Error(\n    `The default export is not a React Component in \"${normalizedPagePath}/${convention}\"`\n  )\n}\n\nconst cacheNodeKey = 'c'\n\nasync function createComponentTreeInternal(\n  {\n    loaderTree: tree,\n    parentParams,\n    rootLayoutIncluded,\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    ctx,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts,\n    MetadataOutlet,\n  }: {\n    loaderTree: LoaderTree\n    parentParams: Params\n    rootLayoutIncluded: boolean\n    injectedCSS: Set<string>\n    injectedJS: Set<string>\n    injectedFontPreloadTags: Set<string>\n    ctx: AppRenderContext\n    missingSlots?: Set<string>\n    preloadCallbacks: PreloadCallbacks\n    authInterrupts: boolean\n    MetadataOutlet: ComponentType | null\n  },\n  isRoot: boolean\n): Promise<CacheNodeSeedData> {\n  const {\n    renderOpts: { nextConfigOutput, experimental, cacheComponents },\n    workStore,\n    componentMod: {\n      createElement,\n      Fragment,\n      SegmentViewNode,\n      HTTPAccessFallbackBoundary,\n      LayoutRouter,\n      RenderFromTemplateContext,\n      ClientPageRoot,\n      ClientSegmentRoot,\n      createServerSearchParamsForServerPage,\n      createPrerenderSearchParamsForClientPage,\n      createServerParamsForServerSegment,\n      createPrerenderParamsForClientSegment,\n      serverHooks: { DynamicServerError },\n      Postpone,\n    },\n    pagePath,\n    getDynamicParamFromSegment,\n    isPrefetch,\n    query,\n  } = ctx\n\n  const { page, conventionPath, segment, modules, parallelRoutes } =\n    parseLoaderTree(tree)\n\n  const {\n    layout,\n    template,\n    error,\n    loading,\n    'not-found': notFound,\n    forbidden,\n    unauthorized,\n  } = modules\n\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n\n  const layerAssets = getLayerAssets({\n    preloadCallbacks,\n    ctx,\n    layoutOrPagePath: conventionPath,\n    injectedCSS: injectedCSSWithCurrentLayout,\n    injectedJS: injectedJSWithCurrentLayout,\n    injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  })\n\n  const [Template, templateStyles, templateScripts] = template\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: template[1],\n        getComponent: template[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : [Fragment]\n\n  const [ErrorComponent, errorStyles, errorScripts] = error\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: error[1],\n        getComponent: error[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Loading, loadingStyles, loadingScripts] = loading\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: loading[1],\n        getComponent: loading[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const isLayout = typeof layout !== 'undefined'\n  const isPage = typeof page !== 'undefined'\n  const { mod: layoutOrPageMod, modType } = await getTracer().trace(\n    NextNodeServerSpan.getLayoutOrPageModule,\n    {\n      hideSpan: !(isLayout || isPage),\n      spanName: 'resolve segment modules',\n      attributes: {\n        'next.segment': segment,\n      },\n    },\n    () => getLayoutOrPageModule(tree)\n  )\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  const [NotFound, notFoundStyles] = notFound\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: notFound[1],\n        getComponent: notFound[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const prefetchConfig = layoutOrPageMod\n    ? (layoutOrPageMod as AppSegmentConfig).unstable_prefetch\n    : undefined\n  /** Whether this segment should use a runtime prefetch instead of a static prefetch. */\n  const hasRuntimePrefetch = prefetchConfig?.mode === 'runtime'\n\n  const [Forbidden, forbiddenStyles] =\n    authInterrupts && forbidden\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: forbidden[1],\n          getComponent: forbidden[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  const [Unauthorized, unauthorizedStyles] =\n    authInterrupts && unauthorized\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: unauthorized[1],\n          getComponent: unauthorized[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  let dynamic = layoutOrPageMod?.dynamic\n\n  if (nextConfigOutput === 'export') {\n    if (!dynamic || dynamic === 'auto') {\n      dynamic = 'error'\n    } else if (dynamic === 'force-dynamic') {\n      // force-dynamic is always incompatible with 'export'. We must interrupt the build\n      throw new StaticGenBailoutError(\n        `Page with \\`dynamic = \"force-dynamic\"\\` couldn't be exported. \\`output: \"export\"\\` requires all pages be renderable statically because there is no runtime server to dynamically render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`\n      )\n    }\n  }\n\n  if (typeof dynamic === 'string') {\n    // the nested most config wins so we only force-static\n    // if it's configured above any parent that configured\n    // otherwise\n    if (dynamic === 'error') {\n      workStore.dynamicShouldError = true\n    } else if (dynamic === 'force-dynamic') {\n      workStore.forceDynamic = true\n\n      // TODO: (PPR) remove this bailout once PPR is the default\n      if (workStore.isStaticGeneration && !experimental.isRoutePPREnabled) {\n        // If the postpone API isn't available, we can't postpone the render and\n        // therefore we can't use the dynamic API.\n        const err = new DynamicServerError(\n          `Page with \\`dynamic = \"force-dynamic\"\\` won't be rendered statically.`\n        )\n        workStore.dynamicUsageDescription = err.message\n        workStore.dynamicUsageStack = err.stack\n        throw err\n      }\n    } else {\n      workStore.dynamicShouldError = false\n      workStore.forceStatic = dynamic === 'force-static'\n    }\n  }\n\n  if (typeof layoutOrPageMod?.fetchCache === 'string') {\n    workStore.fetchCache = layoutOrPageMod?.fetchCache\n  }\n\n  if (typeof layoutOrPageMod?.revalidate !== 'undefined') {\n    validateRevalidate(layoutOrPageMod?.revalidate, workStore.route)\n  }\n\n  if (typeof layoutOrPageMod?.revalidate === 'number') {\n    const defaultRevalidate = layoutOrPageMod.revalidate as number\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n        case 'prerender-runtime':\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n          if (workUnitStore.revalidate > defaultRevalidate) {\n            workUnitStore.revalidate = defaultRevalidate\n          }\n          break\n        case 'request':\n          // A request store doesn't have a revalidate property.\n          break\n        // createComponentTree is not called for these stores:\n        case 'cache':\n        case 'private-cache':\n        case 'prerender-client':\n        case 'unstable-cache':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (\n      !workStore.forceStatic &&\n      workStore.isStaticGeneration &&\n      defaultRevalidate === 0 &&\n      // If the postpone API isn't available, we can't postpone the render and\n      // therefore we can't use the dynamic API.\n      !experimental.isRoutePPREnabled\n    ) {\n      const dynamicUsageDescription = `revalidate: 0 configured ${segment}`\n      workStore.dynamicUsageDescription = dynamicUsageDescription\n\n      throw new DynamicServerError(dynamicUsageDescription)\n    }\n  }\n\n  const isStaticGeneration = workStore.isStaticGeneration\n\n  // Assume the segment we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // It's OK for this to be `true` when the data is actually fully static, but\n  // it's not OK for this to be `false` when the data possibly contains holes.\n  // Although the value here is overly pessimistic, for prefetches, it will be\n  // replaced by a more specific value when the data is later processed into\n  // per-segment responses (see collect-segment-data.tsx)\n  //\n  // For dynamic requests, this must always be `false` because dynamic responses\n  // are never partial.\n  const isPossiblyPartialResponse =\n    isStaticGeneration && experimental.isRoutePPREnabled === true\n\n  const LayoutOrPage: ComponentType<any> | undefined = layoutOrPageMod\n    ? interopDefault(layoutOrPageMod)\n    : undefined\n\n  /**\n   * The React Component to render.\n   */\n  let MaybeComponent = LayoutOrPage\n\n  if (process.env.NODE_ENV === 'development' || isStaticGeneration) {\n    const { isValidElementType } =\n      require('next/dist/compiled/react-is') as typeof import('next/dist/compiled/react-is')\n    if (\n      typeof MaybeComponent !== 'undefined' &&\n      !isValidElementType(MaybeComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, modType ?? 'page')\n    }\n\n    if (\n      typeof ErrorComponent !== 'undefined' &&\n      !isValidElementType(ErrorComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, 'error')\n    }\n\n    if (typeof Loading !== 'undefined' && !isValidElementType(Loading)) {\n      errorMissingDefaultExport(pagePath, 'loading')\n    }\n\n    if (typeof NotFound !== 'undefined' && !isValidElementType(NotFound)) {\n      errorMissingDefaultExport(pagePath, 'not-found')\n    }\n\n    if (typeof Forbidden !== 'undefined' && !isValidElementType(Forbidden)) {\n      errorMissingDefaultExport(pagePath, 'forbidden')\n    }\n\n    if (\n      typeof Unauthorized !== 'undefined' &&\n      !isValidElementType(Unauthorized)\n    ) {\n      errorMissingDefaultExport(pagePath, 'unauthorized')\n    }\n  }\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  // Create object holding the parent params and current params\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  // Resolve the segment param\n  const isSegmentViewEnabled = !!ctx.renderOpts.dev\n  const dir =\n    (process.env.NEXT_RUNTIME === 'edge'\n      ? process.env.__NEXT_EDGE_PROJECT_DIR\n      : ctx.renderOpts.dir) || ''\n\n  const [notFoundElement, notFoundFilePath] =\n    await createBoundaryConventionElement({\n      ctx,\n      conventionName: 'not-found',\n      Component: NotFound,\n      styles: notFoundStyles,\n      tree,\n    })\n\n  const [forbiddenElement] = await createBoundaryConventionElement({\n    ctx,\n    conventionName: 'forbidden',\n    Component: Forbidden,\n    styles: forbiddenStyles,\n    tree,\n  })\n\n  const [unauthorizedElement] = await createBoundaryConventionElement({\n    ctx,\n    conventionName: 'unauthorized',\n    Component: Unauthorized,\n    styles: unauthorizedStyles,\n    tree,\n  })\n\n  // TODO: Combine this `map` traversal with the loop below that turns the array\n  // into an object.\n  const parallelRouteMap = await Promise.all(\n    Object.keys(parallelRoutes).map(\n      async (\n        parallelRouteKey\n      ): Promise<[string, React.ReactNode, CacheNodeSeedData | null]> => {\n        const isChildrenRouteKey = parallelRouteKey === 'children'\n        const parallelRoute = parallelRoutes[parallelRouteKey]\n\n        const notFoundComponent = isChildrenRouteKey\n          ? notFoundElement\n          : undefined\n\n        const forbiddenComponent = isChildrenRouteKey\n          ? forbiddenElement\n          : undefined\n\n        const unauthorizedComponent = isChildrenRouteKey\n          ? unauthorizedElement\n          : undefined\n\n        // if we're prefetching and that there's a Loading component, we bail out\n        // otherwise we keep rendering for the prefetch.\n        // We also want to bail out if there's no Loading component in the tree.\n        let childCacheNodeSeedData: CacheNodeSeedData | null = null\n\n        if (\n          // Before PPR, the way instant navigations work in Next.js is we\n          // prefetch everything up to the first route segment that defines a\n          // loading.tsx boundary. (We do the same if there's no loading\n          // boundary in the entire tree, because we don't want to prefetch too\n          // much) The rest of the tree is deferred until the actual navigation.\n          // It does not take into account whether the data is dynamic  even if\n          // the tree is completely static, it will still defer everything\n          // inside the loading boundary.\n          //\n          // This behavior predates PPR and is only relevant if the\n          // PPR flag is not enabled.\n          isPrefetch &&\n          (Loading || !hasLoadingComponentInTree(parallelRoute)) &&\n          // The approach with PPR is different  loading.tsx behaves like a\n          // regular Suspense boundary and has no special behavior.\n          //\n          // With PPR, we prefetch as deeply as possible, and only defer when\n          // dynamic data is accessed. If so, we only defer the nearest parent\n          // Suspense boundary of the dynamic data access, regardless of whether\n          // the boundary is defined by loading.tsx or a normal <Suspense>\n          // component in userspace.\n          //\n          // NOTE: In practice this usually means we'll end up prefetching more\n          // than we were before PPR, which may or may not be considered a\n          // performance regression by some apps. The plan is to address this\n          // before General Availability of PPR by introducing granular\n          // per-segment fetching, so we can reuse as much of the tree as\n          // possible during both prefetches and dynamic navigations. But during\n          // the beta period, we should be clear about this trade off in our\n          // communications.\n          !experimental.isRoutePPREnabled\n        ) {\n          // Don't prefetch this child. This will trigger a lazy fetch by the\n          // client router.\n        } else {\n          // Create the child component\n\n          if (process.env.NODE_ENV === 'development' && missingSlots) {\n            // When we detect the default fallback (which triggers a 404), we collect the missing slots\n            // to provide more helpful debug information during development mode.\n            const parsedTree = parseLoaderTree(parallelRoute)\n            if (\n              parsedTree.conventionPath?.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)\n            ) {\n              missingSlots.add(parallelRouteKey)\n            }\n          }\n\n          const seedData = await createComponentTreeInternal(\n            {\n              loaderTree: parallelRoute,\n              parentParams: currentParams,\n              rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n              injectedCSS: injectedCSSWithCurrentLayout,\n              injectedJS: injectedJSWithCurrentLayout,\n              injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n              ctx,\n              missingSlots,\n              preloadCallbacks,\n              authInterrupts,\n              // `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page\n              // but we only want to throw on the first one.\n              MetadataOutlet: isChildrenRouteKey ? MetadataOutlet : null,\n            },\n            false\n          )\n\n          childCacheNodeSeedData = seedData\n        }\n\n        const templateNode = createElement(\n          Template,\n          null,\n          createElement(RenderFromTemplateContext, null)\n        )\n\n        const templateFilePath = getConventionPathByType(tree, dir, 'template')\n        const errorFilePath = getConventionPathByType(tree, dir, 'error')\n        const loadingFilePath = getConventionPathByType(tree, dir, 'loading')\n        const globalErrorFilePath = isRoot\n          ? getConventionPathByType(tree, dir, 'global-error')\n          : undefined\n\n        const wrappedErrorStyles =\n          isSegmentViewEnabled && errorFilePath\n            ? createElement(\n                SegmentViewNode,\n                {\n                  type: 'error',\n                  pagePath: errorFilePath,\n                },\n                errorStyles\n              )\n            : errorStyles\n\n        // Add a suffix to avoid conflict with the segment view node representing rendered file.\n        // existence: not-found.tsx@boundary\n        // rendered: not-found.tsx\n        const fileNameSuffix = BOUNDARY_SUFFIX\n        const segmentViewBoundaries = isSegmentViewEnabled\n          ? createElement(\n              Fragment,\n              null,\n              notFoundFilePath &&\n                createElement(SegmentViewNode, {\n                  type: `${BOUNDARY_PREFIX}not-found`,\n                  pagePath: notFoundFilePath + fileNameSuffix,\n                }),\n              loadingFilePath &&\n                createElement(SegmentViewNode, {\n                  type: `${BOUNDARY_PREFIX}loading`,\n                  pagePath: loadingFilePath + fileNameSuffix,\n                }),\n              errorFilePath &&\n                createElement(SegmentViewNode, {\n                  type: `${BOUNDARY_PREFIX}error`,\n                  pagePath: errorFilePath + fileNameSuffix,\n                }),\n              globalErrorFilePath &&\n                createElement(SegmentViewNode, {\n                  type: `${BOUNDARY_PREFIX}global-error`,\n                  pagePath: isNextjsBuiltinFilePath(globalErrorFilePath)\n                    ? `${BUILTIN_PREFIX}global-error.js${fileNameSuffix}`\n                    : globalErrorFilePath,\n                })\n            )\n          : null\n\n        return [\n          parallelRouteKey,\n          createElement(LayoutRouter, {\n            parallelRouterKey: parallelRouteKey,\n            error: ErrorComponent,\n            errorStyles: wrappedErrorStyles,\n            errorScripts: errorScripts,\n            template:\n              isSegmentViewEnabled && templateFilePath\n                ? createElement(\n                    SegmentViewNode,\n                    {\n                      type: 'template',\n                      pagePath: templateFilePath,\n                    },\n                    templateNode\n                  )\n                : templateNode,\n            templateStyles: templateStyles,\n            templateScripts: templateScripts,\n            notFound: notFoundComponent,\n            forbidden: forbiddenComponent,\n            unauthorized: unauthorizedComponent,\n            ...(isSegmentViewEnabled && {\n              segmentViewBoundaries,\n            }),\n          }),\n          childCacheNodeSeedData,\n        ]\n      }\n    )\n  )\n\n  // Convert the parallel route map into an object after all promises have been resolved.\n  let parallelRouteProps: { [key: string]: React.ReactNode } = {}\n  let parallelRouteCacheNodeSeedData: {\n    [key: string]: CacheNodeSeedData | null\n  } = {}\n  for (const parallelRoute of parallelRouteMap) {\n    const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute\n    parallelRouteProps[parallelRouteKey] = parallelRouteProp\n    parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData\n  }\n\n  let loadingElement = Loading\n    ? createElement(Loading, {\n        key: 'l',\n      })\n    : null\n  const loadingFilePath = getConventionPathByType(tree, dir, 'loading')\n  if (isSegmentViewEnabled && loadingElement) {\n    if (loadingFilePath) {\n      loadingElement = createElement(\n        SegmentViewNode,\n        {\n          key: cacheNodeKey + '-loading',\n          type: 'loading',\n          pagePath: loadingFilePath,\n        },\n        loadingElement\n      )\n    }\n  }\n\n  const loadingData: LoadingModuleData = loadingElement\n    ? [loadingElement, loadingStyles, loadingScripts]\n    : null\n\n  // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component\n  if (!MaybeComponent) {\n    return [\n      createElement(\n        Fragment,\n        {\n          key: cacheNodeKey,\n        },\n        layerAssets,\n        parallelRouteProps.children\n      ),\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n      hasRuntimePrefetch,\n    ]\n  }\n\n  const Component = MaybeComponent\n  // If force-dynamic is used and the current render supports postponing, we\n  // replace it with a node that will postpone the render. This ensures that the\n  // postpone is invoked during the react render phase and not during the next\n  // render phase.\n  // @TODO this does not actually do what it seems like it would or should do. The idea is that\n  // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments\n  // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However\n  // because this comes after the children traversal and the static generation store is mutated every segment\n  // along the parent path of a force-dynamic segment will hit this condition effectively making the entire\n  // render force-dynamic. We should refactor this function so that we can correctly track which segments\n  // need to be dynamic\n  if (\n    workStore.isStaticGeneration &&\n    workStore.forceDynamic &&\n    experimental.isRoutePPREnabled\n  ) {\n    return [\n      createElement(\n        Fragment,\n        {\n          key: cacheNodeKey,\n        },\n        createElement(Postpone, {\n          reason: 'dynamic = \"force-dynamic\" was used',\n          route: workStore.route,\n        }),\n        layerAssets\n      ),\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      true,\n      hasRuntimePrefetch,\n    ]\n  }\n\n  const isClientComponent = isClientReference(layoutOrPageMod)\n\n  if (\n    process.env.NODE_ENV === 'development' &&\n    'params' in parallelRouteProps\n  ) {\n    // @TODO consider making this an error and running the check in build as well\n    console.error(\n      `\"params\" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`\n    )\n  }\n\n  if (isPage) {\n    const PageComponent = Component\n\n    // Assign searchParams to props if this is a page\n    let pageElement: React.ReactNode\n    if (isClientComponent) {\n      if (cacheComponents) {\n        // Params are omitted when Cache Components is enabled\n        pageElement = createElement(ClientPageRoot, {\n          Component: PageComponent,\n          serverProvidedParams: null,\n        })\n      } else if (isStaticGeneration) {\n        const promiseOfParams =\n          createPrerenderParamsForClientSegment(currentParams)\n        const promiseOfSearchParams =\n          createPrerenderSearchParamsForClientPage(workStore)\n        pageElement = createElement(ClientPageRoot, {\n          Component: PageComponent,\n          serverProvidedParams: {\n            searchParams: query,\n            params: currentParams,\n            promises: [promiseOfSearchParams, promiseOfParams],\n          },\n        })\n      } else {\n        pageElement = createElement(ClientPageRoot, {\n          Component: PageComponent,\n          serverProvidedParams: {\n            searchParams: query,\n            params: currentParams,\n            promises: null,\n          },\n        })\n      }\n    } else {\n      // If we are passing params to a server component Page we need to track\n      // their usage in case the current render mode tracks dynamic API usage.\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      // If we are passing searchParams to a server component Page we need to\n      // track their usage in case the current render mode tracks dynamic API\n      // usage.\n      let searchParams = createServerSearchParamsForServerPage(query, workStore)\n\n      if (isUseCacheFunction(PageComponent)) {\n        const UseCachePageComponent: ComponentType<UseCachePageProps> =\n          PageComponent\n\n        pageElement = createElement(UseCachePageComponent, {\n          params: params,\n          searchParams: searchParams,\n          $$isPage: true,\n        })\n      } else {\n        pageElement = createElement(PageComponent, {\n          params: params,\n          searchParams: searchParams,\n        })\n      }\n    }\n\n    const isDefaultSegment = segment === DEFAULT_SEGMENT_KEY\n    const pageFilePath =\n      getConventionPathByType(tree, dir, 'page') ??\n      getConventionPathByType(tree, dir, 'defaultPage')\n    const segmentType = isDefaultSegment ? 'default' : 'page'\n    const wrappedPageElement =\n      isSegmentViewEnabled && pageFilePath\n        ? createElement(\n            SegmentViewNode,\n            {\n              key: cacheNodeKey + '-' + segmentType,\n              type: segmentType,\n              pagePath: pageFilePath,\n            },\n            pageElement\n          )\n        : pageElement\n\n    return [\n      createElement(\n        Fragment,\n        {\n          key: cacheNodeKey,\n        },\n        wrappedPageElement,\n        layerAssets,\n        MetadataOutlet ? createElement(MetadataOutlet, null) : null\n      ),\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n      hasRuntimePrefetch,\n    ]\n  } else {\n    const SegmentComponent = Component\n    const isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot =\n      rootLayoutAtThisLevel &&\n      'children' in parallelRoutes &&\n      Object.keys(parallelRoutes).length > 1\n\n    let segmentNode: React.ReactNode\n\n    if (isClientComponent) {\n      let clientSegment: React.ReactNode\n      if (cacheComponents) {\n        // Params are omitted when Cache Components is enabled\n        clientSegment = createElement(ClientSegmentRoot, {\n          Component: SegmentComponent,\n          slots: parallelRouteProps,\n          serverProvidedParams: null,\n        })\n      } else if (isStaticGeneration) {\n        const promiseOfParams =\n          createPrerenderParamsForClientSegment(currentParams)\n\n        clientSegment = createElement(ClientSegmentRoot, {\n          Component: SegmentComponent,\n          slots: parallelRouteProps,\n          serverProvidedParams: {\n            params: currentParams,\n            promises: [promiseOfParams],\n          },\n        })\n      } else {\n        clientSegment = createElement(ClientSegmentRoot, {\n          Component: SegmentComponent,\n          slots: parallelRouteProps,\n          serverProvidedParams: {\n            params: currentParams,\n            promises: null,\n          },\n        })\n      }\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        let notfoundClientSegment: React.ReactNode\n        let forbiddenClientSegment: React.ReactNode\n        let unauthorizedClientSegment: React.ReactNode\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        notfoundClientSegment = createErrorBoundaryClientSegmentRoot({\n          ctx,\n          ErrorBoundaryComponent: NotFound,\n          errorElement: notFoundElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({\n          ctx,\n          ErrorBoundaryComponent: Forbidden,\n          errorElement: forbiddenElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({\n          ctx,\n          ErrorBoundaryComponent: Unauthorized,\n          errorElement: unauthorizedElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        if (\n          notfoundClientSegment ||\n          forbiddenClientSegment ||\n          unauthorizedClientSegment\n        ) {\n          segmentNode = createElement(\n            HTTPAccessFallbackBoundary,\n            {\n              key: cacheNodeKey,\n              notFound: notfoundClientSegment,\n              forbidden: forbiddenClientSegment,\n              unauthorized: unauthorizedClientSegment,\n            },\n            layerAssets,\n            clientSegment\n          )\n        } else {\n          segmentNode = createElement(\n            Fragment,\n            {\n              key: cacheNodeKey,\n            },\n            layerAssets,\n            clientSegment\n          )\n        }\n      } else {\n        segmentNode = createElement(\n          Fragment,\n          {\n            key: cacheNodeKey,\n          },\n          layerAssets,\n          clientSegment\n        )\n      }\n    } else {\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      let serverSegment: React.ReactNode\n\n      if (isUseCacheFunction(SegmentComponent)) {\n        const UseCacheLayoutComponent: ComponentType<UseCacheLayoutProps> =\n          SegmentComponent\n\n        serverSegment = createElement(\n          UseCacheLayoutComponent,\n          {\n            ...parallelRouteProps,\n            params: params,\n            $$isLayout: true,\n          },\n          // Force static children here so that they're validated.\n          // See https://github.com/facebook/react/pull/34846\n          parallelRouteProps.children\n        )\n      } else {\n        serverSegment = createElement(\n          SegmentComponent,\n          {\n            ...parallelRouteProps,\n            params: params,\n          },\n          // Force static children here so that they're validated.\n          // See https://github.com/facebook/react/pull/34846\n          parallelRouteProps.children\n        )\n      }\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        segmentNode = createElement(\n          HTTPAccessFallbackBoundary,\n          {\n            key: cacheNodeKey,\n            notFound: notFoundElement\n              ? createElement(\n                  Fragment,\n                  null,\n                  layerAssets,\n                  createElement(\n                    SegmentComponent,\n                    {\n                      params: params,\n                    },\n                    notFoundStyles,\n                    notFoundElement\n                  )\n                )\n              : undefined,\n          },\n          layerAssets,\n          serverSegment\n        )\n      } else {\n        segmentNode = createElement(\n          Fragment,\n          {\n            key: cacheNodeKey,\n          },\n          layerAssets,\n          serverSegment\n        )\n      }\n    }\n\n    const layoutFilePath = getConventionPathByType(tree, dir, 'layout')\n    const wrappedSegmentNode =\n      isSegmentViewEnabled && layoutFilePath\n        ? createElement(\n            SegmentViewNode,\n            {\n              key: 'layout',\n              type: 'layout',\n              pagePath: layoutFilePath,\n            },\n            segmentNode\n          )\n        : segmentNode\n\n    // For layouts we just render the component\n    return [\n      wrappedSegmentNode,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n      hasRuntimePrefetch,\n    ]\n  }\n}\n\nfunction createErrorBoundaryClientSegmentRoot({\n  ctx,\n  ErrorBoundaryComponent,\n  errorElement,\n  ClientSegmentRoot,\n  layerAssets,\n  SegmentComponent,\n  currentParams,\n}: {\n  ctx: AppRenderContext\n  ErrorBoundaryComponent: ComponentType<any> | undefined\n  errorElement: React.ReactNode\n  ClientSegmentRoot: ComponentType<any>\n  layerAssets: React.ReactNode\n  SegmentComponent: ComponentType<any>\n  currentParams: Params\n}) {\n  const {\n    componentMod: { createElement, Fragment },\n  } = ctx\n  if (ErrorBoundaryComponent) {\n    const notFoundParallelRouteProps = {\n      children: errorElement,\n    }\n    return createElement(\n      Fragment,\n      null,\n      layerAssets,\n      createElement(ClientSegmentRoot, {\n        Component: SegmentComponent,\n        slots: notFoundParallelRouteProps,\n        params: currentParams,\n      })\n    )\n  }\n  return null\n}\n\nexport function getRootParams(\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  return getRootParamsImpl({}, loaderTree, getDynamicParamFromSegment)\n}\n\nfunction getRootParamsImpl(\n  parentParams: Params,\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  const {\n    segment,\n    modules: { layout },\n    parallelRoutes,\n  } = parseLoaderTree(loaderTree)\n\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  const isRootLayout = typeof layout !== 'undefined'\n\n  if (isRootLayout) {\n    return currentParams\n  } else if (!parallelRoutes.children) {\n    // This should really be an error but there are bugs in Turbopack that cause\n    // the _not-found LoaderTree to not have any layouts. For rootParams sake\n    // this is somewhat irrelevant when you are not customizing the 404 page.\n    // If you are customizing 404\n    // TODO update rootParams to make all params optional if `/app/not-found.tsx` is defined\n    return currentParams\n  } else {\n    return getRootParamsImpl(\n      currentParams,\n      // We stop looking for root params as soon as we hit the first layout\n      // and it is not possible to use parallel route children above the root layout\n      // so every parallelRoutes object that this function can visit will necessarily\n      // have a single `children` prop and no others.\n      parallelRoutes.children,\n      getDynamicParamFromSegment\n    )\n  }\n}\n\nasync function createBoundaryConventionElement({\n  ctx,\n  conventionName,\n  Component,\n  styles,\n  tree,\n}: {\n  ctx: AppRenderContext\n  conventionName:\n    | 'not-found'\n    | 'error'\n    | 'loading'\n    | 'forbidden'\n    | 'unauthorized'\n  Component: ComponentType<any> | undefined\n  styles: React.ReactNode | undefined\n  tree: LoaderTree\n}) {\n  const {\n    componentMod: { createElement, Fragment },\n  } = ctx\n  const isSegmentViewEnabled = !!ctx.renderOpts.dev\n  const dir =\n    (process.env.NEXT_RUNTIME === 'edge'\n      ? process.env.__NEXT_EDGE_PROJECT_DIR\n      : ctx.renderOpts.dir) || ''\n  const { SegmentViewNode } = ctx.componentMod\n  const element = Component\n    ? createElement(Fragment, null, createElement(Component, null), styles)\n    : undefined\n\n  const pagePath = getConventionPathByType(tree, dir, conventionName)\n\n  const wrappedElement =\n    isSegmentViewEnabled && element\n      ? createElement(\n          SegmentViewNode,\n          {\n            key: cacheNodeKey + '-' + conventionName,\n            type: conventionName,\n            // TODO: Discovered when moving to `createElement`.\n            // `SegmentViewNode` doesn't support undefined `pagePath`\n            pagePath: pagePath!,\n          },\n          element\n        )\n      : element\n\n  return [wrappedElement, pagePath] as const\n}\n"],"names":["isClientReference","isUseCacheFunction","getLayoutOrPageModule","interopDefault","parseLoaderTree","createComponentStylesAndScripts","getLayerAssets","hasLoadingComponentInTree","validateRevalidate","PARALLEL_ROUTE_DEFAULT_PATH","getTracer","NextNodeServerSpan","StaticGenBailoutError","workUnitAsyncStorage","DEFAULT_SEGMENT_KEY","BOUNDARY_PREFIX","BOUNDARY_SUFFIX","BUILTIN_PREFIX","getConventionPathByType","isNextjsBuiltinFilePath","createComponentTree","props","trace","spanName","createComponentTreeInternal","errorMissingDefaultExport","pagePath","convention","normalizedPagePath","Error","cacheNodeKey","loaderTree","tree","parentParams","rootLayoutIncluded","injectedCSS","injectedJS","injectedFontPreloadTags","ctx","missingSlots","preloadCallbacks","authInterrupts","MetadataOutlet","isRoot","renderOpts","nextConfigOutput","experimental","cacheComponents","workStore","componentMod","createElement","Fragment","SegmentViewNode","HTTPAccessFallbackBoundary","LayoutRouter","RenderFromTemplateContext","ClientPageRoot","ClientSegmentRoot","createServerSearchParamsForServerPage","createPrerenderSearchParamsForClientPage","createServerParamsForServerSegment","createPrerenderParamsForClientSegment","serverHooks","DynamicServerError","Postpone","getDynamicParamFromSegment","isPrefetch","query","page","conventionPath","segment","modules","parallelRoutes","layout","template","error","loading","notFound","forbidden","unauthorized","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","layerAssets","layoutOrPagePath","Template","templateStyles","templateScripts","filePath","getComponent","ErrorComponent","errorStyles","errorScripts","Loading","loadingStyles","loadingScripts","isLayout","isPage","mod","layoutOrPageMod","modType","hideSpan","attributes","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","NotFound","notFoundStyles","prefetchConfig","unstable_prefetch","undefined","hasRuntimePrefetch","mode","Forbidden","forbiddenStyles","Unauthorized","unauthorizedStyles","dynamic","dynamicShouldError","forceDynamic","isStaticGeneration","isRoutePPREnabled","err","dynamicUsageDescription","message","dynamicUsageStack","stack","forceStatic","fetchCache","revalidate","route","defaultRevalidate","workUnitStore","getStore","type","isPossiblyPartialResponse","LayoutOrPage","MaybeComponent","process","env","NODE_ENV","isValidElementType","require","segmentParam","currentParams","value","param","isSegmentViewEnabled","dev","dir","NEXT_RUNTIME","__NEXT_EDGE_PROJECT_DIR","notFoundElement","notFoundFilePath","createBoundaryConventionElement","conventionName","Component","styles","forbiddenElement","unauthorizedElement","parallelRouteMap","Promise","all","Object","keys","map","parallelRouteKey","isChildrenRouteKey","parallelRoute","notFoundComponent","forbiddenComponent","unauthorizedComponent","childCacheNodeSeedData","parsedTree","endsWith","add","seedData","templateNode","templateFilePath","errorFilePath","loadingFilePath","globalErrorFilePath","wrappedErrorStyles","fileNameSuffix","segmentViewBoundaries","parallelRouterKey","parallelRouteProps","parallelRouteCacheNodeSeedData","parallelRouteProp","flightData","loadingElement","key","loadingData","children","reason","isClientComponent","console","PageComponent","pageElement","serverProvidedParams","promiseOfParams","promiseOfSearchParams","searchParams","params","promises","UseCachePageComponent","$$isPage","isDefaultSegment","pageFilePath","segmentType","wrappedPageElement","SegmentComponent","isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot","length","segmentNode","clientSegment","slots","notfoundClientSegment","forbiddenClientSegment","unauthorizedClientSegment","createErrorBoundaryClientSegmentRoot","ErrorBoundaryComponent","errorElement","serverSegment","UseCacheLayoutComponent","$$isLayout","layoutFilePath","wrappedSegmentNode","notFoundParallelRouteProps","getRootParams","getRootParamsImpl","isRootLayout","element","wrappedElement"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4649, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/walk-tree-with-flight-router-state.tsx"],"sourcesContent":["import type {\n  FlightDataPath,\n  FlightDataSegment,\n  FlightRouterState,\n  Segment,\n  HeadData,\n} from '../../shared/lib/app-router-types'\nimport type { PreloadCallbacks } from './types'\nimport { matchSegment } from '../../client/components/match-segments'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport {\n  createFlightRouterStateFromLoaderTree,\n  createRouteTreePrefetch,\n} from './create-flight-router-state-from-loader-tree'\nimport type { AppRenderContext } from './app-render'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { addSearchParamsIfPageSegment } from '../../shared/lib/segment'\nimport { createComponentTree } from './create-component-tree'\nimport { getSegmentParam } from '../../shared/lib/router/utils/get-segment-param'\n\n/**\n * Use router state to decide at what common layout to render the page.\n * This can either be the common layout between two pages or a specific place to start rendering from using the \"refetch\" marker in the tree.\n */\nexport async function walkTreeWithFlightRouterState({\n  loaderTreeToFilter,\n  parentParams,\n  flightRouterState,\n  parentIsInsideSharedLayout,\n  rscHead,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  rootLayoutIncluded,\n  ctx,\n  preloadCallbacks,\n  MetadataOutlet,\n}: {\n  loaderTreeToFilter: LoaderTree\n  parentParams: { [key: string]: string | string[] }\n  flightRouterState?: FlightRouterState\n  rscHead: HeadData\n  parentIsInsideSharedLayout?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  rootLayoutIncluded: boolean\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n  MetadataOutlet: React.ComponentType\n}): Promise<FlightDataPath[]> {\n  const {\n    renderOpts: { nextFontManifest, experimental },\n    query,\n    isPrefetch,\n    getDynamicParamFromSegment,\n    parsedRequestHeaders,\n  } = ctx\n\n  const [segment, parallelRoutes, modules] = loaderTreeToFilter\n\n  const parallelRoutesKeys = Object.keys(parallelRoutes)\n\n  const { layout } = modules\n  const isLayout = typeof layout !== 'undefined'\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts\n  const segmentParam = getDynamicParamFromSegment(segment)\n  const currentParams =\n    // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null\n      ? {\n          ...parentParams,\n          [segmentParam.param]: segmentParam.value,\n        }\n      : parentParams\n  const actualSegment: Segment = addSearchParamsIfPageSegment(\n    segmentParam ? segmentParam.treeSegment : segment,\n    query\n  )\n\n  /**\n   * Decide if the current segment is where rendering has to start.\n   */\n  const renderComponentsOnThisLevel =\n    // No further router state available\n    !flightRouterState ||\n    // Segment in router state does not match current segment\n    !matchSegment(actualSegment, flightRouterState[0]) ||\n    // Last item in the tree\n    parallelRoutesKeys.length === 0 ||\n    // Explicit refresh\n    flightRouterState[3] === 'refetch'\n\n  // Pre-PPR, the `loading` component signals to the router how deep to render the component tree\n  // to ensure prefetches are quick and inexpensive. If there's no `loading` component anywhere in the tree being rendered,\n  // the prefetch will be short-circuited to avoid requesting a potentially very expensive subtree. If there's a `loading`\n  // somewhere in the tree, we'll recursively render the component tree up until we encounter that loading component, and then stop.\n\n  // Check if we're inside the \"new\" part of the navigation  inside the\n  // shared layout. In the case of a prefetch, this can be true even if the\n  // segment matches, because the client might send a matching segment to\n  // indicate that it already has the data in its cache. But in order to find\n  // the correct loading boundary, we still need to track where the shared\n  // layout begins.\n  //\n  // TODO: We should rethink the protocol for dynamic requests. It might not\n  // make sense for the client to send a FlightRouterState, since that type is\n  // overloaded with other concerns.\n  const isInsideSharedLayout =\n    renderComponentsOnThisLevel ||\n    parentIsInsideSharedLayout ||\n    flightRouterState[3] === 'inside-shared-layout'\n\n  if (\n    isInsideSharedLayout &&\n    !experimental.isRoutePPREnabled &&\n    // If PPR is disabled, and this is a request for the route tree, then we\n    // never render any components. Only send the router state.\n    (parsedRequestHeaders.isRouteTreePrefetchRequest ||\n      // Otherwise, check for the presence of a `loading` component.\n      (isPrefetch &&\n        !Boolean(modules.loading) &&\n        !hasLoadingComponentInTree(loaderTreeToFilter)))\n  ) {\n    // Send only the router state.\n    // TODO: Even for a dynamic route, we should cache these responses,\n    // because they do not contain any render data (neither segment data nor\n    // the head). They can be made even more cacheable once we move the route\n    // params into a separate data structure.\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = parsedRequestHeaders.isRouteTreePrefetchRequest\n      ? // Route tree prefetch requests contain some extra information\n        createRouteTreePrefetch(loaderTreeToFilter, getDynamicParamFromSegment)\n      : createFlightRouterStateFromLoaderTree(\n          loaderTreeToFilter,\n          getDynamicParamFromSegment,\n          query\n        )\n\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        null,\n        [null, null],\n        true,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  // Similar to the previous branch. This flag is sent by the client to request\n  // only the metadata for a page. No segment data.\n  if (flightRouterState && flightRouterState[3] === 'metadata-only') {\n    const overriddenSegment =\n      flightRouterState &&\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n    const routerState = parsedRequestHeaders.isRouteTreePrefetchRequest\n      ? createRouteTreePrefetch(loaderTreeToFilter, getDynamicParamFromSegment)\n      : createFlightRouterStateFromLoaderTree(\n          loaderTreeToFilter,\n          getDynamicParamFromSegment,\n          query\n        )\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        null,\n        rscHead,\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  if (renderComponentsOnThisLevel) {\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n\n    // Create component tree using the slice of the loaderTree\n    const seedData = await createComponentTree(\n      // This ensures flightRouterPath is valid and filters down the tree\n      {\n        ctx,\n        loaderTree: loaderTreeToFilter,\n        parentParams: currentParams,\n        injectedCSS,\n        injectedJS,\n        injectedFontPreloadTags,\n        // This is intentionally not \"rootLayoutIncludedAtThisLevelOrAbove\" as createComponentTree starts at the current level and does a check for \"rootLayoutAtThisLevel\" too.\n        rootLayoutIncluded,\n        preloadCallbacks,\n        authInterrupts: experimental.authInterrupts,\n        MetadataOutlet,\n      }\n    )\n\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        seedData,\n        rscHead,\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  // If we are not rendering on this level we need to check if the current\n  // segment has a layout. If so, we need to track all the used CSS to make\n  // the result consistent.\n  const layoutPath = layout?.[1]\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n  if (layoutPath) {\n    getLinkAndScriptTags(\n      layoutPath,\n      injectedCSSWithCurrentLayout,\n      injectedJSWithCurrentLayout,\n      true\n    )\n    getPreloadableFonts(\n      nextFontManifest,\n      layoutPath,\n      injectedFontPreloadTagsWithCurrentLayout\n    )\n  }\n\n  const paths: FlightDataPath[] = []\n\n  // Walk through all parallel routes.\n  for (const parallelRouteKey of parallelRoutesKeys) {\n    const parallelRoute = parallelRoutes[parallelRouteKey]\n\n    const subPaths = await walkTreeWithFlightRouterState({\n      ctx,\n      loaderTreeToFilter: parallelRoute,\n      parentParams: currentParams,\n      flightRouterState:\n        flightRouterState && flightRouterState[1][parallelRouteKey],\n      parentIsInsideSharedLayout: isInsideSharedLayout,\n      rscHead,\n      injectedCSS: injectedCSSWithCurrentLayout,\n      injectedJS: injectedJSWithCurrentLayout,\n      injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n      rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n      preloadCallbacks,\n      MetadataOutlet,\n    })\n\n    for (const subPath of subPaths) {\n      paths.push([actualSegment, parallelRouteKey, ...subPath])\n    }\n  }\n\n  return paths\n}\n\n/*\n * This function is used to determine if an existing segment can be overridden\n * by the incoming segment.\n */\nconst canSegmentBeOverridden = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  if (Array.isArray(existingSegment) || !Array.isArray(segment)) {\n    return false\n  }\n\n  return getSegmentParam(existingSegment)?.paramName === segment[0]\n}\n"],"names":["matchSegment","getLinkAndScriptTags","getPreloadableFonts","createFlightRouterStateFromLoaderTree","createRouteTreePrefetch","hasLoadingComponentInTree","addSearchParamsIfPageSegment","createComponentTree","getSegmentParam","walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","flightRouterState","parentIsInsideSharedLayout","rscHead","injectedCSS","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","ctx","preloadCallbacks","MetadataOutlet","renderOpts","nextFontManifest","experimental","query","isPrefetch","getDynamicParamFromSegment","parsedRequestHeaders","segment","parallelRoutes","modules","parallelRoutesKeys","Object","keys","layout","isLayout","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","segmentParam","currentParams","value","param","actualSegment","treeSegment","renderComponentsOnThisLevel","length","isInsideSharedLayout","isRoutePPREnabled","isRouteTreePrefetchRequest","Boolean","loading","overriddenSegment","canSegmentBeOverridden","routerState","seedData","loaderTree","authInterrupts","layoutPath","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","paths","parallelRouteKey","parallelRoute","subPaths","subPath","push","existingSegment","Array","isArray","paramName"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4834, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/encryption-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { getServerActionsManifest } from './manifests-singleton'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifest = getServerActionsManifest()\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n"],"names":["InvariantError","getServerActionsManifest","__next_loaded_action_key","arrayBufferToString","buffer","bytes","Uint8Array","len","byteLength","String","fromCharCode","apply","binary","i","stringToUint8Array","length","arr","charCodeAt","encrypt","key","iv","data","crypto","subtle","name","decrypt","getActionEncryptionKey","serverActionsManifest","rawKey","process","env","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","undefined","importKey","atob"],"mappings":";;;;;;;;;;;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAASC,wBAAwB,QAAQ,wBAAuB;;;AAEhE,IAAIC;AAEG,SAASC,oBACdC,MAAiD;IAEjD,MAAMC,QAAQ,IAAIC,WAAWF;IAC7B,MAAMG,MAAMF,MAAMG,UAAU;IAE5B,6DAA6D;IAC7D,mCAAmC;IACnC,4EAA4E;IAC5E,IAAID,MAAM,OAAO;QACf,OAAOE,OAAOC,YAAY,CAACC,KAAK,CAAC,MAAMN;IACzC;IAEA,IAAIO,SAAS;IACb,IAAK,IAAIC,IAAI,GAAGA,IAAIN,KAAKM,IAAK;QAC5BD,UAAUH,OAAOC,YAAY,CAACL,KAAK,CAACQ,EAAE;IACxC;IACA,OAAOD;AACT;AAEO,SAASE,mBAAmBF,MAAc;IAC/C,MAAML,MAAMK,OAAOG,MAAM;IACzB,MAAMC,MAAM,IAAIV,WAAWC;IAE3B,IAAK,IAAIM,IAAI,GAAGA,IAAIN,KAAKM,IAAK;QAC5BG,GAAG,CAACH,EAAE,GAAGD,OAAOK,UAAU,CAACJ;IAC7B;IAEA,OAAOG;AACT;AAEO,SAASE,QACdC,GAAc,EACdC,EAA2B,EAC3BC,IAA6B;IAE7B,OAAOC,OAAOC,MAAM,CAACL,OAAO,CAC1B;QACEM,MAAM;QACNJ;IACF,GACAD,KACAE;AAEJ;AAEO,SAASI,QACdN,GAAc,EACdC,EAA2B,EAC3BC,IAA6B;IAE7B,OAAOC,OAAOC,MAAM,CAACE,OAAO,CAC1B;QACED,MAAM;QACNJ;IACF,GACAD,KACAE;AAEJ;AAEO,eAAeK;IACpB,IAAIxB,0BAA0B;QAC5B,OAAOA;IACT;IAEA,MAAMyB,4BAAwB1B,2OAAAA;IAE9B,MAAM2B,SACJC,QAAQC,GAAG,CAACC,kCAAkC,IAC9CJ,sBAAsBK,aAAa;IAErC,IAAIJ,WAAWK,WAAW;QACxB,MAAM,OAAA,cAA+D,CAA/D,IAAIjC,mNAAAA,CAAe,8CAAnB,qBAAA;mBAAA;wBAAA;0BAAA;QAA8D;IACtE;IAEAE,2BAA2B,MAAMoB,OAAOC,MAAM,CAACW,SAAS,CACtD,OACApB,mBAAmBqB,KAAKP,UACxB,WACA,MACA;QAAC;QAAW;KAAU;IAGxB,OAAO1B;AACT","ignoreList":[0]}},
    {"offset": {"line": 4909, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/postponed-state.ts"],"sourcesContent":["import type {\n  OpaqueFallbackRouteParamEntries,\n  OpaqueFallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { getDynamicParam } from '../../shared/lib/router/utils/get-dynamic-param'\nimport type { Params } from '../request/params'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport { stringifyResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport enum DynamicState {\n  /**\n   * The dynamic access occurred during the RSC render phase.\n   */\n  DATA = 1,\n\n  /**\n   * The dynamic access occurred during the HTML shell render phase.\n   */\n  HTML = 2,\n}\n\n/**\n * The postponed state for dynamic data.\n */\nexport type DynamicDataPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.DATA\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\n/**\n * The postponed state for dynamic HTML.\n */\nexport type DynamicHTMLPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.HTML\n\n  /**\n   * The postponed data used by React.\n   */\n  readonly data: [\n    preludeState: DynamicHTMLPreludeState,\n    postponed: ReactPostponed,\n  ]\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\nexport const enum DynamicHTMLPreludeState {\n  Empty = 0,\n  Full = 1,\n}\n\ntype ReactPostponed = NonNullable<\n  import('react-dom/static').PrerenderResult['postponed']\n>\n\nexport type PostponedState =\n  | DynamicDataPostponedState\n  | DynamicHTMLPostponedState\n\nexport async function getDynamicHTMLPostponedState(\n  postponed: ReactPostponed,\n  preludeState: DynamicHTMLPreludeState,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  resumeDataCache: PrerenderResumeDataCache | RenderResumeDataCache,\n  isCacheComponentsEnabled: boolean\n): Promise<string> {\n  const data: DynamicHTMLPostponedState['data'] = [preludeState, postponed]\n  const dataString = JSON.stringify(data)\n\n  // If there are no fallback route params, we can just serialize the postponed\n  // state as is.\n  if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n    // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n    return `${dataString.length}:${dataString}${await stringifyResumeDataCache(\n      createRenderResumeDataCache(resumeDataCache),\n      isCacheComponentsEnabled\n    )}`\n  }\n\n  const replacements: OpaqueFallbackRouteParamEntries = Array.from(\n    fallbackRouteParams.entries()\n  )\n  const replacementsString = JSON.stringify(replacements)\n\n  // Serialized as `<replacements.length><replacements><data>`\n  const postponedString = `${replacementsString.length}${replacementsString}${dataString}`\n\n  // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n  return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(resumeDataCache, isCacheComponentsEnabled)}`\n}\n\nexport async function getDynamicDataPostponedState(\n  resumeDataCache: PrerenderResumeDataCache | RenderResumeDataCache,\n  isCacheComponentsEnabled: boolean\n): Promise<string> {\n  return `4:null${await stringifyResumeDataCache(createRenderResumeDataCache(resumeDataCache), isCacheComponentsEnabled)}`\n}\n\nexport function parsePostponedState(\n  state: string,\n  interpolatedParams: Params,\n  maxPostponedStateSizeBytes: number | undefined\n): PostponedState {\n  try {\n    const postponedStringLengthMatch = state.match(/^([0-9]*):/)?.[1]\n    if (!postponedStringLengthMatch) {\n      throw new Error(`Invariant: invalid postponed state ${state}`)\n    }\n\n    const postponedStringLength = parseInt(postponedStringLengthMatch)\n\n    // We add a `:` to the end of the length as the first character of the\n    // postponed string is the length of the replacement entries.\n    const postponedString = state.slice(\n      postponedStringLengthMatch.length + 1,\n      postponedStringLengthMatch.length + postponedStringLength + 1\n    )\n\n    const renderResumeDataCache = createRenderResumeDataCache(\n      state.slice(\n        postponedStringLengthMatch.length + postponedStringLength + 1\n      ),\n      maxPostponedStateSizeBytes\n    )\n\n    try {\n      if (postponedString === 'null') {\n        return { type: DynamicState.DATA, renderResumeDataCache }\n      }\n\n      if (/^[0-9]/.test(postponedString)) {\n        const match = postponedString.match(/^([0-9]*)/)?.[1]\n        if (!match) {\n          throw new Error(\n            `Invariant: invalid postponed state ${JSON.stringify(postponedString)}`\n          )\n        }\n\n        // This is the length of the replacements entries.\n        const length = parseInt(match)\n        const replacements = JSON.parse(\n          postponedString.slice(\n            match.length,\n            // We then go to the end of the string.\n            match.length + length\n          )\n        ) as OpaqueFallbackRouteParamEntries\n\n        let postponed = postponedString.slice(match.length + length)\n        for (const [\n          segmentKey,\n          [searchValue, dynamicParamType],\n        ] of replacements) {\n          const {\n            treeSegment: [\n              ,\n              // This is the same value that'll be used in the postponed state\n              // as it's part of the tree data. That's why we use it as the\n              // replacement value.\n              value,\n            ],\n          } = getDynamicParam(\n            interpolatedParams,\n            segmentKey,\n            dynamicParamType,\n            null\n          )\n\n          postponed = postponed.replaceAll(searchValue, value)\n        }\n\n        return {\n          type: DynamicState.HTML,\n          data: JSON.parse(postponed),\n          renderResumeDataCache,\n        }\n      }\n\n      return {\n        type: DynamicState.HTML,\n        data: JSON.parse(postponedString),\n        renderResumeDataCache,\n      }\n    } catch (err) {\n      console.error('Failed to parse postponed state', err)\n      return { type: DynamicState.DATA, renderResumeDataCache }\n    }\n  } catch (err) {\n    console.error('Failed to parse postponed state', err)\n    return {\n      type: DynamicState.DATA,\n      renderResumeDataCache: createPrerenderResumeDataCache(),\n    }\n  }\n}\n\nexport function getPostponedFromState(state: DynamicHTMLPostponedState) {\n  const [preludeState, postponed] = state.data\n  return { preludeState, postponed }\n}\n"],"names":["getDynamicParam","createPrerenderResumeDataCache","createRenderResumeDataCache","stringifyResumeDataCache","DynamicState","DynamicHTMLPreludeState","getDynamicHTMLPostponedState","postponed","preludeState","fallbackRouteParams","resumeDataCache","isCacheComponentsEnabled","data","dataString","JSON","stringify","size","length","replacements","Array","from","entries","replacementsString","postponedString","getDynamicDataPostponedState","parsePostponedState","state","interpolatedParams","maxPostponedStateSizeBytes","postponedStringLengthMatch","match","Error","postponedStringLength","parseInt","slice","renderResumeDataCache","type","test","parse","segmentKey","searchValue","dynamicParamType","treeSegment","value","replaceAll","err","console","error","getPostponedFromState"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5044, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/use-flight-response.tsx"],"sourcesContent":["import type { BinaryStreamOf } from './app-render'\nimport type { Readable } from 'node:stream'\n\nimport { htmlEscapeJsonString } from '../htmlescape'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { getClientReferenceManifest } from './manifests-singleton'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0\nconst INLINE_FLIGHT_PAYLOAD_DATA = 1\nconst INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2\nconst INLINE_FLIGHT_PAYLOAD_BINARY = 3\n\nconst flightResponses = new WeakMap<\n  Readable | BinaryStreamOf<any>,\n  Promise<any>\n>()\nconst encoder = new TextEncoder()\n\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Render Flight stream.\n * This is only used for renderToHTML, the Flight response does not need additional wrappers.\n */\nexport function getFlightStream<T>(\n  flightStream: Readable | BinaryStreamOf<T>,\n  debugStream: Readable | ReadableStream<Uint8Array> | undefined,\n  debugEndTime: number | undefined,\n  nonce: string | undefined\n): Promise<T> {\n  const response = flightResponses.get(flightStream)\n\n  if (response) {\n    return response\n  }\n\n  const { moduleLoading, edgeSSRModuleMapping, ssrModuleMapping } =\n    getClientReferenceManifest()\n\n  let newResponse: Promise<T>\n  if (flightStream instanceof ReadableStream) {\n    // The types of flightStream and debugStream should match.\n    if (debugStream && !(debugStream instanceof ReadableStream)) {\n      throw new InvariantError('Expected debug stream to be a ReadableStream')\n    }\n\n    // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly\n    const { createFromReadableStream } =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client') as typeof import('react-server-dom-webpack/client')\n\n    newResponse = createFromReadableStream<T>(flightStream, {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        moduleLoading,\n        moduleMap: isEdgeRuntime ? edgeSSRModuleMapping : ssrModuleMapping,\n        serverModuleMap: null,\n      },\n      nonce,\n      debugChannel: debugStream ? { readable: debugStream } : undefined,\n      endTime: debugEndTime,\n    })\n  } else {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      throw new InvariantError(\n        'getFlightStream should always receive a ReadableStream when using the edge runtime'\n      )\n    } else {\n      const { Readable } =\n        require('node:stream') as typeof import('node:stream')\n\n      // The types of flightStream and debugStream should match.\n      if (debugStream && !(debugStream instanceof Readable)) {\n        throw new InvariantError('Expected debug stream to be a Readable')\n      }\n\n      // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly\n      const { createFromNodeStream } =\n        // eslint-disable-next-line import/no-extraneous-dependencies\n        require('react-server-dom-webpack/client') as typeof import('react-server-dom-webpack/client')\n\n      newResponse = createFromNodeStream<T>(\n        flightStream,\n        {\n          moduleLoading,\n          moduleMap: isEdgeRuntime ? edgeSSRModuleMapping : ssrModuleMapping,\n          serverModuleMap: null,\n        },\n        {\n          findSourceMapURL,\n          nonce,\n          debugChannel: debugStream,\n          endTime: debugEndTime,\n        }\n      )\n    }\n  }\n\n  // Edge pages are never prerendered so they necessarily cannot have a workUnitStore type\n  // that requires the nextTick behavior. This is why it is safe to access a node only API here\n  if (process.env.NEXT_RUNTIME !== 'edge') {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    if (!workUnitStore) {\n      throw new InvariantError('Expected workUnitAsyncStorage to have a store.')\n    }\n\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n        const responseOnNextTick = new Promise<T>((resolve) => {\n          process.nextTick(() => {\n            resolve(newResponse)\n          })\n        })\n        flightResponses.set(flightStream, responseOnNextTick)\n        return responseOnNextTick\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  flightResponses.set(flightStream, newResponse)\n\n  return newResponse\n}\n\n/**\n * Creates a ReadableStream provides inline script tag chunks for writing hydration\n * data to the client outside the React render itself.\n *\n * @param flightStream The RSC render stream\n * @param nonce optionally a nonce used during this particular render\n * @param formState optionally the formState used with this particular render\n * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream\n */\nexport function createInlinedDataReadableStream(\n  flightStream: ReadableStream<Uint8Array>,\n  nonce: string | undefined,\n  formState: unknown | null\n): ReadableStream<Uint8Array> {\n  const startScriptTag = nonce\n    ? `<script nonce=${JSON.stringify(nonce)}>`\n    : '<script>'\n\n  const flightReader = flightStream.getReader()\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n\n  const readable = new ReadableStream({\n    type: 'bytes',\n    start(controller) {\n      try {\n        writeInitialInstructions(controller, startScriptTag, formState)\n      } catch (error) {\n        // during encoding or enqueueing forward the error downstream\n        controller.error(error)\n      }\n    },\n    async pull(controller) {\n      try {\n        const { done, value } = await flightReader.read()\n\n        if (value) {\n          try {\n            const decodedString = decoder.decode(value, { stream: !done })\n\n            // The chunk cannot be decoded as valid UTF-8 string as it might\n            // have arbitrary binary data.\n            writeFlightDataInstruction(\n              controller,\n              startScriptTag,\n              decodedString\n            )\n          } catch {\n            // The chunk cannot be decoded as valid UTF-8 string.\n            writeFlightDataInstruction(controller, startScriptTag, value)\n          }\n        }\n\n        if (done) {\n          controller.close()\n        }\n      } catch (error) {\n        // There was a problem in the upstream reader or during decoding or enqueuing\n        // forward the error downstream\n        controller.error(error)\n      }\n    },\n  })\n\n  return readable\n}\n\nfunction writeInitialInstructions(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  formState: unknown | null\n) {\n  let scriptContents = `(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n    JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n  )})`\n\n  if (formState != null) {\n    scriptContents += `;self.__next_f.push(${htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_FORM_STATE, formState])\n    )})`\n  }\n\n  controller.enqueue(encoder.encode(`${scriptStart}${scriptContents}</script>`))\n}\n\nfunction writeFlightDataInstruction(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  chunk: string | Uint8Array\n) {\n  let htmlInlinedData: string\n\n  if (typeof chunk === 'string') {\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_DATA, chunk])\n    )\n  } else {\n    // The chunk cannot be embedded as a UTF-8 string in the script tag.\n    // Instead let's inline it in base64.\n    // Credits to Devon Govett (devongovett) for the technique.\n    // https://github.com/devongovett/rsc-html-stream\n    const base64 = btoa(String.fromCodePoint(...chunk))\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_BINARY, base64])\n    )\n  }\n\n  controller.enqueue(\n    encoder.encode(\n      `${scriptStart}self.__next_f.push(${htmlInlinedData})</script>`\n    )\n  )\n}\n"],"names":["htmlEscapeJsonString","workUnitAsyncStorage","InvariantError","getClientReferenceManifest","isEdgeRuntime","process","env","NEXT_RUNTIME","INLINE_FLIGHT_PAYLOAD_BOOTSTRAP","INLINE_FLIGHT_PAYLOAD_DATA","INLINE_FLIGHT_PAYLOAD_FORM_STATE","INLINE_FLIGHT_PAYLOAD_BINARY","flightResponses","WeakMap","encoder","TextEncoder","findSourceMapURL","NODE_ENV","require","findSourceMapURLDEV","undefined","getFlightStream","flightStream","debugStream","debugEndTime","nonce","response","get","moduleLoading","edgeSSRModuleMapping","ssrModuleMapping","newResponse","ReadableStream","createFromReadableStream","serverConsumerManifest","moduleMap","serverModuleMap","debugChannel","readable","endTime","Readable","createFromNodeStream","workUnitStore","getStore","type","responseOnNextTick","Promise","resolve","nextTick","set","createInlinedDataReadableStream","formState","startScriptTag","JSON","stringify","flightReader","getReader","decoder","TextDecoder","fatal","start","controller","writeInitialInstructions","error","pull","done","value","read","decodedString","decode","stream","writeFlightDataInstruction","close","scriptStart","scriptContents","enqueue","encode","chunk","htmlInlinedData","base64","btoa","String","fromCodePoint"],"mappings":";;;;;;AAGA,SAASA,oBAAoB,QAAQ,gBAAe;AACpD,SAASC,oBAAoB,QAAQ,qCAAoC;AACzE,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,0BAA0B,QAAQ,wBAAuB;;;;;AAElE,MAAMC,gBAAgBC,QAAQC,GAAG,CAACC,YAAY,qBAAK;AAEnD,MAAMC,kCAAkC;AACxC,MAAMC,6BAA6B;AACnC,MAAMC,mCAAmC;AACzC,MAAMC,+BAA+B;AAErC,MAAMC,kBAAkB,IAAIC;AAI5B,MAAMC,UAAU,IAAIC;AAEpB,MAAMC,mBACJX,QAAQC,GAAG,CAACW,QAAQ,KAAK,cACpBC,QAAQ,uHACNC,mBAAmB,GACtBC;AAMC,SAASC,gBACdC,YAA0C,EAC1CC,WAA8D,EAC9DC,YAAgC,EAChCC,KAAyB;IAEzB,MAAMC,WAAWd,gBAAgBe,GAAG,CAACL;IAErC,IAAII,UAAU;QACZ,OAAOA;IACT;IAEA,MAAM,EAAEE,aAAa,EAAEC,oBAAoB,EAAEC,gBAAgB,EAAE,OAC7D3B,6OAAAA;IAEF,IAAI4B;IACJ,IAAIT,wBAAwBU,gBAAgB;QAC1C,0DAA0D;QAC1D,IAAIT,eAAe,CAAEA,CAAAA,uBAAuBS,cAAa,GAAI;YAC3D,MAAM,OAAA,cAAkE,CAAlE,IAAI9B,mNAAAA,CAAe,iDAAnB,qBAAA;uBAAA;4BAAA;8BAAA;YAAiE;QACzE;QAEA,wGAAwG;QACxG,MAAM,EAAE+B,wBAAwB,EAAE,GAChC,6DAA6D;QAG/DF,cAAcE,yBAA4BX,cAAc;YACtDN;YACAkB,wBAAwB;gBACtBN;gBACAO,WAAW/B,uCAAgByB,uBAAuBC;gBAClDM,iBAAiB;YACnB;YACAX;YACAY,cAAcd,cAAc;gBAAEe,UAAUf;YAAY,IAAIH;YACxDmB,SAASf;QACX;IACF,OAAO;QACL,IAAInB,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;YACvC,MAAM,OAAA,cAEL,CAFK,IAAIL,mNAAAA,CACR,uFADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF,OAAO;;IA6BT;IAEA,wFAAwF;IACxF,6FAA6F;IAC7F,IAAIG,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;IA8BzCK,gBAAgBqC,GAAG,CAAC3B,cAAcS;IAElC,OAAOA;AACT;AAWO,SAASmB,gCACd5B,YAAwC,EACxCG,KAAyB,EACzB0B,SAAyB;IAEzB,MAAMC,iBAAiB3B,QACnB,CAAC,cAAc,EAAE4B,KAAKC,SAAS,CAAC7B,OAAO,CAAC,CAAC,GACzC;IAEJ,MAAM8B,eAAejC,aAAakC,SAAS;IAC3C,MAAMC,UAAU,IAAIC,YAAY,SAAS;QAAEC,OAAO;IAAK;IAEvD,MAAMrB,WAAW,IAAIN,eAAe;QAClCY,MAAM;QACNgB,OAAMC,UAAU;YACd,IAAI;gBACFC,yBAAyBD,YAAYT,gBAAgBD;YACvD,EAAE,OAAOY,OAAO;gBACd,6DAA6D;gBAC7DF,WAAWE,KAAK,CAACA;YACnB;QACF;QACA,MAAMC,MAAKH,UAAU;YACnB,IAAI;gBACF,MAAM,EAAEI,IAAI,EAAEC,KAAK,EAAE,GAAG,MAAMX,aAAaY,IAAI;gBAE/C,IAAID,OAAO;oBACT,IAAI;wBACF,MAAME,gBAAgBX,QAAQY,MAAM,CAACH,OAAO;4BAAEI,QAAQ,CAACL;wBAAK;wBAE5D,gEAAgE;wBAChE,8BAA8B;wBAC9BM,2BACEV,YACAT,gBACAgB;oBAEJ,EAAE,OAAM;wBACN,qDAAqD;wBACrDG,2BAA2BV,YAAYT,gBAAgBc;oBACzD;gBACF;gBAEA,IAAID,MAAM;oBACRJ,WAAWW,KAAK;gBAClB;YACF,EAAE,OAAOT,OAAO;gBACd,6EAA6E;gBAC7E,+BAA+B;gBAC/BF,WAAWE,KAAK,CAACA;YACnB;QACF;IACF;IAEA,OAAOzB;AACT;AAEA,SAASwB,yBACPD,UAA2C,EAC3CY,WAAmB,EACnBtB,SAAyB;IAEzB,IAAIuB,iBAAiB,CAAC,uCAAuC,MAAE1E,0MAAAA,EAC7DqD,KAAKC,SAAS,CAAC;QAAC9C;KAAgC,GAChD,CAAC,CAAC;IAEJ,IAAI2C,aAAa,MAAM;QACrBuB,kBAAkB,CAAC,oBAAoB,MAAE1E,0MAAAA,EACvCqD,KAAKC,SAAS,CAAC;YAAC5C;YAAkCyC;SAAU,GAC5D,CAAC,CAAC;IACN;IAEAU,WAAWc,OAAO,CAAC7D,QAAQ8D,MAAM,CAAC,GAAGH,cAAcC,eAAe,SAAS,CAAC;AAC9E;AAEA,SAASH,2BACPV,UAA2C,EAC3CY,WAAmB,EACnBI,KAA0B;IAE1B,IAAIC;IAEJ,IAAI,OAAOD,UAAU,UAAU;QAC7BC,sBAAkB9E,0MAAAA,EAChBqD,KAAKC,SAAS,CAAC;YAAC7C;YAA4BoE;SAAM;IAEtD,OAAO;QACL,oEAAoE;QACpE,qCAAqC;QACrC,2DAA2D;QAC3D,iDAAiD;QACjD,MAAME,SAASC,KAAKC,OAAOC,aAAa,IAAIL;QAC5CC,sBAAkB9E,0MAAAA,EAChBqD,KAAKC,SAAS,CAAC;YAAC3C;YAA8BoE;SAAO;IAEzD;IAEAlB,WAAWc,OAAO,CAChB7D,QAAQ8D,MAAM,CACZ,GAAGH,YAAY,mBAAmB,EAAEK,gBAAgB,UAAU,CAAC;AAGrE","ignoreList":[0]}},
    {"offset": {"line": 5234, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/app-render-scheduling.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { unpatchedSetImmediate } from '../node-environment-extensions/fast-set-immediate.external'\n\n/*\n==========================\n| Background             |\n==========================\n\nNode.js does not guarantee that two timers scheduled back to back will run\non the same iteration of the event loop:\n\n```ts\nsetTimeout(one, 0)\nsetTimeout(two, 0)\n```\n\nInternally, each timer is assigned a `_idleStart` property that holds\nan internal libuv timestamp in millisecond resolution.\nThis will be used to determine if the timer is already \"expired\" and should be executed.\nHowever, even in sync code, it's possible for two timers to get different `_idleStart` values.\nThis can cause one of the timers to be executed, and the other to be delayed until the next timer phase.\n\nThe delaying happens [here](https://github.com/nodejs/node/blob/c208ffc66bb9418ff026c4e3fa82e5b4387bd147/lib/internal/timers.js#L556-L564).\nand can be debugged by running node with `NODE_DEBUG=timer`.\n\nThe easiest way to observe it is to run this program in a loop until it exits with status 1:\n\n```\n// test.js\n\nlet immediateRan = false\nconst t1 = setTimeout(() => {\n  console.log('timeout 1')\n  setImmediate(() => {\n    console.log('immediate 1')\n    immediateRan = true\n  })\n})\n\nconst t2 = setTimeout(() => {\n  console.log('timeout 2')\n  if (immediateRan) {\n    console.log('immediate ran before the second timeout!')\n    console.log(\n      `t1._idleStart: ${t1._idleStart}, t2_idleStart: ${t2._idleStart}`\n    );\n    process.exit(1)\n  }\n})\n```\n\n```bash\n#!/usr/bin/env bash\n\ni=1;\nwhile true; do\n  output=\"$(NODE_DEBUG=timer node test.js 2>&1)\";\n  if [ \"$?\" -eq 1 ]; then\n    echo \"failed after $i iterations\";\n    echo \"$output\";\n    break;\n  fi;\n  i=$((i+1));\ndone\n```\n\nIf `t2` is deferred to the next iteration of the event loop,\nthen the immediate scheduled from inside `t1` will run first.\nWhen this occurs, `_idleStart` is reliably different between `t1` and `t2`.\n\n==========================\n| Solution               |\n==========================\n\nWe can guarantee that multiple timers (with the same delay, usually `0`)\nrun together without any delays by making sure that their `_idleStart`s are the same,\nbecause that's what's used to determine if a timer should be deferred or not.\nLuckily, this property is currently exposed to userland and mutable,\nso we can patch it.\n\nAnother related trick we could potentially apply is making\na timer immediately be considered expired by doing  `timer._idleStart -= 2`.\n(the value must be more than `1`, the delay that actually gets set for `setTimeout(cb, 0)`).\nThis makes node view this timer as \"a 1ms timer scheduled 2ms ago\",\nmeaning that it should definitely run in the next timer phase.\nHowever, I'm not confident we know all the side effects of doing this,\nso for now, simply ensuring coordination is enough.\n*/\n\nlet shouldAttemptPatching = true\n\nfunction warnAboutTimers() {\n  console.warn(\n    \"Next.js cannot guarantee that Cache Components will run as expected due to the current runtime's implementation of `setTimeout()`.\\nPlease report a github issue here: https://github.com/vercel/next.js/issues/new/\"\n  )\n}\n\n/**\n * Allows scheduling multiple timers (equivalent to `setTimeout(cb, delayMs)`)\n * that are guaranteed to run in the same iteration of the event loop.\n *\n * @param delayMs - the delay to pass to `setTimeout`. (default: 0)\n *\n * */\nexport function createAtomicTimerGroup(delayMs = 0) {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'createAtomicTimerGroup cannot be called in the edge runtime'\n    )\n  } else {\n    let isFirstCallback = true\n    let firstTimerIdleStart: number | null = null\n    let didFirstTimerRun = false\n\n    // As a sanity check, we schedule an immediate from the first timeout\n    // to check if the execution was interrupted (i.e. if it ran between the timeouts).\n    // Note that we're deliberately bypassing the \"fast setImmediate\" patch here --\n    // otherwise, this check would always fail, because the immediate\n    // would always run before the second timeout.\n    let didImmediateRun = false\n    function runFirstCallback(callback: () => void) {\n      didFirstTimerRun = true\n      if (shouldAttemptPatching) {\n        unpatchedSetImmediate(() => {\n          didImmediateRun = true\n        })\n      }\n      return callback()\n    }\n\n    function runSubsequentCallback(callback: () => void) {\n      if (shouldAttemptPatching) {\n        if (didImmediateRun) {\n          // If the immediate managed to run between the timers, then we're not\n          // able to provide the guarantees that we're supposed to\n          shouldAttemptPatching = false\n          warnAboutTimers()\n        }\n      }\n      return callback()\n    }\n\n    return function scheduleTimeout(callback: () => void) {\n      if (didFirstTimerRun) {\n        throw new InvariantError(\n          'Cannot schedule more timers into a group that already executed'\n        )\n      }\n\n      const timer = setTimeout(\n        isFirstCallback ? runFirstCallback : runSubsequentCallback,\n        delayMs,\n        callback\n      )\n      isFirstCallback = false\n\n      if (!shouldAttemptPatching) {\n        // We already tried patching some timers, and it didn't work.\n        // No point trying again.\n        return timer\n      }\n\n      // NodeJS timers have a `_idleStart` property, but it doesn't exist e.g. in Bun.\n      // If it's not present, we'll warn and try to continue.\n      try {\n        if ('_idleStart' in timer && typeof timer._idleStart === 'number') {\n          // If this is the first timer that was scheduled, save its `_idleStart`.\n          // We'll copy it onto subsequent timers to guarantee that they'll all be\n          // considered expired in the same iteration of the event loop\n          // and thus will all be executed in the same timer phase.\n          if (firstTimerIdleStart === null) {\n            firstTimerIdleStart = timer._idleStart\n          } else {\n            timer._idleStart = firstTimerIdleStart\n          }\n        } else {\n          shouldAttemptPatching = false\n          warnAboutTimers()\n        }\n      } catch (err) {\n        // This should never fail in current Node, but it might start failing in the future.\n        // We might be okay even without tweaking the timers, so warn and try to continue.\n        console.error(\n          new InvariantError(\n            'An unexpected error occurred while adjusting `_idleStart` on an atomic timer',\n            { cause: err }\n          )\n        )\n        shouldAttemptPatching = false\n        warnAboutTimers()\n      }\n\n      return timer\n    }\n  }\n}\n"],"names":["InvariantError","unpatchedSetImmediate","shouldAttemptPatching","warnAboutTimers","console","warn","createAtomicTimerGroup","delayMs","process","env","NEXT_RUNTIME","isFirstCallback","firstTimerIdleStart","didFirstTimerRun","didImmediateRun","runFirstCallback","callback","runSubsequentCallback","scheduleTimeout","timer","setTimeout","_idleStart","err","error","cause"],"mappings":";;;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAASC,qBAAqB,QAAQ,6DAA4D;;;AAElG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoFA,GAEA,IAAIC,wBAAwB;AAE5B,SAASC;IACPC,QAAQC,IAAI,CACV;AAEJ;AASO,SAASC,uBAAuBC,UAAU,CAAC;IAChD,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIV,mNAAAA,CACR,gEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;QAWL,SAASe,iBAAiBC,QAAoB;YAC5CH,mBAAmB;YACnB,IAAIX,uBAAuB;oBACzBD,0QAAAA,EAAsB;oBACpBa,kBAAkB;gBACpB;YACF;YACA,OAAOE;QACT;QAEA,SAASC,sBAAsBD,QAAoB;YACjD,IAAId,uBAAuB;gBACzB,IAAIY,iBAAiB;oBACnB,qEAAqE;oBACrE,wDAAwD;oBACxDZ,wBAAwB;oBACxBC;gBACF;YACF;YACA,OAAOa;QACT;;AAuDJ","ignoreList":[0]}},
    {"offset": {"line": 5365, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/app-render-prerender-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createAtomicTimerGroup } from './app-render-scheduling'\nimport {\n  DANGEROUSLY_runPendingImmediatesAfterCurrentTask,\n  expectNoPendingImmediates,\n} from '../node-environment-extensions/fast-set-immediate.external'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setTimeout) at the same time to ensure no other events can sneak in between.\n */\nexport function prerenderAndAbortInSequentialTasks<R>(\n  prerender: () => Promise<R>,\n  abort: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      const scheduleTimeout = createAtomicTimerGroup()\n\n      let pendingResult: Promise<R>\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          pendingResult = prerender()\n          pendingResult.catch(() => {})\n        } catch (err) {\n          reject(err)\n        }\n      })\n      scheduleTimeout(() => {\n        try {\n          expectNoPendingImmediates()\n          abort()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      })\n    })\n  }\n}\n\n/**\n * Like `prerenderAndAbortInSequentialTasks`, but with another task between `prerender` and `abort`,\n * which allows us to move a part of the render into a separate task.\n */\nexport function prerenderAndAbortInSequentialTasksWithStages<R>(\n  prerender: () => Promise<R>,\n  advanceStage: () => void,\n  abort: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasksWithStages` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      const scheduleTimeout = createAtomicTimerGroup()\n\n      let pendingResult: Promise<R>\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          pendingResult = prerender()\n          pendingResult.catch(() => {})\n        } catch (err) {\n          reject(err)\n        }\n      })\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          advanceStage()\n        } catch (err) {\n          reject(err)\n        }\n      })\n      scheduleTimeout(() => {\n        try {\n          expectNoPendingImmediates()\n          abort()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      })\n    })\n  }\n}\n\n// React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection\n// closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)\n// has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream\n// in one that doesn't close even when the underlying is complete.\nexport class ReactServerResult {\n  private _stream: null | ReadableStream<Uint8Array>\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this._stream = stream\n  }\n\n  tee() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot tee a ReactServerResult that has already been consumed'\n      )\n    }\n    const tee = this._stream.tee()\n    this._stream = tee[0]\n    return tee[1]\n  }\n\n  consume() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot consume a ReactServerResult that has already been consumed'\n      )\n    }\n    const stream = this._stream\n    this._stream = null\n    return stream\n  }\n}\n\nexport type ReactServerPrerenderResolveToType = {\n  prelude: ReadableStream<Uint8Array>\n}\n\nexport async function createReactServerPrerenderResult(\n  underlying: Promise<ReactServerPrerenderResolveToType>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const { prelude } = await underlying\n  const reader = prelude.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      return new ReactServerPrerenderResult(chunks)\n    } else {\n      chunks.push(value)\n    }\n  }\n}\n\nexport async function createReactServerPrerenderResultFromRender(\n  underlying: ReadableStream<Uint8Array>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const reader = underlying.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    } else {\n      chunks.push(value)\n    }\n  }\n  return new ReactServerPrerenderResult(chunks)\n}\nexport class ReactServerPrerenderResult {\n  private _chunks: null | Array<Uint8Array>\n\n  private assertChunks(expression: string): Array<Uint8Array> {\n    if (this._chunks === null) {\n      throw new InvariantError(\n        `Cannot \\`${expression}\\` on a ReactServerPrerenderResult that has already been consumed.`\n      )\n    }\n    return this._chunks\n  }\n\n  private consumeChunks(expression: string): Array<Uint8Array> {\n    const chunks = this.assertChunks(expression)\n    this.consume()\n    return chunks\n  }\n\n  consume(): void {\n    this._chunks = null\n  }\n\n  constructor(chunks: Array<Uint8Array>) {\n    this._chunks = chunks\n  }\n\n  asUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  consumeAsUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  asStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asStream()')\n    return createClosingStream(chunks)\n  }\n\n  consumeAsStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsStream()')\n    return createClosingStream(chunks)\n  }\n}\n\nfunction createUnclosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      }\n      // we intentionally keep the stream open. The consumer will clear\n      // out chunks once finished and the remaining memory will be GC'd\n      // when this object goes out of scope\n    },\n  })\n}\n\nfunction createClosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      } else {\n        controller.close()\n      }\n    },\n  })\n}\n\nexport async function processPrelude(\n  unprocessedPrelude: ReadableStream<Uint8Array>\n) {\n  const [prelude, peek] = unprocessedPrelude.tee()\n\n  const reader = peek.getReader()\n  const firstResult = await reader.read()\n  reader.cancel()\n\n  const preludeIsEmpty = firstResult.done === true\n\n  return { prelude, preludeIsEmpty }\n}\n"],"names":["InvariantError","createAtomicTimerGroup","DANGEROUSLY_runPendingImmediatesAfterCurrentTask","expectNoPendingImmediates","prerenderAndAbortInSequentialTasks","prerender","abort","process","env","NEXT_RUNTIME","Promise","resolve","reject","scheduleTimeout","pendingResult","catch","err","prerenderAndAbortInSequentialTasksWithStages","advanceStage","ReactServerResult","constructor","stream","_stream","tee","Error","consume","createReactServerPrerenderResult","underlying","chunks","prelude","reader","getReader","done","value","read","ReactServerPrerenderResult","push","createReactServerPrerenderResultFromRender","assertChunks","expression","_chunks","consumeChunks","asUnclosingStream","createUnclosingStream","consumeAsUnclosingStream","asStream","createClosingStream","consumeAsStream","i","ReadableStream","pull","controller","length","enqueue","close","processPrelude","unprocessedPrelude","peek","firstResult","cancel","preludeIsEmpty"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5541, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/prospective-render-utils.ts"],"sourcesContent":["import { getDigestForWellKnownError } from './create-error-handler'\nimport { isReactLargeShellError } from './react-large-shell-error'\n\nexport enum Phase {\n  ProspectiveRender = 'the prospective render',\n  SegmentCollection = 'segment collection',\n}\n\nexport function printDebugThrownValueForProspectiveRender(\n  thrownValue: unknown,\n  route: string,\n  phase: Phase\n) {\n  // We don't need to print well-known Next.js errors.\n  if (getDigestForWellKnownError(thrownValue)) {\n    return\n  }\n\n  if (isReactLargeShellError(thrownValue)) {\n    // TODO: Aggregate\n    console.error(thrownValue)\n    return undefined\n  }\n\n  let message: undefined | string\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    typeof (thrownValue as any).message === 'string'\n  ) {\n    message = (thrownValue as any).message\n    if (typeof (thrownValue as any).stack === 'string') {\n      const originalErrorStack: string = (thrownValue as any).stack\n      const stackStart = originalErrorStack.indexOf('\\n')\n      if (stackStart > -1) {\n        const error = new Error(\n          `Route ${route} errored during ${phase}. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled.\n          \nOriginal Error: ${message}`\n        )\n        error.stack =\n          'Error: ' + error.message + originalErrorStack.slice(stackStart)\n        console.error(error)\n        return\n      }\n    }\n  } else if (typeof thrownValue === 'string') {\n    message = thrownValue\n  }\n\n  if (message) {\n    console.error(`Route ${route} errored during ${phase}. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. No stack was provided.\n          \nOriginal Message: ${message}`)\n    return\n  }\n\n  console.error(\n    `Route ${route} errored during ${phase}. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. The thrown value is logged just following this message`\n  )\n  console.error(thrownValue)\n  return\n}\n"],"names":["getDigestForWellKnownError","isReactLargeShellError","Phase","printDebugThrownValueForProspectiveRender","thrownValue","route","phase","console","error","undefined","message","stack","originalErrorStack","stackStart","indexOf","Error","slice"],"mappings":";;;;;;AAAA,SAASA,0BAA0B,QAAQ,yBAAwB;AACnE,SAASC,sBAAsB,QAAQ,4BAA2B;;;AAE3D,IAAKC,QAAAA,WAAAA,GAAAA,SAAAA,KAAAA;;;WAAAA;MAGX;AAEM,SAASC,0CACdC,WAAoB,EACpBC,KAAa,EACbC,KAAY;IAEZ,oDAAoD;IACpD,QAAIN,iPAAAA,EAA2BI,cAAc;QAC3C;IACF;IAEA,QAAIH,mPAAAA,EAAuBG,cAAc;QACvC,kBAAkB;QAClBG,QAAQC,KAAK,CAACJ;QACd,OAAOK;IACT;IAEA,IAAIC;IACJ,IACE,OAAON,gBAAgB,YACvBA,gBAAgB,QAChB,OAAQA,YAAoBM,OAAO,KAAK,UACxC;QACAA,UAAWN,YAAoBM,OAAO;QACtC,IAAI,OAAQN,YAAoBO,KAAK,KAAK,UAAU;YAClD,MAAMC,qBAA8BR,YAAoBO,KAAK;YAC7D,MAAME,aAAaD,mBAAmBE,OAAO,CAAC;YAC9C,IAAID,aAAa,CAAC,GAAG;gBACnB,MAAML,QAAQ,OAAA,cAIb,CAJa,IAAIO,MAChB,CAAC,MAAM,EAAEV,MAAM,gBAAgB,EAAEC,MAAM;;gBAEjC,EAAEI,SAAS,GAHL,qBAAA;2BAAA;gCAAA;kCAAA;gBAId;gBACAF,MAAMG,KAAK,GACT,YAAYH,MAAME,OAAO,GAAGE,mBAAmBI,KAAK,CAACH;gBACvDN,QAAQC,KAAK,CAACA;gBACd;YACF;QACF;IACF,OAAO,IAAI,OAAOJ,gBAAgB,UAAU;QAC1CM,UAAUN;IACZ;IAEA,IAAIM,SAAS;QACXH,QAAQC,KAAK,CAAC,CAAC,MAAM,EAAEH,MAAM,gBAAgB,EAAEC,MAAM;;kBAEvC,EAAEI,SAAS;QACzB;IACF;IAEAH,QAAQC,KAAK,CACX,CAAC,MAAM,EAAEH,MAAM,gBAAgB,EAAEC,MAAM,kMAAkM,CAAC;IAE5OC,QAAQC,KAAK,CAACJ;IACd;AACF","ignoreList":[0]}},
    {"offset": {"line": 5602, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/app-render-render-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createAtomicTimerGroup } from './app-render-scheduling'\nimport {\n  DANGEROUSLY_runPendingImmediatesAfterCurrentTask,\n  expectNoPendingImmediates,\n} from '../node-environment-extensions/fast-set-immediate.external'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setTimeout) at the same time to ensure no other events can sneak in between.\n */\nexport function scheduleInSequentialTasks<R>(\n  render: () => R | Promise<R>,\n  followup: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`scheduleInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      const scheduleTimeout = createAtomicTimerGroup()\n\n      let pendingResult: R | Promise<R>\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          pendingResult = render()\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      scheduleTimeout(() => {\n        try {\n          expectNoPendingImmediates()\n          followup()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      })\n    })\n  }\n}\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setTimeout) at the same time to ensure no other events can sneak in between.\n * The function that runs in the second task gets access to the first tasks's result.\n */\nexport function pipelineInSequentialTasks<A, B, C>(\n  one: () => A,\n  two: (a: A) => B,\n  three: (b: B) => C\n): Promise<C> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`pipelineInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      const scheduleTimeout = createAtomicTimerGroup()\n\n      let oneResult: A\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          oneResult = one()\n        } catch (err) {\n          clearTimeout(twoId)\n          clearTimeout(threeId)\n          clearTimeout(fourId)\n          reject(err)\n        }\n      })\n\n      let twoResult: B\n      const twoId = scheduleTimeout(() => {\n        // if `one` threw, then this timeout would've been cleared,\n        // so if we got here, we're guaranteed to have a value.\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          twoResult = two(oneResult!)\n        } catch (err) {\n          clearTimeout(threeId)\n          clearTimeout(fourId)\n          reject(err)\n        }\n      })\n\n      let threeResult: C\n      const threeId = scheduleTimeout(() => {\n        // if `two` threw, then this timeout would've been cleared,\n        // so if we got here, we're guaranteed to have a value.\n        try {\n          expectNoPendingImmediates()\n          threeResult = three(twoResult!)\n        } catch (err) {\n          clearTimeout(fourId)\n          reject(err)\n        }\n      })\n\n      // We wait a task before resolving/rejecting\n      const fourId = scheduleTimeout(() => {\n        resolve(threeResult)\n      })\n    })\n  }\n}\n"],"names":["InvariantError","createAtomicTimerGroup","DANGEROUSLY_runPendingImmediatesAfterCurrentTask","expectNoPendingImmediates","scheduleInSequentialTasks","render","followup","process","env","NEXT_RUNTIME","Promise","resolve","reject","scheduleTimeout","pendingResult","err","pipelineInSequentialTasks","one","two","three","oneResult","clearTimeout","twoId","threeId","fourId","twoResult","threeResult"],"mappings":";;;;;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAASC,sBAAsB,QAAQ,0BAAyB;AAChE,SACEC,gDAAgD,EAChDC,yBAAyB,QACpB,6DAA4D;;;;AAM5D,SAASC,0BACdC,MAA4B,EAC5BC,QAAoB;IAEpB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIT,mNAAAA,CACR,sEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;AAyBT;AAOO,SAASgB,0BACdC,GAAY,EACZC,GAAgB,EAChBC,KAAkB;IAElB,IAAIZ,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIT,mNAAAA,CACR,sEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;AAkDT","ignoreList":[0]}},
    {"offset": {"line": 5638, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/console-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { ConsoleAsyncStorage } from './console-async-storage.external'\n\nexport const consoleAsyncStorageInstance: ConsoleAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","consoleAsyncStorageInstance"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAGxD,MAAMC,kCACXD,gPAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 5649, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/console-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { consoleAsyncStorageInstance } from './console-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport interface ConsoleStore {\n  /**\n   * if true the color of logs output will be dimmed to indicate the log is\n   * from a repeat or validation render that is not typically relevant to\n   * the primary action the server is taking.\n   */\n  readonly dim: boolean\n}\n\nexport type ConsoleAsyncStorage = AsyncLocalStorage<ConsoleStore>\n\nexport { consoleAsyncStorageInstance as consoleAsyncStorage }\n"],"names":["consoleAsyncStorageInstance","consoleAsyncStorage"],"mappings":";AAEA,qDAAqD;AACrD,SAASA,2BAA2B,QAAQ,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 5668, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/cache-signal.ts"],"sourcesContent":["/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the cacheComponents flag is on\n * and should only be used in codepaths gated with this feature.\n */\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport class CacheSignal {\n  private count = 0\n  private earlyListeners: Array<() => void> = []\n  private listeners: Array<() => void> = []\n  private tickPending = false\n  private pendingTimeoutCleanup: (() => void) | null = null\n\n  private subscribedSignals: Set<CacheSignal> | null = null\n\n  constructor() {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      // we rely on `process.nextTick`, which is not supported in edge\n      throw new InvariantError(\n        'CacheSignal cannot be used in the edge runtime, because `cacheComponents` does not support it.'\n      )\n    }\n  }\n\n  private noMorePendingCaches() {\n    if (!this.tickPending) {\n      this.tickPending = true\n      queueMicrotask(() =>\n        process.nextTick(() => {\n          this.tickPending = false\n          if (this.count === 0) {\n            for (let i = 0; i < this.earlyListeners.length; i++) {\n              this.earlyListeners[i]()\n            }\n            this.earlyListeners.length = 0\n          }\n        })\n      )\n    }\n\n    // After a cache resolves, React will schedule new rendering work:\n    // - in a microtask (when prerendering)\n    // - in setImmediate (when rendering)\n    // To cover both of these, we have to make sure that we let immediates execute at least once after each cache resolved.\n    // We don't know when the pending timeout was scheduled (and if it's about to resolve),\n    // so by scheduling a new one, we can be sure that we'll go around the event loop at least once.\n    if (this.pendingTimeoutCleanup) {\n      // We cancel the timeout in beginRead, so this shouldn't ever be active here,\n      // but we still cancel it defensively.\n      this.pendingTimeoutCleanup()\n    }\n    this.pendingTimeoutCleanup = scheduleImmediateAndTimeoutWithCleanup(\n      this.invokeListenersIfNoPendingReads\n    )\n  }\n\n  private invokeListenersIfNoPendingReads = () => {\n    this.pendingTimeoutCleanup = null\n    if (this.count === 0) {\n      for (let i = 0; i < this.listeners.length; i++) {\n        this.listeners[i]()\n      }\n      this.listeners.length = 0\n    }\n  }\n\n  /**\n   * This promise waits until there are no more in progress cache reads but no later.\n   * This allows for adding more cache reads after to delay cacheReady.\n   */\n  inputReady() {\n    return new Promise<void>((resolve) => {\n      this.earlyListeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */\n  cacheReady() {\n    return new Promise<void>((resolve) => {\n      this.listeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  beginRead() {\n    this.count++\n\n    // There's a new pending cache, so if there's a `noMorePendingCaches` timeout running,\n    // we should cancel it.\n    if (this.pendingTimeoutCleanup) {\n      this.pendingTimeoutCleanup()\n      this.pendingTimeoutCleanup = null\n    }\n\n    if (this.subscribedSignals !== null) {\n      for (const subscriber of this.subscribedSignals) {\n        subscriber.beginRead()\n      }\n    }\n  }\n\n  endRead() {\n    if (this.count === 0) {\n      throw new InvariantError(\n        'CacheSignal got more endRead() calls than beginRead() calls'\n      )\n    }\n\n    // If this is the last read we need to wait a task before we can claim the cache is settled.\n    // The cache read will likely ping a Server Component which can read from the cache again and this\n    // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n    // after at least one task.\n    // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n    // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n    this.count--\n    if (this.count === 0) {\n      this.noMorePendingCaches()\n    }\n\n    if (this.subscribedSignals !== null) {\n      for (const subscriber of this.subscribedSignals) {\n        subscriber.endRead()\n      }\n    }\n  }\n\n  hasPendingReads(): boolean {\n    return this.count > 0\n  }\n\n  trackRead<T>(promise: Promise<T>) {\n    this.beginRead()\n    // `promise.finally()` still rejects, so don't use it here to avoid unhandled rejections\n    const onFinally = this.endRead.bind(this)\n    promise.then(onFinally, onFinally)\n    return promise\n  }\n\n  subscribeToReads(subscriber: CacheSignal): () => void {\n    if (subscriber === this) {\n      throw new InvariantError('A CacheSignal cannot subscribe to itself')\n    }\n    if (this.subscribedSignals === null) {\n      this.subscribedSignals = new Set()\n    }\n    this.subscribedSignals.add(subscriber)\n\n    // we'll notify the subscriber of each endRead() on this signal,\n    // so we need to give it a corresponding beginRead() for each read we have in flight now.\n    for (let i = 0; i < this.count; i++) {\n      subscriber.beginRead()\n    }\n\n    return this.unsubscribeFromReads.bind(this, subscriber)\n  }\n\n  unsubscribeFromReads(subscriber: CacheSignal) {\n    if (!this.subscribedSignals) {\n      return\n    }\n    this.subscribedSignals.delete(subscriber)\n\n    // we don't need to set the set back to `null` if it's empty --\n    // if other signals are subscribing to this one, it'll likely get more subscriptions later,\n    // so we'd have to allocate a fresh set again when that happens.\n  }\n}\n\nfunction scheduleImmediateAndTimeoutWithCleanup(cb: () => void): () => void {\n  // If we decide to clean up the timeout, we want to remove\n  // either the immediate or the timeout, whichever is still pending.\n  let clearPending: () => void\n\n  const immediate = setImmediate(() => {\n    const timeout = setTimeout(cb, 0)\n    clearPending = clearTimeout.bind(null, timeout)\n  })\n  clearPending = clearImmediate.bind(null, immediate)\n\n  return () => clearPending()\n}\n"],"names":["InvariantError","CacheSignal","constructor","count","earlyListeners","listeners","tickPending","pendingTimeoutCleanup","subscribedSignals","invokeListenersIfNoPendingReads","i","length","process","env","NEXT_RUNTIME","noMorePendingCaches","queueMicrotask","nextTick","scheduleImmediateAndTimeoutWithCleanup","inputReady","Promise","resolve","push","cacheReady","beginRead","subscriber","endRead","hasPendingReads","trackRead","promise","onFinally","bind","then","subscribeToReads","Set","add","unsubscribeFromReads","delete","cb","clearPending","immediate","setImmediate","timeout","setTimeout","clearTimeout","clearImmediate"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5846, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/metadata-insertion/create-server-inserted-metadata.tsx"],"sourcesContent":["/**\n * For chromium based browsers (Chrome, Edge, etc.) and Safari,\n * icons need to stay under <head> to be picked up by the browser.\n *\n */\nconst REINSERT_ICON_SCRIPT = `\\\ndocument.querySelectorAll('body link[rel=\"icon\"], body link[rel=\"apple-touch-icon\"]').forEach(el => document.head.appendChild(el))`\n\nexport function createServerInsertedMetadata(nonce: string | undefined) {\n  let inserted = false\n\n  return async function getServerInsertedMetadata(): Promise<string> {\n    if (inserted) {\n      return ''\n    }\n\n    inserted = true\n    return `<script ${nonce ? `nonce=\"${nonce}\"` : ''}>${REINSERT_ICON_SCRIPT}</script>`\n  }\n}\n"],"names":["REINSERT_ICON_SCRIPT","createServerInsertedMetadata","nonce","inserted","getServerInsertedMetadata"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,uBAAuB,CAAC;kIACoG,CAAC;AAE5H,SAASC,6BAA6BC,KAAyB;IACpE,IAAIC,WAAW;IAEf,OAAO,eAAeC;QACpB,IAAID,UAAU;YACZ,OAAO;QACT;QAEAA,WAAW;QACX,OAAO,CAAC,QAAQ,EAAED,QAAQ,CAAC,OAAO,EAAEA,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,EAAEF,qBAAqB,SAAS,CAAC;IACtF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5870, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/cache-signal.ts"],"sourcesContent":["/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the cacheComponents flag is on\n * and should only be used in codepaths gated with this feature.\n */\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport class CacheSignal {\n  private count = 0\n  private earlyListeners: Array<() => void> = []\n  private listeners: Array<() => void> = []\n  private tickPending = false\n  private pendingTimeoutCleanup: (() => void) | null = null\n\n  private subscribedSignals: Set<CacheSignal> | null = null\n\n  constructor() {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      // we rely on `process.nextTick`, which is not supported in edge\n      throw new InvariantError(\n        'CacheSignal cannot be used in the edge runtime, because `cacheComponents` does not support it.'\n      )\n    }\n  }\n\n  private noMorePendingCaches() {\n    if (!this.tickPending) {\n      this.tickPending = true\n      queueMicrotask(() =>\n        process.nextTick(() => {\n          this.tickPending = false\n          if (this.count === 0) {\n            for (let i = 0; i < this.earlyListeners.length; i++) {\n              this.earlyListeners[i]()\n            }\n            this.earlyListeners.length = 0\n          }\n        })\n      )\n    }\n\n    // After a cache resolves, React will schedule new rendering work:\n    // - in a microtask (when prerendering)\n    // - in setImmediate (when rendering)\n    // To cover both of these, we have to make sure that we let immediates execute at least once after each cache resolved.\n    // We don't know when the pending timeout was scheduled (and if it's about to resolve),\n    // so by scheduling a new one, we can be sure that we'll go around the event loop at least once.\n    if (this.pendingTimeoutCleanup) {\n      // We cancel the timeout in beginRead, so this shouldn't ever be active here,\n      // but we still cancel it defensively.\n      this.pendingTimeoutCleanup()\n    }\n    this.pendingTimeoutCleanup = scheduleImmediateAndTimeoutWithCleanup(\n      this.invokeListenersIfNoPendingReads\n    )\n  }\n\n  private invokeListenersIfNoPendingReads = () => {\n    this.pendingTimeoutCleanup = null\n    if (this.count === 0) {\n      for (let i = 0; i < this.listeners.length; i++) {\n        this.listeners[i]()\n      }\n      this.listeners.length = 0\n    }\n  }\n\n  /**\n   * This promise waits until there are no more in progress cache reads but no later.\n   * This allows for adding more cache reads after to delay cacheReady.\n   */\n  inputReady() {\n    return new Promise<void>((resolve) => {\n      this.earlyListeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */\n  cacheReady() {\n    return new Promise<void>((resolve) => {\n      this.listeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  beginRead() {\n    this.count++\n\n    // There's a new pending cache, so if there's a `noMorePendingCaches` timeout running,\n    // we should cancel it.\n    if (this.pendingTimeoutCleanup) {\n      this.pendingTimeoutCleanup()\n      this.pendingTimeoutCleanup = null\n    }\n\n    if (this.subscribedSignals !== null) {\n      for (const subscriber of this.subscribedSignals) {\n        subscriber.beginRead()\n      }\n    }\n  }\n\n  endRead() {\n    if (this.count === 0) {\n      throw new InvariantError(\n        'CacheSignal got more endRead() calls than beginRead() calls'\n      )\n    }\n\n    // If this is the last read we need to wait a task before we can claim the cache is settled.\n    // The cache read will likely ping a Server Component which can read from the cache again and this\n    // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n    // after at least one task.\n    // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n    // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n    this.count--\n    if (this.count === 0) {\n      this.noMorePendingCaches()\n    }\n\n    if (this.subscribedSignals !== null) {\n      for (const subscriber of this.subscribedSignals) {\n        subscriber.endRead()\n      }\n    }\n  }\n\n  hasPendingReads(): boolean {\n    return this.count > 0\n  }\n\n  trackRead<T>(promise: Promise<T>) {\n    this.beginRead()\n    // `promise.finally()` still rejects, so don't use it here to avoid unhandled rejections\n    const onFinally = this.endRead.bind(this)\n    promise.then(onFinally, onFinally)\n    return promise\n  }\n\n  subscribeToReads(subscriber: CacheSignal): () => void {\n    if (subscriber === this) {\n      throw new InvariantError('A CacheSignal cannot subscribe to itself')\n    }\n    if (this.subscribedSignals === null) {\n      this.subscribedSignals = new Set()\n    }\n    this.subscribedSignals.add(subscriber)\n\n    // we'll notify the subscriber of each endRead() on this signal,\n    // so we need to give it a corresponding beginRead() for each read we have in flight now.\n    for (let i = 0; i < this.count; i++) {\n      subscriber.beginRead()\n    }\n\n    return this.unsubscribeFromReads.bind(this, subscriber)\n  }\n\n  unsubscribeFromReads(subscriber: CacheSignal) {\n    if (!this.subscribedSignals) {\n      return\n    }\n    this.subscribedSignals.delete(subscriber)\n\n    // we don't need to set the set back to `null` if it's empty --\n    // if other signals are subscribing to this one, it'll likely get more subscriptions later,\n    // so we'd have to allocate a fresh set again when that happens.\n  }\n}\n\nfunction scheduleImmediateAndTimeoutWithCleanup(cb: () => void): () => void {\n  // If we decide to clean up the timeout, we want to remove\n  // either the immediate or the timeout, whichever is still pending.\n  let clearPending: () => void\n\n  const immediate = setImmediate(() => {\n    const timeout = setTimeout(cb, 0)\n    clearPending = clearTimeout.bind(null, timeout)\n  })\n  clearPending = clearImmediate.bind(null, immediate)\n\n  return () => clearPending()\n}\n"],"names":["InvariantError","CacheSignal","constructor","count","earlyListeners","listeners","tickPending","pendingTimeoutCleanup","subscribedSignals","invokeListenersIfNoPendingReads","i","length","process","env","NEXT_RUNTIME","noMorePendingCaches","queueMicrotask","nextTick","scheduleImmediateAndTimeoutWithCleanup","inputReady","Promise","resolve","push","cacheReady","beginRead","subscriber","endRead","hasPendingReads","trackRead","promise","onFinally","bind","then","subscribeToReads","Set","add","unsubscribeFromReads","delete","cb","clearPending","immediate","setImmediate","timeout","setTimeout","clearTimeout","clearImmediate"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6048, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/module-loading/track-module-loading.instance.ts"],"sourcesContent":["import { CacheSignal } from '../cache-signal'\nimport { isThenable } from '../../../shared/lib/is-thenable'\n\n/**\n * Tracks all in-flight async imports and chunk loads.\n * Initialized lazily, because we don't want this to error in case it gets pulled into an edge runtime module.\n */\nlet _moduleLoadingSignal: CacheSignal | null\nfunction getModuleLoadingSignal() {\n  if (!_moduleLoadingSignal) {\n    _moduleLoadingSignal = new CacheSignal()\n  }\n  return _moduleLoadingSignal\n}\n\nexport function trackPendingChunkLoad(promise: Promise<unknown>) {\n  const moduleLoadingSignal = getModuleLoadingSignal()\n  moduleLoadingSignal.trackRead(promise)\n}\n\nexport function trackPendingImport(exportsOrPromise: unknown) {\n  const moduleLoadingSignal = getModuleLoadingSignal()\n\n  // requiring an async module returns a promise.\n  // if it's sync, there's nothing to track.\n  if (isThenable(exportsOrPromise)) {\n    // A client reference proxy might look like a promise, but we can only call `.then()` on it, not e.g. `.finally()`.\n    // Turn it into a real promise to avoid issues elsewhere.\n    const promise = Promise.resolve(exportsOrPromise)\n    moduleLoadingSignal.trackRead(promise)\n  }\n}\n\n/**\n * A top-level dynamic import (or chunk load):\n *\n *   1. delays a prerender (potentially for a task or longer)\n *   2. may reveal more caches that need be filled\n *\n * So if we see one, we want to extend the duration of `cacheSignal` at least until the import/chunk-load is done.\n */\nexport function trackPendingModules(cacheSignal: CacheSignal): void {\n  const moduleLoadingSignal = getModuleLoadingSignal()\n\n  // We can't just use `cacheSignal.trackRead(moduleLoadingSignal.cacheReady())`,\n  // because we might start and finish multiple batches of module loads while waiting for caches,\n  // and `moduleLoadingSignal.cacheReady()` would resolve after the first batch.\n  // Instead, we'll keep notifying `cacheSignal` of each import/chunk-load.\n  const unsubscribe = moduleLoadingSignal.subscribeToReads(cacheSignal)\n\n  // Later, when `cacheSignal` is no longer waiting for any caches (or imports that we've notified it of),\n  // we can unsubscribe it.\n  cacheSignal.cacheReady().then(unsubscribe)\n}\n"],"names":["CacheSignal","isThenable","_moduleLoadingSignal","getModuleLoadingSignal","trackPendingChunkLoad","promise","moduleLoadingSignal","trackRead","trackPendingImport","exportsOrPromise","Promise","resolve","trackPendingModules","cacheSignal","unsubscribe","subscribeToReads","cacheReady","then"],"mappings":";;;;;;;;AAAA,SAASA,WAAW,QAAQ,kBAAiB;AAC7C,SAASC,UAAU,QAAQ,kCAAiC;;;AAE5D;;;CAGC,GACD,IAAIC;AACJ,SAASC;IACP,IAAI,CAACD,sBAAsB;QACzBA,uBAAuB,IAAIF,0NAAAA;IAC7B;IACA,OAAOE;AACT;AAEO,SAASE,sBAAsBC,OAAyB;IAC7D,MAAMC,sBAAsBH;IAC5BG,oBAAoBC,SAAS,CAACF;AAChC;AAEO,SAASG,mBAAmBC,gBAAyB;IAC1D,MAAMH,sBAAsBH;IAE5B,+CAA+C;IAC/C,0CAA0C;IAC1C,QAAIF,8MAAAA,EAAWQ,mBAAmB;QAChC,mHAAmH;QACnH,yDAAyD;QACzD,MAAMJ,UAAUK,QAAQC,OAAO,CAACF;QAChCH,oBAAoBC,SAAS,CAACF;IAChC;AACF;AAUO,SAASO,oBAAoBC,WAAwB;IAC1D,MAAMP,sBAAsBH;IAE5B,+EAA+E;IAC/E,+FAA+F;IAC/F,8EAA8E;IAC9E,yEAAyE;IACzE,MAAMW,cAAcR,oBAAoBS,gBAAgB,CAACF;IAEzD,wGAAwG;IACxG,yBAAyB;IACzBA,YAAYG,UAAU,GAAGC,IAAI,CAACH;AAChC","ignoreList":[0]}},
    {"offset": {"line": 6100, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/module-loading/track-module-loading.external.ts"],"sourcesContent":["// NOTE: this is marked as shared/external because it's stateful\n// and the state needs to be shared between app-render (which waits for pending imports)\n// and helpers used in transformed page code (which register pending imports)\n\nimport {\n  trackPendingChunkLoad,\n  trackPendingImport,\n  trackPendingModules,\n} from './track-module-loading.instance' with { 'turbopack-transition': 'next-shared' }\n\nexport { trackPendingChunkLoad, trackPendingImport, trackPendingModules }\n"],"names":["trackPendingChunkLoad","trackPendingImport","trackPendingModules"],"mappings":";AAAA,gEAAgE;AAChE,wFAAwF;AACxF,6EAA6E;AAE7E,SACEA,qBAAqB,EACrBC,kBAAkB,EAClBC,mBAAmB,QACd,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 6112, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/staged-validation.tsx"],"sourcesContent":["import { getLayoutOrPageModule } from '../lib/app-dir-module'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\n\nexport async function anySegmentHasRuntimePrefetchEnabled(\n  tree: LoaderTree\n): Promise<boolean> {\n  const { mod: layoutOrPageMod } = await getLayoutOrPageModule(tree)\n\n  // TODO(restart-on-cache-miss): Does this work correctly for client page/layout modules?\n  const prefetchConfig = layoutOrPageMod\n    ? (layoutOrPageMod as AppSegmentConfig).unstable_prefetch\n    : undefined\n  /** Whether this segment should use a runtime prefetch instead of a static prefetch. */\n  const hasRuntimePrefetch = prefetchConfig?.mode === 'runtime'\n  if (hasRuntimePrefetch) {\n    return true\n  }\n\n  const { parallelRoutes } = parseLoaderTree(tree)\n  for (const parallelRouteKey in parallelRoutes) {\n    const parallelRoute = parallelRoutes[parallelRouteKey]\n    const hasChildRuntimePrefetch =\n      await anySegmentHasRuntimePrefetchEnabled(parallelRoute)\n    if (hasChildRuntimePrefetch) {\n      return true\n    }\n  }\n\n  return false\n}\n"],"names":["getLayoutOrPageModule","parseLoaderTree","anySegmentHasRuntimePrefetchEnabled","tree","mod","layoutOrPageMod","prefetchConfig","unstable_prefetch","undefined","hasRuntimePrefetch","mode","parallelRoutes","parallelRouteKey","parallelRoute","hasChildRuntimePrefetch"],"mappings":";;;;AAAA,SAASA,qBAAqB,QAAQ,wBAAuB;AAE7D,SAASC,eAAe,QAAQ,kDAAiD;;;AAG1E,eAAeC,oCACpBC,IAAgB;IAEhB,MAAM,EAAEC,KAAKC,eAAe,EAAE,GAAG,UAAML,4NAAAA,EAAsBG;IAE7D,wFAAwF;IACxF,MAAMG,iBAAiBD,kBAClBA,gBAAqCE,iBAAiB,GACvDC;IACJ,qFAAqF,GACrF,MAAMC,qBAAqBH,CAAAA,kBAAAA,OAAAA,KAAAA,IAAAA,eAAgBI,IAAI,MAAK;IACpD,IAAID,oBAAoB;QACtB,OAAO;IACT;IAEA,MAAM,EAAEE,cAAc,EAAE,OAAGV,4OAAAA,EAAgBE;IAC3C,IAAK,MAAMS,oBAAoBD,eAAgB;QAC7C,MAAME,gBAAgBF,cAAc,CAACC,iBAAiB;QACtD,MAAME,0BACJ,MAAMZ,oCAAoCW;QAC5C,IAAIC,yBAAyB;YAC3B,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 6142, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/app-render.tsx"],"sourcesContent":["import type { ComponentType, ErrorInfo, JSX, ReactNode } from 'react'\nimport type { RenderOpts, PreloadCallbacks } from './types'\nimport type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  Segment,\n  CacheNodeSeedData,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n  FlightDataPath,\n} from '../../shared/lib/app-router-types'\nimport type { Readable } from 'node:stream'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type {\n  PrerenderStoreModernRuntime,\n  RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport * as ReactClient from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n  continueStaticFallbackPrerender,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n} from '../../client/components/app-router-headers'\nimport { createMetadataContext } from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { createWorkStore } from '../async-storage/work-store'\nimport {\n  getAccessFallbackErrorTypeByStatus,\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer, SpanStatusCode } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n  getDigestForWellKnownError,\n} from './create-error-handler'\nimport { dynamicParamTypes } from './get-short-dynamic-param-type'\nimport { getSegmentParam } from '../../shared/lib/router/utils/get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree, getRootParams } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from './manifests-singleton'\nimport {\n  DynamicState,\n  type PostponedState,\n  DynamicHTMLPreludeState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  getFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createRenderInBrowserAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  PreludeState,\n  consumeDynamicAccess,\n  type DynamicAccess,\n  logDisallowedDynamicError,\n  trackDynamicHoleInRuntimeShell,\n  trackDynamicHoleInStaticShell,\n  getStaticShellDisallowedDynamicReasons,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getIsPossibleServerAction } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../client/components/app-router-instance'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\nimport {\n  prerenderAndAbortInSequentialTasksWithStages,\n  processPrelude,\n} from './app-render-prerender-utils'\nimport {\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n} from './app-render-prerender-utils'\nimport {\n  Phase,\n  printDebugThrownValueForProspectiveRender,\n} from './prospective-render-utils'\nimport {\n  pipelineInSequentialTasks,\n  scheduleInSequentialTasks,\n} from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  getHmrRefreshHash,\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { consoleAsyncStorage } from './console-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport { HTML_CONTENT_TYPE_HEADER, INFINITE_CACHE } from '../../lib/constants'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\nimport isError from '../../lib/is-error'\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\nimport { getPreviouslyRevalidatedTags } from '../server-utils'\nimport { executeRevalidates } from '../revalidation-utils'\nimport {\n  trackPendingChunkLoad,\n  trackPendingImport,\n  trackPendingModules,\n} from './module-loading/track-module-loading.external'\nimport { isReactLargeShellError } from './react-large-shell-error'\nimport type { GlobalErrorComponent } from '../../client/components/builtin/global-error'\nimport { normalizeConventionFilePath } from './segment-explorer-path'\nimport { getRequestMeta } from '../request-meta'\nimport {\n  getDynamicParam,\n  interpolateParallelRouteParams,\n} from '../../shared/lib/router/utils/get-dynamic-param'\nimport type { ExperimentalConfig } from '../config-shared'\nimport type { Params } from '../request/params'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\nimport { ImageConfigContext } from '../../shared/lib/image-config-context.shared-runtime'\nimport { imageConfigDefault } from '../../shared/lib/image-config'\nimport { RenderStage, StagedRenderingController } from './staged-rendering'\nimport { anySegmentHasRuntimePrefetchEnabled } from './staged-validation'\nimport { warnOnce } from '../../shared/lib/utils/warn-once'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => DynamicParam | null\n\nexport type DynamicParam = {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n}\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppSharedContext = {\n  buildId: string\n}\n\nexport type AppRenderContext = {\n  sharedContext: AppSharedContext\n  workStore: WorkStore\n  url: ReturnType<typeof parseRelativeUrl>\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isPossibleServerAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  htmlRequestId: string\n  pagePath: string\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n  /**\n   * For now, the implicit tags are common for the whole route. If we ever start\n   * rendering/revalidating segments independently, they need to move to the\n   * work unit store.\n   */\n  implicitTags: ImplicitTags\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isRoutePPREnabled: boolean\n  readonly previewModeId: string | undefined\n}\n\nconst flightDataPathHeadKey = 'h'\nconst getFlightViewportKey = (requestId: string) => requestId + 'v'\nconst getFlightMetadataKey = (requestId: string) => requestId + 'm'\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isRuntimePrefetchRequest: boolean\n  readonly isRouteTreePrefetchRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n  readonly previouslyRevalidatedTags: string[]\n  readonly requestId: string | undefined\n  readonly htmlRequestId: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  // runtime prefetch requests are *not* treated as prefetch requests\n  // (TODO: this is confusing, we should refactor this to express this better)\n  const isPrefetchRequest = headers[NEXT_ROUTER_PREFETCH_HEADER] === '1'\n\n  const isRuntimePrefetchRequest = headers[NEXT_ROUTER_PREFETCH_HEADER] === '2'\n\n  const isHmrRefresh = headers[NEXT_HMR_REFRESH_HEADER] !== undefined\n\n  const isRSCRequest = headers[RSC_HEADER] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(headers[NEXT_ROUTER_STATE_TREE_HEADER])\n    : undefined\n\n  // Checks if this is a prefetch of the Route Tree by the Segment Cache\n  const isRouteTreePrefetchRequest =\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] === '/_tree'\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n    headers,\n    options.previewModeId\n  )\n\n  let requestId: string | undefined\n  let htmlRequestId: string | undefined\n\n  if (process.env.NODE_ENV !== 'production') {\n    // The request IDs are only used in development mode to send debug\n    // information to the matching client (identified by the HTML request ID\n    // that was sent to the client with the HTML document) for the current\n    // request (identified by the request ID, as defined by the client).\n\n    requestId =\n      typeof headers[NEXT_REQUEST_ID_HEADER] === 'string'\n        ? headers[NEXT_REQUEST_ID_HEADER]\n        : undefined\n\n    htmlRequestId =\n      typeof headers[NEXT_HTML_REQUEST_ID_HEADER] === 'string'\n        ? headers[NEXT_HTML_REQUEST_ID_HEADER]\n        : undefined\n  }\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isRuntimePrefetchRequest,\n    isRouteTreePrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    nonce,\n    previouslyRevalidatedTags,\n    requestId,\n    htmlRequestId,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  const components = loaderTree[2]\n  const hasGlobalNotFound = !!components['global-not-found']\n  const notFoundTreeComponents: LoaderTree[2] = hasGlobalNotFound\n    ? {\n        layout: components['global-not-found']!,\n        page: [() => null, 'next/dist/client/components/builtin/empty-stub'],\n      }\n    : {\n        page: components['not-found'],\n      }\n\n  return [\n    '',\n    {\n      children: [PAGE_SEGMENT_KEY, {}, notFoundTreeComponents],\n    },\n    // When global-not-found is present, skip layout from components\n    hasGlobalNotFound ? components : {},\n  ]\n}\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  interpolatedParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n    const segmentKey = segmentParam.paramName\n    const dynamicParamType = dynamicParamTypes[segmentParam.paramType]\n    return getDynamicParam(\n      interpolatedParams,\n      segmentKey,\n      dynamicParamType,\n      fallbackRouteParams\n    )\n  }\n}\n\nfunction NonIndex({\n  createElement,\n  pagePath,\n  statusCode,\n  isPossibleServerAction,\n}: {\n  createElement: typeof ReactClient.createElement\n  pagePath: string\n  statusCode: number | undefined\n  isPossibleServerAction: boolean\n}) {\n  const is404Page = pagePath === '/404'\n  const isInvalidStatusCode = typeof statusCode === 'number' && statusCode > 400\n\n  // Only render noindex for page request, skip for server actions\n  // TODO: is this correct if `isPossibleServerAction` is a false positive?\n  if (!isPossibleServerAction && (is404Page || isInvalidStatusCode)) {\n    return createElement('meta', {\n      name: 'robots',\n      content: 'noindex',\n    })\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `next-router-state-tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult?: ActionResult\n    skipPageRendering?: boolean\n    runtimePrefetchSentinel?: number\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n      createElement,\n      createMetadataComponents,\n      Fragment,\n    },\n    getDynamicParamFromSegment,\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n    url,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  if (!options?.skipPageRendering) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n      tree: loaderTree,\n      parsedQuery: query,\n      pathname: url.pathname,\n      metadataContext: createMetadataContext(ctx.renderOpts),\n      getDynamicParamFromSegment,\n      workStore,\n      serveStreamingMetadata,\n    })\n\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        // For flight, render metadata inside leaf page\n        rscHead: createElement(\n          Fragment,\n          {\n            key: flightDataPathHeadKey,\n          },\n          createElement(NonIndex, {\n            createElement,\n            pagePath: ctx.pagePath,\n            statusCode: ctx.res.statusCode,\n            isPossibleServerAction: ctx.isPossibleServerAction,\n          }),\n          createElement(Viewport, {\n            key: getFlightViewportKey(requestId),\n          }),\n          createElement(Metadata, {\n            key: getFlightMetadataKey(requestId),\n          })\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        preloadCallbacks,\n        MetadataOutlet,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.sharedContext.buildId,\n      q: getRenderedSearch(query),\n      i: !!couldBeIntercepted,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  const baseResponse = {\n    b: ctx.sharedContext.buildId,\n    f: flightData,\n    q: getRenderedSearch(query),\n    i: !!couldBeIntercepted,\n    S: workStore.isStaticGeneration,\n  }\n\n  // For runtime prefetches, we encode the stale time and isPartial flag in the response body\n  // rather than relying on response headers. Both of these values will be transformed\n  // by a transform stream before being sent to the client.\n  if (options?.runtimePrefetchSentinel !== undefined) {\n    return {\n      ...baseResponse,\n      rp: [options.runtimePrefetchSentinel] as any,\n    }\n  }\n\n  return baseResponse\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    // TODO: is this correct if `isPossibleServerAction` is a false positive?\n    routeType: ctx.isPossibleServerAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  options?: {\n    actionResult: ActionResult\n    skipPageRendering: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n    waitUntil?: Promise<unknown>\n  }\n): Promise<RenderResult> {\n  const {\n    componentMod: { renderToReadableStream },\n    htmlRequestId,\n    renderOpts,\n    requestId,\n    workStore,\n  } = ctx\n\n  const {\n    dev = false,\n    onInstrumentationRequestError,\n    setReactDebugChannel,\n    nextExport = false,\n  } = renderOpts\n\n  function onFlightDataRenderError(err: DigestedError, silenceLog: boolean) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload'),\n      silenceLog\n    )\n  }\n\n  const onError = createReactServerErrorHandler(\n    dev,\n    nextExport,\n    workStore.reactServerErrorsByDigest,\n    onFlightDataRenderError\n  )\n\n  const debugChannel = setReactDebugChannel && createDebugChannel()\n\n  if (debugChannel) {\n    setReactDebugChannel(debugChannel.clientSide, htmlRequestId, requestId)\n  }\n\n  const { clientModules } = getClientReferenceManifest()\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const rscPayload = await workUnitAsyncStorage.run(\n    requestStore,\n    generateDynamicRSCPayload,\n    ctx,\n    options\n  )\n\n  const flightReadableStream = workUnitAsyncStorage.run(\n    requestStore,\n    renderToReadableStream,\n    rscPayload,\n    clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n      filterStackFrame,\n      debugChannel: debugChannel?.serverSide,\n    }\n  )\n\n  return new FlightRenderResult(\n    flightReadableStream,\n    { fetchMetrics: workStore.fetchMetrics },\n    options?.waitUntil\n  )\n}\n\ntype RenderToReadableStreamServerOptions = NonNullable<\n  Parameters<\n    (typeof import('react-server-dom-webpack/server.node'))['renderToReadableStream']\n  >[2]\n>\n\nasync function stagedRenderToReadableStreamWithoutCachesInDev(\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  getPayload: (requestStore: RequestStore) => Promise<RSCPayload>,\n  options: Omit<RenderToReadableStreamServerOptions, 'environmentName'>\n) {\n  const {\n    componentMod: { renderToReadableStream },\n  } = ctx\n  // We're rendering while bypassing caches,\n  // so we have no hope of showing a useful runtime stage.\n  // But we still want things like `params` to show up in devtools correctly,\n  // which relies on mechanisms we've set up for staged rendering,\n  // so we do a 2-task version (Static -> Dynamic) instead.\n\n  // We aren't doing any validation in this kind of render so we say there\n  // is not runtime prefetch regardless of whether there is or not\n  const hasRuntimePrefetch = false\n\n  // We aren't filling caches so we don't need to abort this render, it'll\n  // stream in a single pass\n  const abortSignal = null\n\n  const stageController = new StagedRenderingController(\n    abortSignal,\n    hasRuntimePrefetch\n  )\n  const environmentName = () => {\n    const currentStage = stageController.currentStage\n    switch (currentStage) {\n      case RenderStage.Before:\n      case RenderStage.Static:\n        return 'Prerender'\n      case RenderStage.Runtime:\n      case RenderStage.Dynamic:\n      case RenderStage.Abandoned:\n        return 'Server'\n      default:\n        currentStage satisfies never\n        throw new InvariantError(`Invalid render stage: ${currentStage}`)\n    }\n  }\n\n  requestStore.stagedRendering = stageController\n  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n    stageController,\n    requestStore.cookies,\n    requestStore.mutableCookies,\n    requestStore.headers\n  )\n\n  const { clientModules } = getClientReferenceManifest()\n  const rscPayload = await getPayload(requestStore)\n\n  return await workUnitAsyncStorage.run(\n    requestStore,\n    scheduleInSequentialTasks,\n    () => {\n      stageController.advanceStage(RenderStage.Static)\n      return renderToReadableStream(rscPayload, clientModules, {\n        ...options,\n        environmentName,\n      })\n    },\n    () => {\n      stageController.advanceStage(RenderStage.Dynamic)\n    }\n  )\n}\n\n/**\n * Fork of `generateDynamicFlightRenderResult` that renders using `renderWithRestartOnCacheMissInDev`\n * to ensure correct separation of environments Prerender/Server (for use in Cache Components)\n */\nasync function generateDynamicFlightRenderResultWithStagesInDev(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  initialRequestStore: RequestStore,\n  createRequestStore: (() => RequestStore) | undefined,\n  devFallbackParams: OpaqueFallbackRouteParams | null\n): Promise<RenderResult> {\n  const {\n    htmlRequestId,\n    renderOpts,\n    requestId,\n    workStore,\n    componentMod: { createElement },\n    url,\n  } = ctx\n\n  const {\n    dev = false,\n    onInstrumentationRequestError,\n    setReactDebugChannel,\n    setCacheStatus,\n    nextExport = false,\n  } = renderOpts\n\n  function onFlightDataRenderError(err: DigestedError, silenceLog: boolean) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload'),\n      silenceLog\n    )\n  }\n\n  const onError = createReactServerErrorHandler(\n    dev,\n    nextExport,\n    workStore.reactServerErrorsByDigest,\n    onFlightDataRenderError\n  )\n\n  // We only validate RSC requests if it is for HMR refreshes since we know we\n  // will render all the layouts necessary to perform the validation.\n  const shouldValidate =\n    !isBypassingCachesInDev(renderOpts, initialRequestStore) &&\n    initialRequestStore.isHmrRefresh === true\n\n  const getPayload = async (requestStore: RequestStore) => {\n    const payload: RSCPayload &\n      RSCPayloadDevProperties &\n      RSCInitialPayloadPartialDev = await workUnitAsyncStorage.run(\n      requestStore,\n      generateDynamicRSCPayload,\n      ctx,\n      undefined\n    )\n\n    if (isBypassingCachesInDev(renderOpts, requestStore)) {\n      // Mark the RSC payload to indicate that caches were bypassed in dev.\n      // This lets the client know not to cache anything based on this render.\n      payload._bypassCachesInDev = createElement(WarnForBypassCachesInDev, {\n        route: workStore.route,\n      })\n    } else if (shouldValidate) {\n      // If this payload will be used for validation, it needs to contain the\n      // canonical URL. Without it we'd get an error.\n      payload.c = prepareInitialCanonicalUrl(url)\n    }\n\n    return payload\n  }\n\n  let debugChannel: DebugChannelPair | undefined\n  let stream: ReadableStream<Uint8Array>\n\n  if (\n    // We only do this flow if we can safely recreate the store from scratch\n    // (which is not the case for renders after an action)\n    createRequestStore &&\n    // We only do this flow if we're not bypassing caches in dev using\n    // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n    !isBypassingCachesInDev(renderOpts, initialRequestStore)\n  ) {\n    // Before we kick off the render, we set the cache status back to it's initial state\n    // in case a previous render bypassed the cache.\n    if (setCacheStatus) {\n      setCacheStatus('ready', htmlRequestId)\n    }\n\n    const {\n      stream: serverStream,\n      accumulatedChunksPromise,\n      staticInterruptReason,\n      runtimeInterruptReason,\n      staticStageEndTime,\n      runtimeStageEndTime,\n      debugChannel: returnedDebugChannel,\n      requestStore: finalRequestStore,\n    } = await renderWithRestartOnCacheMissInDev(\n      ctx,\n      initialRequestStore,\n      createRequestStore,\n      getPayload,\n      onError\n    )\n\n    if (shouldValidate) {\n      let validationDebugChannelClient: Readable | undefined = undefined\n      if (returnedDebugChannel) {\n        const [t1, t2] = returnedDebugChannel.clientSide.readable.tee()\n        returnedDebugChannel.clientSide.readable = t1\n        validationDebugChannelClient = nodeStreamFromReadableStream(t2)\n      }\n      consoleAsyncStorage.run(\n        { dim: true },\n        spawnStaticShellValidationInDev,\n        accumulatedChunksPromise,\n        staticInterruptReason,\n        runtimeInterruptReason,\n        staticStageEndTime,\n        runtimeStageEndTime,\n        ctx,\n        finalRequestStore,\n        devFallbackParams,\n        validationDebugChannelClient\n      )\n    }\n\n    debugChannel = returnedDebugChannel\n    stream = serverStream\n  } else {\n    // We're either bypassing caches or we can't restart the render.\n    // Do a dynamic render, but with (basic) environment labels.\n\n    // Set cache status to bypass when specifically bypassing caches in dev\n    if (setCacheStatus) {\n      setCacheStatus('bypass', htmlRequestId)\n    }\n\n    debugChannel = setReactDebugChannel && createDebugChannel()\n\n    stream = await stagedRenderToReadableStreamWithoutCachesInDev(\n      ctx,\n      initialRequestStore,\n      getPayload,\n      {\n        onError: onError,\n        filterStackFrame,\n        debugChannel: debugChannel?.serverSide,\n      }\n    )\n  }\n\n  if (debugChannel && setReactDebugChannel) {\n    setReactDebugChannel(debugChannel.clientSide, htmlRequestId, requestId)\n  }\n\n  return new FlightRenderResult(stream, {\n    fetchMetrics: workStore.fetchMetrics,\n  })\n}\n\nasync function generateRuntimePrefetchResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore\n): Promise<RenderResult> {\n  const { workStore, renderOpts } = ctx\n  const { nextExport = false, onInstrumentationRequestError } = renderOpts\n\n  function onFlightDataRenderError(err: DigestedError, silenceLog: boolean) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      // TODO(runtime-ppr): should we use a different value?\n      createErrorContext(ctx, 'react-server-components-payload'),\n      silenceLog\n    )\n  }\n\n  const onError = createReactServerErrorHandler(\n    false,\n    nextExport,\n    workStore.reactServerErrorsByDigest,\n    onFlightDataRenderError\n  )\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  // Generate a random sentinel that will be used as a placeholder in the payload\n  // and later replaced by the transform stream\n  const runtimePrefetchSentinel = Math.floor(\n    Math.random() * Number.MAX_SAFE_INTEGER\n  )\n\n  const generatePayload = () =>\n    generateDynamicRSCPayload(ctx, { runtimePrefetchSentinel })\n\n  const {\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n    },\n    getDynamicParamFromSegment,\n  } = ctx\n  const rootParams = getRootParams(loaderTree, getDynamicParamFromSegment)\n\n  // We need to share caches between the prospective prerender and the final prerender,\n  // but we're not going to persist this anywhere.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  // We're not resuming an existing render.\n  const renderResumeDataCache = null\n\n  await prospectiveRuntimeServerPrerender(\n    ctx,\n    generatePayload,\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    rootParams,\n    requestStore.headers,\n    requestStore.cookies,\n    requestStore.draftMode\n  )\n\n  const response = await finalRuntimeServerPrerender(\n    ctx,\n    generatePayload,\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    rootParams,\n    requestStore.headers,\n    requestStore.cookies,\n    requestStore.draftMode,\n    onError,\n    runtimePrefetchSentinel\n  )\n\n  applyMetadataFromPrerenderResult(response, metadata, workStore)\n  metadata.fetchMetrics = ctx.workStore.fetchMetrics\n\n  return new FlightRenderResult(response.result.prelude, metadata)\n}\n\nasync function prospectiveRuntimeServerPrerender(\n  ctx: AppRenderContext,\n  getPayload: () => any,\n  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n  renderResumeDataCache: RenderResumeDataCache | null,\n  rootParams: Params,\n  headers: PrerenderStoreModernRuntime['headers'],\n  cookies: PrerenderStoreModernRuntime['cookies'],\n  draftMode: PrerenderStoreModernRuntime['draftMode']\n) {\n  const { implicitTags, renderOpts, workStore } = ctx\n  const { ComponentMod } = renderOpts\n\n  // Prerender controller represents the lifetime of the prerender.\n  // It will be aborted when a Task is complete or a synchronously aborting\n  // API is called. Notably during cache-filling renders this does not actually\n  // terminate the render itself which will continue until all caches are filled\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller represents the lifetime of the React render call. Notably\n  // during the cache-filling render it is different from the prerender controller\n  // because we don't want to end the react render until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  // The cacheSignal helps us track whether caches are still filling or we are ready\n  // to cut the render off.\n  const cacheSignal = new CacheSignal()\n\n  const initialServerPrerenderStore: PrerenderStoreModernRuntime = {\n    type: 'prerender-runtime',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    // During the initial prerender we need to track all cache reads to ensure\n    // we render long enough to fill every cache it is possible to visit during\n    // the final prerender.\n    cacheSignal,\n    // We only need to track dynamic accesses during the final prerender.\n    dynamicTracking: null,\n    // Runtime prefetches are never cached server-side, only client-side,\n    // so we set `expire` and `revalidate` to their minimum values just in case.\n    revalidate: 1,\n    expire: 0,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    renderResumeDataCache,\n    prerenderResumeDataCache,\n    hmrRefreshHash: undefined,\n    // We only need task sequencing in the final prerender.\n    runtimeStagePromise: null,\n    // These are not present in regular prerenders, but allowed in a runtime prerender.\n    headers,\n    cookies,\n    draftMode,\n  }\n\n  const { clientModules } = getClientReferenceManifest()\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const initialServerPayload = await workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    getPayload\n  )\n\n  const pendingInitialServerResult = workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    ComponentMod.prerender,\n    initialServerPayload,\n    clientModules,\n    {\n      filterStackFrame,\n      onError: (err) => {\n        const digest = getDigestForWellKnownError(err)\n\n        if (digest) {\n          return digest\n        }\n\n        if (initialServerPrerenderController.signal.aborted) {\n          // The render aborted before this error was handled which indicates\n          // the error is caused by unfinished components within the render\n          return\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          printDebugThrownValueForProspectiveRender(\n            err,\n            workStore.route,\n            Phase.ProspectiveRender\n          )\n        }\n      },\n      // We don't want to stop rendering until the cacheSignal is complete so we pass\n      // a different signal to this render call than is used by dynamic APIs to signify\n      // transitioning out of the prerender environment\n      signal: initialServerRenderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling and for async imports to resolve\n  trackPendingModules(cacheSignal)\n  await cacheSignal.cacheReady()\n\n  initialServerRenderController.abort()\n  initialServerPrerenderController.abort()\n\n  // We don't need to continue the prerender process if we already\n  // detected invalid dynamic usage in the initial prerender phase.\n  if (workStore.invalidDynamicUsageError) {\n    throw workStore.invalidDynamicUsageError\n  }\n\n  try {\n    return await createReactServerPrerenderResult(pendingInitialServerResult)\n  } catch (err) {\n    if (\n      initialServerRenderController.signal.aborted ||\n      initialServerPrerenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(\n        err,\n        workStore.route,\n        Phase.ProspectiveRender\n      )\n    }\n    return null\n  }\n}\n/**\n * Updates the runtime prefetch metadata in the RSC payload as it streams:\n *   \"rp\":[<sentinel>] -> \"rp\":[<isPartial>,<staleTime>]\n *\n * We use a transform stream to do this to avoid needing to trigger an additional render.\n * A random sentinel number guarantees no collision with user data.\n */\nfunction createRuntimePrefetchTransformStream(\n  sentinel: number,\n  isPartial: boolean,\n  staleTime: number\n): TransformStream<Uint8Array, Uint8Array> {\n  const encoder = new TextEncoder()\n\n  // Search for: [<sentinel>]\n  // Replace with: [<isPartial>,<staleTime>]\n  const search = encoder.encode(`[${sentinel}]`)\n  const first = search[0]\n  const replace = encoder.encode(`[${isPartial},${staleTime}]`)\n  const searchLen = search.length\n\n  let currentChunk: Uint8Array | null = null\n  let found = false\n\n  function processChunk(\n    controller: TransformStreamDefaultController<Uint8Array>,\n    nextChunk: null | Uint8Array\n  ) {\n    if (found) {\n      if (nextChunk) {\n        controller.enqueue(nextChunk)\n      }\n      return\n    }\n\n    if (currentChunk) {\n      // We can't search past the index that can contain a full match\n      let exclusiveUpperBound = currentChunk.length - (searchLen - 1)\n      if (nextChunk) {\n        // If we have any overflow bytes we can search up to the chunk's final byte\n        exclusiveUpperBound += Math.min(nextChunk.length, searchLen - 1)\n      }\n      if (exclusiveUpperBound < 1) {\n        // we can't match the current chunk.\n        controller.enqueue(currentChunk)\n        currentChunk = nextChunk // advance so we don't process this chunk again\n        return\n      }\n\n      let currentIndex = currentChunk.indexOf(first)\n\n      // check the current candidate match if it is within the bounds of our search space for the currentChunk\n      candidateLoop: while (\n        -1 < currentIndex &&\n        currentIndex < exclusiveUpperBound\n      ) {\n        // We already know index 0 matches because we used indexOf to find the candidateIndex so we start at index 1\n        let matchIndex = 1\n        while (matchIndex < searchLen) {\n          const candidateIndex = currentIndex + matchIndex\n          const candidateValue =\n            candidateIndex < currentChunk.length\n              ? currentChunk[candidateIndex]\n              : // if we ever hit this condition it is because there is a nextChunk we can read from\n                nextChunk![candidateIndex - currentChunk.length]\n          if (candidateValue !== search[matchIndex]) {\n            // No match, reset and continue the search from the next position\n            currentIndex = currentChunk.indexOf(first, currentIndex + 1)\n            continue candidateLoop\n          }\n          matchIndex++\n        }\n        // We found a complete match. currentIndex is our starting point to replace the value.\n        found = true\n        // enqueue everything up to the match\n        controller.enqueue(currentChunk.subarray(0, currentIndex))\n        // enqueue the replacement value\n        controller.enqueue(replace)\n        // If there are bytes in the currentChunk after the match enqueue them\n        if (currentIndex + searchLen < currentChunk.length) {\n          controller.enqueue(currentChunk.slice(currentIndex + searchLen))\n        }\n        // If we have a next chunk we enqueue it now\n        if (nextChunk) {\n          // if replacement spills over to the next chunk we first exclude the replaced bytes\n          const overflowBytes = currentIndex + searchLen - currentChunk.length\n          const truncatedChunk =\n            overflowBytes > 0 ? nextChunk!.subarray(overflowBytes) : nextChunk\n          controller.enqueue(truncatedChunk)\n        }\n        // We are now in found mode and don't need to track currentChunk anymore\n        currentChunk = null\n        return\n      }\n      // No match found in this chunk, emit it and wait for the next one\n      controller.enqueue(currentChunk)\n    }\n\n    // Advance to the next chunk\n    currentChunk = nextChunk\n  }\n\n  return new TransformStream<Uint8Array, Uint8Array>({\n    transform(chunk, controller) {\n      processChunk(controller, chunk)\n    },\n    flush(controller) {\n      processChunk(controller, null)\n    },\n  })\n}\n\nasync function finalRuntimeServerPrerender(\n  ctx: AppRenderContext,\n  getPayload: () => any,\n  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n  renderResumeDataCache: RenderResumeDataCache | null,\n  rootParams: Params,\n  headers: PrerenderStoreModernRuntime['headers'],\n  cookies: PrerenderStoreModernRuntime['cookies'],\n  draftMode: PrerenderStoreModernRuntime['draftMode'],\n  onError: (err: unknown) => string | undefined,\n  runtimePrefetchSentinel: number\n) {\n  const { implicitTags, renderOpts } = ctx\n  const { ComponentMod, experimental, isDebugDynamicAccesses } = renderOpts\n  const selectStaleTime = createSelectStaleTime(experimental)\n\n  let serverIsDynamic = false\n  const finalServerController = new AbortController()\n\n  const serverDynamicTracking = createDynamicTrackingState(\n    isDebugDynamicAccesses\n  )\n\n  const { promise: runtimeStagePromise, resolve: resolveBlockedRuntimeAPIs } =\n    createPromiseWithResolvers<void>()\n\n  const finalServerPrerenderStore: PrerenderStoreModernRuntime = {\n    type: 'prerender-runtime',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: finalServerController.signal,\n    controller: finalServerController,\n    // All caches we could read must already be filled so no tracking is necessary\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    // Runtime prefetches are never cached server-side, only client-side,\n    // so we set `expire` and `revalidate` to their minimum values just in case.\n    revalidate: 1,\n    expire: 0,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    hmrRefreshHash: undefined,\n    // Used to separate the \"Static\" stage from the \"Runtime\" stage.\n    runtimeStagePromise,\n    // These are not present in regular prerenders, but allowed in a runtime prerender.\n    headers,\n    cookies,\n    draftMode,\n  }\n\n  const { clientModules } = getClientReferenceManifest()\n\n  const finalRSCPayload = await workUnitAsyncStorage.run(\n    finalServerPrerenderStore,\n    getPayload\n  )\n\n  let prerenderIsPending = true\n  const result = await prerenderAndAbortInSequentialTasksWithStages(\n    async () => {\n      // Static stage\n      const prerenderResult = await workUnitAsyncStorage.run(\n        finalServerPrerenderStore,\n        ComponentMod.prerender,\n        finalRSCPayload,\n        clientModules,\n        {\n          filterStackFrame,\n          onError,\n          signal: finalServerController.signal,\n        }\n      )\n      prerenderIsPending = false\n      return prerenderResult\n    },\n    () => {\n      // Advance to the runtime stage.\n      //\n      // We make runtime APIs hang during the first task (above), and unblock them in the following task (here).\n      // This makes sure that, at this point, we'll have finished all the static parts (what we'd prerender statically).\n      // We know that they don't contain any incorrect sync IO, because that'd have caused a build error.\n      // After we unblock Runtime APIs, if we encounter sync IO (e.g. `await cookies(); Date.now()`),\n      // we'll abort, but we'll produce at least as much output as a static prerender would.\n      resolveBlockedRuntimeAPIs()\n    },\n    () => {\n      // Abort.\n      if (finalServerController.signal.aborted) {\n        // If the server controller is already aborted we must have called something\n        // that required aborting the prerender synchronously such as with new Date()\n        serverIsDynamic = true\n        return\n      }\n\n      if (prerenderIsPending) {\n        // If prerenderIsPending then we have blocked for longer than a Task and we assume\n        // there is something unfinished.\n        serverIsDynamic = true\n      }\n      finalServerController.abort()\n    }\n  )\n\n  // Update the RSC payload stream to replace the sentinel with actual values.\n  // React has already serialized the payload with the sentinel, so we need to transform the stream.\n  const collectedStale = selectStaleTime(finalServerPrerenderStore.stale)\n  result.prelude = result.prelude.pipeThrough(\n    createRuntimePrefetchTransformStream(\n      runtimePrefetchSentinel,\n      serverIsDynamic,\n      collectedStale\n    )\n  )\n\n  return {\n    result,\n    // TODO(runtime-ppr): do we need to produce a digest map here?\n    // digestErrorsMap: ...,\n    dynamicAccess: serverDynamicTracking,\n    isPartial: serverIsDynamic,\n    collectedRevalidate: finalServerPrerenderStore.revalidate,\n    collectedExpire: finalServerPrerenderStore.expire,\n    collectedStale,\n    collectedTags: finalServerPrerenderStore.tags,\n  }\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\nfunction getRenderedSearch(query: NextParsedUrlQuery): string {\n  // Inlined implementation of querystring.encode, which is not available in\n  // the Edge runtime.\n  const pairs = []\n  for (const key in query) {\n    const value = query[key]\n    if (value == null) continue\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        pairs.push(\n          `${encodeURIComponent(key)}=${encodeURIComponent(String(v))}`\n        )\n      }\n    } else {\n      pairs.push(\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`\n      )\n    }\n  }\n\n  // The result should match the format of a web URL's `search` property, since\n  // this is the format that's stored in the App Router state.\n  // TODO: We're a bit inconsistent about this. The x-nextjs-rewritten-query\n  // header omits the leading question mark. Should refactor to always do\n  // that instead.\n  if (pairs.length === 0) {\n    // If the search string is empty, return an empty string.\n    return ''\n  }\n  // Prepend '?' to the search params string.\n  return '?' + pairs.join('&')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: { createMetadataComponents, createElement, Fragment },\n    url,\n    workStore,\n  } = ctx\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const hasGlobalNotFound = !!tree[2]['global-not-found']\n\n  const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n    tree,\n    // When it's using global-not-found, metadata errorType is undefined, which will retrieve the\n    // metadata from the page.\n    // When it's using not-found, metadata errorType is 'not-found', which will retrieve the\n    // metadata from the not-found.js boundary.\n    // TODO: remove this condition and keep it undefined when global-not-found is stabilized.\n    errorType: is404 && !hasGlobalNotFound ? 'not-found' : undefined,\n    parsedQuery: query,\n    pathname: url.pathname,\n    metadataContext: createMetadataContext(ctx.renderOpts),\n    getDynamicParamFromSegment,\n    workStore,\n    serveStreamingMetadata,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    loaderTree: tree,\n    parentParams: {},\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n    MetadataOutlet,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = createElement(\n    Fragment,\n    {\n      key: flightDataPathHeadKey,\n    },\n    createElement(NonIndex, {\n      createElement,\n      pagePath: ctx.pagePath,\n      statusCode: ctx.res.statusCode,\n      isPossibleServerAction: ctx.isPossibleServerAction,\n    }),\n    createElement(Viewport, null),\n    createElement(Metadata, null),\n    appUsingSizeAdjustment\n      ? createElement('meta', {\n          name: 'next-size-adjust',\n          content: '',\n        })\n      : null\n  )\n\n  const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(\n    tree,\n    ctx\n  )\n\n  // Assume the head we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // See similar comment in create-component-tree.tsx for more context.\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: createElement(Preloads, {\n      preloadCallbacks: preloadCallbacks,\n    }),\n    b: ctx.sharedContext.buildId,\n    c: prepareInitialCanonicalUrl(url),\n    q: getRenderedSearch(query),\n    i: !!couldBeIntercepted,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    m: missingSlots,\n    G: [GlobalError, globalErrorStyles],\n    S: workStore.isStaticGeneration,\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  ssrError: unknown,\n  errorType: MetadataErrorType | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    componentMod: { createMetadataComponents, createElement, Fragment },\n    url,\n    workStore,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const { Viewport, Metadata } = createMetadataComponents({\n    tree,\n    parsedQuery: query,\n    pathname: url.pathname,\n    metadataContext: createMetadataContext(ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    workStore,\n    serveStreamingMetadata: serveStreamingMetadata,\n  })\n\n  const initialHead = createElement(\n    Fragment,\n    {\n      key: flightDataPathHeadKey,\n    },\n    createElement(NonIndex, {\n      createElement,\n      pagePath: ctx.pagePath,\n      statusCode: ctx.res.statusCode,\n      isPossibleServerAction: ctx.isPossibleServerAction,\n    }),\n    createElement(Viewport, null),\n    process.env.NODE_ENV === 'development' &&\n      createElement('meta', {\n        name: 'next-error',\n        content: 'not-found',\n      }),\n    createElement(Metadata, null)\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  let err: Error | undefined = undefined\n  if (ssrError) {\n    err = isError(ssrError) ? ssrError : new Error(ssrError + '')\n  }\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const seedData: CacheNodeSeedData = [\n    createElement(\n      'html',\n      {\n        id: '__next_error__',\n      },\n      createElement('head', null),\n      createElement(\n        'body',\n        null,\n        process.env.NODE_ENV !== 'production' && err\n          ? createElement('template', {\n              'data-next-error-message': err.message,\n              'data-next-error-digest': 'digest' in err ? err.digest : '',\n              'data-next-error-stack': err.stack,\n            })\n          : null\n      )\n    ),\n    {},\n    null,\n    false,\n    false, // We don't currently support runtime prefetching for error pages.\n  ]\n\n  const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(\n    tree,\n    ctx\n  )\n\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    b: ctx.sharedContext.buildId,\n    c: prepareInitialCanonicalUrl(url),\n    q: getRenderedSearch(query),\n    m: undefined,\n    i: false,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    G: [GlobalError, globalErrorStyles],\n    S: workStore.isStaticGeneration,\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  reactDebugStream,\n  debugEndTime,\n  preinitScripts,\n  ServerInsertedHTMLProvider,\n  nonce,\n  images,\n}: {\n  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n  reactServerStream: Readable | BinaryStreamOf<T>\n  reactDebugStream: Readable | ReadableStream<Uint8Array> | undefined\n  debugEndTime: number | undefined\n  preinitScripts: () => void\n  ServerInsertedHTMLProvider: ComponentType<{\n    children: JSX.Element\n  }>\n  images: RenderOpts['images']\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = ReactClient.use(\n    getFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      reactDebugStream,\n      debugEndTime,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialRenderedSearch: response.q,\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ImageConfigContext.Provider value={images ?? imageConfigDefault}>\n        <ServerInsertedHTMLProvider>\n          <AppRouter actionQueue={actionQueue} globalErrorState={response.G} />\n        </ServerInsertedHTMLProvider>\n      </ImageConfigContext.Provider>\n    </HeadManagerContext.Provider>\n  )\n  /* eslint-enable @next/internal/no-ambiguous-jsx -- React Client */\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction ErrorApp<T>({\n  reactServerStream,\n  preinitScripts,\n  ServerInsertedHTMLProvider,\n  nonce,\n  images,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  ServerInsertedHTMLProvider: ComponentType<{\n    children: JSX.Element\n  }>\n  nonce?: string\n  images: RenderOpts['images']\n}): JSX.Element {\n  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n  preinitScripts()\n  const response = ReactClient.use(\n    getFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      undefined,\n      undefined,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialRenderedSearch: response.q,\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  return (\n    <ImageConfigContext.Provider value={images ?? imageConfigDefault}>\n      <ServerInsertedHTMLProvider>\n        <AppRouter actionQueue={actionQueue} globalErrorState={response.G} />\n      </ServerInsertedHTMLProvider>\n    </ImageConfigContext.Provider>\n  )\n  /* eslint-enable @next/internal/no-ambiguous-jsx -- React Client */\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  url: ReturnType<typeof parseRelativeUrl>,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  postponedState: PostponedState | null,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext,\n  interpolatedParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n    cacheComponents,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we track calls to `loadChunk` and `require`. This allows us\n    // to treat chunk/module loading with similar semantics as cache reads to avoid\n    // module loading from causing a prerender to abort too early.\n\n    const shouldTrackModuleLoading = () => {\n      if (!cacheComponents) {\n        return false\n      }\n      if (renderOpts.dev) {\n        return true\n      }\n      const workUnitStore = workUnitAsyncStorage.getStore()\n\n      if (!workUnitStore) {\n        return false\n      }\n\n      switch (workUnitStore.type) {\n        case 'prerender':\n        case 'prerender-client':\n        case 'prerender-runtime':\n        case 'cache':\n        case 'private-cache':\n          return true\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'unstable-cache':\n          return false\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    const __next_require__: typeof instrumented.require = (...args) => {\n      const exportsOrPromise = instrumented.require(...args)\n      if (shouldTrackModuleLoading()) {\n        // requiring an async module returns a promise.\n        trackPendingImport(exportsOrPromise)\n      }\n      return exportsOrPromise\n    }\n    // @ts-expect-error\n    globalThis.__next_require__ = __next_require__\n\n    const __next_chunk_load__: typeof instrumented.loadChunk = (...args) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      if (shouldTrackModuleLoading()) {\n        trackPendingChunkLoad(loadingChunk)\n      }\n      return loadingChunk\n    }\n    // @ts-expect-error\n    globalThis.__next_chunk_load__ = __next_chunk_load__\n  }\n\n  if (\n    process.env.NODE_ENV === 'development' &&\n    renderOpts.setIsrStatus &&\n    !cacheComponents\n  ) {\n    // Reset the ISR status at start of request.\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setIsrStatus(\n      pathname,\n      // Only pages using the Node runtime can use ISR, Edge is always dynamic.\n      process.env.NEXT_RUNTIME === 'edge' ? false : undefined\n    )\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    res.onClose(() => {\n      // We stop tracking fetch metrics when the response closes, since we\n      // report them at that time.\n      workStore.shouldTrackFetchMetrics = false\n    })\n\n    req.originalRequest.on('end', () => {\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {\n    statusCode: isNotFoundPath ? 404 : undefined,\n  }\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const {\n    routeModule: {\n      userland: { loaderTree },\n    },\n    taintObjectReference,\n  } = ComponentMod\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to Client Components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const { isStaticGeneration } = workStore\n\n  let requestId: string\n  let htmlRequestId: string\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRuntimePrefetchRequest,\n    isRSCRequest,\n    isHmrRefresh,\n    nonce,\n  } = parsedRequestHeaders\n\n  if (parsedRequestHeaders.requestId) {\n    // If the client has provided a request ID (in development mode), we use it.\n    requestId = parsedRequestHeaders.requestId\n  } else {\n    // Otherwise we generate a new request ID.\n    if (isStaticGeneration) {\n      requestId = Buffer.from(\n        await crypto.subtle.digest('SHA-1', Buffer.from(req.url))\n      ).toString('hex')\n    } else if (process.env.NEXT_RUNTIME === 'edge') {\n      requestId = crypto.randomUUID()\n    } else {\n      requestId = (\n        require('next/dist/compiled/nanoid') as typeof import('next/dist/compiled/nanoid')\n      ).nanoid()\n    }\n  }\n\n  // If the client has provided an HTML request ID, we use it to associate the\n  // request with the HTML document from which it originated, which is used to\n  // send debug information to the associated WebSocket client. Otherwise, this\n  // is the request for the HTML document, so we use the request ID also as the\n  // HTML request ID.\n  htmlRequestId = parsedRequestHeaders.htmlRequestId || requestId\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    interpolatedParams,\n    fallbackRouteParams\n  )\n\n  const isPossibleActionRequest = getIsPossibleServerAction(req)\n\n  const implicitTags = await getImplicitTags(\n    workStore.page,\n    url,\n    fallbackRouteParams\n  )\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    url,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isPossibleServerAction: isPossibleActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    htmlRequestId,\n    pagePath,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n    sharedContext,\n    implicitTags,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    const response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      loaderTree,\n      fallbackRouteParams\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (workStore.invalidDynamicUsageError) {\n      logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)\n      throw new StaticGenBailoutError()\n    }\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n      contentType: HTML_CONTENT_TYPE_HEADER,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    applyMetadataFromPrerenderResult(response, metadata, workStore)\n\n    if (response.renderResumeDataCache) {\n      metadata.renderResumeDataCache = response.renderResumeDataCache\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    const renderResumeDataCache =\n      renderOpts.renderResumeDataCache ??\n      postponedState?.renderResumeDataCache ??\n      null\n\n    const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n    const devFallbackParams = getRequestMeta(req, 'devFallbackParams') || null\n\n    const createRequestStore = createRequestStoreForRender.bind(\n      null,\n      req,\n      res,\n      url,\n      rootParams,\n      implicitTags,\n      renderOpts.onUpdateCookies,\n      renderOpts.previewProps,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n      renderResumeDataCache,\n      devFallbackParams\n    )\n    const requestStore = createRequestStore()\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      renderOpts.setIsrStatus &&\n      !cacheComponents &&\n      // Only pages using the Node runtime can use ISR, so we only need to\n      // update the status for those.\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      const setIsrStatus = renderOpts.setIsrStatus\n      req.originalRequest.on('end', () => {\n        const { pathname } = new URL(req.url || '/', 'http://n')\n        const isStatic = !requestStore.usedDynamic && !workStore.forceDynamic\n        setIsrStatus(pathname, isStatic)\n      })\n    }\n\n    if (isRSCRequest) {\n      if (isRuntimePrefetchRequest) {\n        return generateRuntimePrefetchResult(req, ctx, requestStore)\n      } else {\n        if (\n          process.env.NODE_ENV === 'development' &&\n          process.env.NEXT_RUNTIME !== 'edge' &&\n          cacheComponents\n        ) {\n          return generateDynamicFlightRenderResultWithStagesInDev(\n            req,\n            ctx,\n            requestStore,\n            createRequestStore,\n            devFallbackParams\n          )\n        } else {\n          return generateDynamicFlightRenderResult(req, ctx, requestStore)\n        }\n      }\n    }\n\n    let didExecuteServerAction = false\n    let formState: null | any = null\n    if (isPossibleActionRequest) {\n      // For action requests, we don't want to use the resume data cache.\n      requestStore.renderResumeDataCache = null\n\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n        metadata,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          metadata.statusCode = 404\n          const stream = await renderToStream(\n            requestStore,\n            req,\n            res,\n            ctx,\n            notFoundLoaderTree,\n            formState,\n            postponedState,\n            metadata,\n            undefined, // Prevent restartable-render behavior in dev + Cache Components mode\n            devFallbackParams\n          )\n\n          return new RenderResult(stream, {\n            metadata,\n            contentType: HTML_CONTENT_TYPE_HEADER,\n          })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n\n      didExecuteServerAction = true\n      // Restore the resume data cache\n      requestStore.renderResumeDataCache = renderResumeDataCache\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n      contentType: HTML_CONTENT_TYPE_HEADER,\n    }\n\n    const stream = await renderToStream(\n      // NOTE: in Cache Components (dev), if the render is restarted, it will use a different requestStore\n      // than the one that we're passing in here.\n      requestStore,\n      req,\n      res,\n      ctx,\n      loaderTree,\n      formState,\n      postponedState,\n      metadata,\n      // If we're rendering HTML after an action, we don't want restartable-render behavior\n      // because the result should be dynamic, like it is in prod.\n      // Also, the request store might have been mutated by the action (e.g. enabling draftMode)\n      // and we currently we don't copy changes over when creating a new store,\n      // so the restarted render wouldn't be correct.\n      didExecuteServerAction ? undefined : createRequestStore,\n      devFallbackParams\n    )\n\n    // Invalid dynamic usages should only error the request in development.\n    // In production, it's better to produce a result.\n    // (the dynamic error will still be thrown inside the component tree, but it's catchable by error boundaries)\n    if (workStore.invalidDynamicUsageError && workStore.dev) {\n      throw workStore.invalidDynamicUsageError\n    }\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache,\n  sharedContext\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n    previewModeId: renderOpts.previewProps?.previewModeId,\n  })\n\n  const { isPrefetchRequest, previouslyRevalidatedTags, nonce } =\n    parsedRequestHeaders\n\n  let interpolatedParams: Params\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams) {\n      throw new InvariantError(\n        'postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    interpolatedParams = interpolateParallelRouteParams(\n      renderOpts.ComponentMod.routeModule.userland.loaderTree,\n      renderOpts.params ?? {},\n      pagePath,\n      fallbackRouteParams\n    )\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      interpolatedParams,\n      renderOpts.experimental.maxPostponedStateSizeBytes\n    )\n  } else {\n    interpolatedParams = interpolateParallelRouteParams(\n      renderOpts.ComponentMod.routeModule.userland.loaderTree,\n      renderOpts.params ?? {},\n      pagePath,\n      fallbackRouteParams\n    )\n  }\n\n  if (\n    postponedState?.renderResumeDataCache &&\n    renderOpts.renderResumeDataCache\n  ) {\n    throw new InvariantError(\n      'postponed state and dev warmup immutable resume data cache should not be provided together'\n    )\n  }\n\n  const workStore = createWorkStore({\n    page: renderOpts.routeModule.definition.page,\n    renderOpts,\n    // @TODO move to workUnitStore of type Request\n    isPrefetchRequest,\n    buildId: sharedContext.buildId,\n    previouslyRevalidatedTags,\n    nonce,\n  })\n\n  return workAsyncStorage.run(\n    workStore,\n    // The function to run\n    renderToHTMLOrFlightImpl,\n    // all of it's args\n    req,\n    res,\n    url,\n    pagePath,\n    query,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    postponedState,\n    serverComponentsHmrCache,\n    sharedContext,\n    interpolatedParams,\n    fallbackRouteParams\n  )\n}\n\nfunction applyMetadataFromPrerenderResult(\n  response: Pick<\n    PrerenderToStreamResult,\n    | 'collectedExpire'\n    | 'collectedRevalidate'\n    | 'collectedStale'\n    | 'collectedTags'\n  >,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore\n) {\n  if (response.collectedTags) {\n    metadata.fetchTags = response.collectedTags.join(',')\n  }\n\n  // Let the client router know how long to keep the cached entry around.\n  const staleHeader = String(response.collectedStale)\n  metadata.headers ??= {}\n  metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n  // If force static is specifically set to false, we should not revalidate\n  // the page.\n  if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n    metadata.cacheControl = { revalidate: 0, expire: undefined }\n  } else {\n    // Copy the cache control value onto the render result metadata.\n    metadata.cacheControl = {\n      revalidate:\n        response.collectedRevalidate >= INFINITE_CACHE\n          ? false\n          : response.collectedRevalidate,\n      expire:\n        response.collectedExpire >= INFINITE_CACHE\n          ? undefined\n          : response.collectedExpire,\n    }\n  }\n\n  // provide bailout info for debugging\n  if (metadata.cacheControl.revalidate === 0) {\n    metadata.staticBailoutInfo = {\n      description: workStore.dynamicUsageDescription,\n      stack: workStore.dynamicUsageStack,\n    }\n  }\n}\n\ntype RSCPayloadDevProperties = {\n  /** Only available during cacheComponents development builds. Used for logging errors. */\n  _validation?: Promise<ReactNode>\n  _bypassCachesInDev?: ReactNode\n}\n\ntype RSCInitialPayloadPartialDev = {\n  c?: InitialRSCPayload['c']\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null,\n  metadata: AppPageRenderResultMetadata,\n  createRequestStore: (() => RequestStore) | undefined,\n  devFallbackParams: OpaqueFallbackRouteParams | null\n): Promise<ReadableStream<Uint8Array>> {\n  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n  const {\n    assetPrefix,\n    htmlRequestId,\n    nonce,\n    pagePath,\n    renderOpts,\n    requestId,\n    workStore,\n  } = ctx\n\n  const {\n    basePath,\n    buildManifest,\n    ComponentMod: {\n      createElement,\n      renderToReadableStream: serverRenderToReadableStream,\n    },\n    crossOrigin,\n    dev = false,\n    experimental,\n    nextExport = false,\n    onInstrumentationRequestError,\n    page,\n    reactMaxHeadersLength,\n    setReactDebugChannel,\n    shouldWaitOnAllReady,\n    subresourceIntegrityManifest,\n    supportsDynamicResponse,\n    cacheComponents,\n  } = renderOpts\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const getServerInsertedMetadata = createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: subresourceIntegrityManifest?.[polyfill],\n        crossOrigin,\n        noModule: true,\n        nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    crossOrigin,\n    subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    page\n  )\n\n  // In development mode, set the request ID as a global variable, before the\n  // bootstrap script is executed, which depends on it during hydration.\n  const bootstrapScriptContent =\n    process.env.NODE_ENV !== 'production'\n      ? `self.__next_r=${JSON.stringify(requestId)}`\n      : undefined\n\n  // Create the \"render route (app)\" span manually so we can keep it open during streaming.\n  // This is necessary because errors inside Suspense boundaries are reported asynchronously\n  // during stream consumption, after a typical wrapped function would have ended the span.\n  // Note: We pass the full span name as the first argument since startSpan uses it directly.\n  const renderSpan = getTracer().startSpan(\n    `render route (app) ${pagePath}` as any,\n    {\n      attributes: {\n        'next.span_name': `render route (app) ${pagePath}`,\n        'next.span_type': AppRenderSpan.getBodyResult,\n        'next.route': pagePath,\n      },\n    }\n  )\n\n  // Helper to end the span with error status (used when throwing from catch blocks)\n  const endSpanWithError = (err: unknown) => {\n    if (!renderSpan.isRecording()) return\n    if (err instanceof Error) {\n      renderSpan.recordException(err)\n      renderSpan.setAttribute('error.type', err.name)\n    }\n    renderSpan.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: err instanceof Error ? err.message : undefined,\n    })\n    renderSpan.end()\n  }\n\n  // Run the rest of the function within the span's context so child spans\n  // (like \"build component tree\", \"generateMetadata\") are properly parented.\n  return getTracer().withSpan(renderSpan, async () => {\n    const { reactServerErrorsByDigest } = workStore\n    function onHTMLRenderRSCError(err: DigestedError, silenceLog: boolean) {\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'react-server-components'),\n        silenceLog\n      )\n    }\n    const serverComponentsErrorHandler = createReactServerErrorHandler(\n      dev,\n      nextExport,\n      reactServerErrorsByDigest,\n      onHTMLRenderRSCError,\n      renderSpan\n    )\n\n    function onHTMLRenderSSRError(err: DigestedError) {\n      // We don't need to silence logs here. onHTMLRenderSSRError won't be called\n      // at all if the error was logged before in the RSC error handler.\n      const silenceLog = false\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'server-rendering'),\n        silenceLog\n      )\n    }\n\n    const allCapturedErrors: Array<unknown> = []\n    const htmlRendererErrorHandler = createHTMLErrorHandler(\n      dev,\n      nextExport,\n      reactServerErrorsByDigest,\n      allCapturedErrors,\n      onHTMLRenderSSRError,\n      renderSpan\n    )\n\n    let reactServerResult: null | ReactServerResult = null\n    let reactDebugStream: ReadableStream<Uint8Array> | undefined\n\n    const setHeader = res.setHeader.bind(res)\n    const appendHeader = res.appendHeader.bind(res)\n    const { clientModules } = getClientReferenceManifest()\n\n    try {\n      if (\n        // We only want this behavior when we have React's dev builds available\n        process.env.NODE_ENV === 'development' &&\n        // We only want this behavior when running `next dev`\n        dev &&\n        // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        // We only have a Prerender environment for projects opted into cacheComponents\n        cacheComponents\n      ) {\n        let debugChannel: DebugChannelPair | undefined\n\n        const getPayload = async (\n          // eslint-disable-next-line @typescript-eslint/no-shadow\n          requestStore: RequestStore\n        ) => {\n          const payload: InitialRSCPayload & RSCPayloadDevProperties =\n            await workUnitAsyncStorage.run(\n              requestStore,\n              getRSCPayload,\n              tree,\n              ctx,\n              res.statusCode === 404\n            )\n\n          if (isBypassingCachesInDev(renderOpts, requestStore)) {\n            // Mark the RSC payload to indicate that caches were bypassed in dev.\n            // This lets the client know not to cache anything based on this render.\n            if (renderOpts.setCacheStatus) {\n              // we know this is available  when cacheComponents is enabled, but typeguard to be safe\n              renderOpts.setCacheStatus('bypass', htmlRequestId)\n            }\n            payload._bypassCachesInDev = createElement(\n              WarnForBypassCachesInDev,\n              {\n                route: workStore.route,\n              }\n            )\n          }\n\n          return payload\n        }\n\n        if (\n          // We only do this flow if we can safely recreate the store from scratch\n          // (which is not the case for renders after an action)\n          createRequestStore &&\n          // We only do this flow if we're not bypassing caches in dev using\n          // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n          !isBypassingCachesInDev(renderOpts, requestStore)\n        ) {\n          const {\n            stream: serverStream,\n            accumulatedChunksPromise,\n            staticInterruptReason,\n            runtimeInterruptReason,\n            staticStageEndTime,\n            runtimeStageEndTime,\n            debugChannel: returnedDebugChannel,\n            requestStore: finalRequestStore,\n          } = await renderWithRestartOnCacheMissInDev(\n            ctx,\n            requestStore,\n            createRequestStore,\n            getPayload,\n            serverComponentsErrorHandler\n          )\n\n          let validationDebugChannelClient: Readable | undefined = undefined\n          if (returnedDebugChannel) {\n            const [t1, t2] = returnedDebugChannel.clientSide.readable.tee()\n            returnedDebugChannel.clientSide.readable = t1\n            validationDebugChannelClient = nodeStreamFromReadableStream(t2)\n          }\n\n          consoleAsyncStorage.run(\n            { dim: true },\n            spawnStaticShellValidationInDev,\n            accumulatedChunksPromise,\n            staticInterruptReason,\n            runtimeInterruptReason,\n            staticStageEndTime,\n            runtimeStageEndTime,\n            ctx,\n            finalRequestStore,\n            devFallbackParams,\n            validationDebugChannelClient\n          )\n\n          reactServerResult = new ReactServerResult(serverStream)\n          requestStore = finalRequestStore\n          debugChannel = returnedDebugChannel\n        } else {\n          // We're either bypassing caches or we can't restart the render.\n          // Do a dynamic render, but with (basic) environment labels.\n\n          debugChannel = setReactDebugChannel && createDebugChannel()\n\n          const serverStream =\n            await stagedRenderToReadableStreamWithoutCachesInDev(\n              ctx,\n              requestStore,\n              getPayload,\n              {\n                onError: serverComponentsErrorHandler,\n                filterStackFrame,\n                debugChannel: debugChannel?.serverSide,\n              }\n            )\n          reactServerResult = new ReactServerResult(serverStream)\n        }\n\n        if (debugChannel && setReactDebugChannel) {\n          const [readableSsr, readableBrowser] =\n            debugChannel.clientSide.readable.tee()\n\n          reactDebugStream = readableSsr\n\n          setReactDebugChannel(\n            { readable: readableBrowser },\n            htmlRequestId,\n            requestId\n          )\n        }\n      } else {\n        // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n        const RSCPayload: RSCPayload & RSCPayloadDevProperties =\n          await workUnitAsyncStorage.run(\n            requestStore,\n            getRSCPayload,\n            tree,\n            ctx,\n            res.statusCode === 404\n          )\n\n        const debugChannel = setReactDebugChannel && createDebugChannel()\n\n        if (debugChannel) {\n          const [readableSsr, readableBrowser] =\n            debugChannel.clientSide.readable.tee()\n\n          reactDebugStream = readableSsr\n\n          setReactDebugChannel(\n            { readable: readableBrowser },\n            htmlRequestId,\n            requestId\n          )\n        }\n\n        reactServerResult = new ReactServerResult(\n          workUnitAsyncStorage.run(\n            requestStore,\n            serverRenderToReadableStream,\n            RSCPayload,\n            clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n              debugChannel: debugChannel?.serverSide,\n            }\n          )\n        )\n      }\n\n      // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n      // before we begin SSR rendering because we want to capture any available preload headers so we tick\n      // one task before continuing\n      await waitAtLeastOneReactRenderTask()\n\n      // If provided, the postpone state should be parsed as JSON so it can be\n      // provided to React.\n      if (typeof renderOpts.postponed === 'string') {\n        if (postponedState?.type === DynamicState.DATA) {\n          // We have a complete HTML Document in the prerender but we need to\n          // still include the new server component render because it was not included\n          // in the static prelude.\n          const inlinedReactServerDataStream = createInlinedDataReadableStream(\n            reactServerResult.tee(),\n            nonce,\n            formState\n          )\n\n          // End the span since there's no async rendering in this path\n          if (renderSpan.isRecording()) renderSpan.end()\n          return chainStreams(\n            inlinedReactServerDataStream,\n            createDocumentClosingStream()\n          )\n        } else if (postponedState) {\n          // We assume we have dynamic HTML requiring a resume render to complete\n          const { postponed, preludeState } =\n            getPostponedFromState(postponedState)\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          const htmlStream = await workUnitAsyncStorage.run(\n            requestStore,\n            resume,\n            <App\n              reactServerStream={reactServerResult.tee()}\n              reactDebugStream={reactDebugStream}\n              debugEndTime={undefined}\n              preinitScripts={preinitScripts}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            postponed,\n            { onError: htmlRendererErrorHandler, nonce }\n          )\n\n          // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n          htmlStream.allReady.finally(() => {\n            if (renderSpan.isRecording()) renderSpan.end()\n          })\n\n          const getServerInsertedHTML = makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: allCapturedErrors,\n            basePath,\n            tracingMetadata: tracingMetadata,\n          })\n          return await continueDynamicHTMLResume(htmlStream, {\n            // If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered\n            // to avoid injecting RSC data too early.\n            // If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,\n            // so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.\n            delayDataUntilFirstHtmlChunk:\n              preludeState === DynamicHTMLPreludeState.Empty,\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consume(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          })\n        }\n      }\n\n      // This is a regular dynamic render\n      const renderToReadableStream = (\n        require('react-dom/server') as typeof import('react-dom/server')\n      ).renderToReadableStream\n\n      const htmlStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.tee()}\n          reactDebugStream={reactDebugStream}\n          debugEndTime={undefined}\n          preinitScripts={preinitScripts}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={nonce}\n          images={ctx.renderOpts.images}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              appendHeader(key, value)\n            })\n          },\n          maxHeadersLength: reactMaxHeadersLength,\n          bootstrapScriptContent,\n          bootstrapScripts: [bootstrapScript],\n          formState,\n        }\n      )\n\n      // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n      htmlStream.allReady.finally(() => {\n        if (renderSpan.isRecording()) renderSpan.end()\n      })\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n       *\n       *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *       resolve all suspenses and generate a full HTML. e.g. when it's a\n       *       html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML =\n        supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n\n      return await continueFizzStream(htmlStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          reactServerResult.consume(),\n          nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n        buildId: ctx.workStore.buildId,\n        getServerInsertedHTML,\n        getServerInsertedMetadata,\n        validateRootLayout: dev,\n      })\n    } catch (err) {\n      if (\n        isStaticGenBailoutError(err) ||\n        (typeof err === 'object' &&\n          err !== null &&\n          'message' in err &&\n          typeof err.message === 'string' &&\n          err.message.includes(\n            'https://nextjs.org/docs/advanced-features/static-html-export'\n          ))\n      ) {\n        // Ensure that \"next dev\" prints the red error overlay\n        endSpanWithError(err)\n        throw err\n      }\n\n      // If a bailout made it to this point, it means it wasn't wrapped inside\n      // a suspense boundary.\n      const shouldBailoutToCSR = isBailoutToCSRError(err)\n      if (shouldBailoutToCSR) {\n        const stack = getStackWithoutErrorMessage(err)\n        error(\n          `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n        )\n\n        endSpanWithError(err)\n        throw err\n      }\n\n      let errorType: MetadataErrorType | 'redirect' | undefined\n\n      if (isHTTPAccessFallbackError(err)) {\n        res.statusCode = getAccessFallbackHTTPStatus(err)\n        metadata.statusCode = res.statusCode\n        errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n      } else if (isRedirectError(err)) {\n        errorType = 'redirect'\n        res.statusCode = getRedirectStatusCodeFromError(err)\n        metadata.statusCode = res.statusCode\n\n        const redirectUrl = addPathPrefix(\n          getURLFromRedirectError(err),\n          basePath\n        )\n\n        // If there were mutable cookies set, we need to set them on the\n        // response.\n        const headers = new Headers()\n        if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n          setHeader('set-cookie', Array.from(headers.values()))\n        }\n\n        setHeader('location', redirectUrl)\n      } else if (!shouldBailoutToCSR) {\n        res.statusCode = 500\n        metadata.statusCode = res.statusCode\n      }\n\n      const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n        buildManifest,\n        assetPrefix,\n        crossOrigin,\n        subresourceIntegrityManifest,\n        getAssetQueryString(ctx, false),\n        nonce,\n        '/_not-found/page'\n      )\n\n      let errorRSCPayload: InitialRSCPayload\n      let errorServerStream: ReturnType<typeof serverRenderToReadableStream>\n\n      try {\n        errorRSCPayload = await workUnitAsyncStorage.run(\n          requestStore,\n          getErrorRSCPayload,\n          tree,\n          ctx,\n          reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n          errorType\n        )\n\n        errorServerStream = workUnitAsyncStorage.run(\n          requestStore,\n          serverRenderToReadableStream,\n          errorRSCPayload,\n          clientModules,\n          {\n            filterStackFrame,\n            onError: serverComponentsErrorHandler,\n          }\n        )\n\n        if (reactServerResult === null) {\n          // We errored when we did not have an RSC stream to read from. This is not just a render\n          // error, we need to throw early\n          endSpanWithError(err)\n          throw err\n        }\n      } catch (setupErr) {\n        endSpanWithError(setupErr)\n        throw setupErr\n      }\n\n      try {\n        const fizzStream = await workUnitAsyncStorage.run(\n          requestStore,\n          renderToInitialFizzStream,\n          {\n            ReactDOMServer:\n              require('react-dom/server') as typeof import('react-dom/server'),\n            element: (\n              <ErrorApp\n                reactServerStream={errorServerStream}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                preinitScripts={errorPreinitScripts}\n                nonce={nonce}\n                images={ctx.renderOpts.images}\n              />\n            ),\n            streamOptions: {\n              nonce,\n              bootstrapScriptContent,\n              // Include hydration scripts in the HTML\n              bootstrapScripts: [errorBootstrapScript],\n              formState,\n            },\n          }\n        )\n\n        // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n        fizzStream.allReady.finally(() => {\n          if (renderSpan.isRecording()) renderSpan.end()\n        })\n\n        /**\n         * Rules of Static & Dynamic HTML:\n         *\n         *    1.) We must generate static HTML unless the caller explicitly opts\n         *        in to dynamic HTML support.\n         *\n         *    2.) If dynamic HTML support is requested, we must honor that request\n         *        or throw an error. It is the sole responsibility of the caller to\n         *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n         *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n         *        resolve all suspenses and generate a full HTML. e.g. when it's a\n         *        html limited bot requests, we produce the full HTML content.\n         *\n         * These rules help ensure that other existing features like request caching,\n         * coalescing, and ISR continue working as intended.\n         */\n        const generateStaticHTML =\n          supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n        return await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            // This is intentionally using the readable datastream from the\n            // main render rather than the flight data from the error page\n            // render\n            reactServerResult.consume(),\n            nonce,\n            formState\n          ),\n          isStaticGeneration: generateStaticHTML,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout: dev,\n        })\n      } catch (finalErr: any) {\n        if (\n          process.env.NODE_ENV === 'development' &&\n          isHTTPAccessFallbackError(finalErr)\n        ) {\n          const { bailOnRootNotFound } =\n            require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n          bailOnRootNotFound()\n        }\n        endSpanWithError(finalErr)\n        throw finalErr\n      }\n    }\n  })\n  /* eslint-enable @next/internal/no-ambiguous-jsx */\n}\n\nasync function renderWithRestartOnCacheMissInDev(\n  ctx: AppRenderContext,\n  initialRequestStore: RequestStore,\n  createRequestStore: () => RequestStore,\n  getPayload: (requestStore: RequestStore) => Promise<RSCPayload>,\n  onError: (error: unknown) => void\n) {\n  const {\n    htmlRequestId,\n    renderOpts,\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n    },\n  } = ctx\n\n  const { ComponentMod, setCacheStatus, setReactDebugChannel } = renderOpts\n\n  const hasRuntimePrefetch =\n    await anySegmentHasRuntimePrefetchEnabled(loaderTree)\n\n  // If the render is restarted, we'll recreate a fresh request store\n  let requestStore: RequestStore = initialRequestStore\n\n  const environmentName = () => {\n    const currentStage = requestStore.stagedRendering!.currentStage\n    switch (currentStage) {\n      case RenderStage.Before:\n      case RenderStage.Static:\n        return 'Prerender'\n      case RenderStage.Runtime:\n        return hasRuntimePrefetch ? 'Prefetch' : 'Prefetchable'\n      case RenderStage.Dynamic:\n      case RenderStage.Abandoned:\n        return 'Server'\n      default:\n        currentStage satisfies never\n        throw new InvariantError(`Invalid render stage: ${currentStage}`)\n    }\n  }\n\n  //===============================================\n  // Initial render\n  //===============================================\n\n  // Try to render the page and see if there's any cache misses.\n  // If there are, wait for caches to finish and restart the render.\n\n  // This render might end up being used as a prospective render (if there's cache misses),\n  // so we need to set it up for filling caches.\n  const cacheSignal = new CacheSignal()\n\n  // If we encounter async modules that delay rendering, we'll also need to restart.\n  // TODO(restart-on-cache-miss): technically, we only need to wait for pending *server* modules here,\n  // but `trackPendingModules` doesn't distinguish between client and server.\n  trackPendingModules(cacheSignal)\n\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n  const initialReactController = new AbortController()\n  const initialDataController = new AbortController() // Controls hanging promises we create\n  const initialStageController = new StagedRenderingController(\n    initialDataController.signal,\n    hasRuntimePrefetch\n  )\n\n  requestStore.prerenderResumeDataCache = prerenderResumeDataCache\n  // `getRenderResumeDataCache` will fall back to using `prerenderResumeDataCache` as `renderResumeDataCache`,\n  // so not having a resume data cache won't break any expectations in case we don't need to restart.\n  requestStore.renderResumeDataCache = null\n  requestStore.stagedRendering = initialStageController\n  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n    initialStageController,\n    requestStore.cookies,\n    requestStore.mutableCookies,\n    requestStore.headers\n  )\n  requestStore.cacheSignal = cacheSignal\n\n  let debugChannel = setReactDebugChannel && createDebugChannel()\n  const { clientModules } = getClientReferenceManifest()\n\n  // Note: The stage controller starts out in the `Before` stage,\n  // where sync IO does not cause aborts, so it's okay if it happens before render.\n  const initialRscPayload = await getPayload(requestStore)\n\n  const maybeInitialStreamResult = await workUnitAsyncStorage.run(\n    requestStore,\n    () =>\n      pipelineInSequentialTasks(\n        () => {\n          // Static stage\n          initialStageController.advanceStage(RenderStage.Static)\n\n          const stream = ComponentMod.renderToReadableStream(\n            initialRscPayload,\n            clientModules,\n            {\n              onError,\n              environmentName,\n              filterStackFrame,\n              debugChannel: debugChannel?.serverSide,\n              signal: initialReactController.signal,\n            }\n          )\n          // If we abort the render, we want to reject the stage-dependent promises as well.\n          // Note that we want to install this listener after the render is started\n          // so that it runs after react is finished running its abort code.\n          initialReactController.signal.addEventListener('abort', () => {\n            initialDataController.abort(initialReactController.signal.reason)\n          })\n\n          const [continuationStream, accumulatingStream] = stream.tee()\n          const accumulatedChunksPromise = accumulateStreamChunks(\n            accumulatingStream,\n            initialStageController,\n            initialDataController.signal\n          )\n          return { stream: continuationStream, accumulatedChunksPromise }\n        },\n        ({ stream, accumulatedChunksPromise }) => {\n          // Runtime stage\n\n          if (initialStageController.currentStage === RenderStage.Abandoned) {\n            // If we abandoned the render in the static stage, we won't proceed further.\n            return null\n          }\n\n          // If we had a cache miss in the static stage, we'll have to discard this stream\n          // and render again once the caches are warm.\n          // If we already advanced stages we similarly had sync IO that might be from module loading\n          // and need to render again once the caches are warm.\n          if (cacheSignal.hasPendingReads()) {\n            // Regardless of whether we are going to abandon this\n            // render we need the unblock runtime b/c it's essential\n            // filling caches.\n            initialStageController.abandonRender()\n            return null\n          }\n\n          initialStageController.advanceStage(RenderStage.Runtime)\n          return { stream, accumulatedChunksPromise }\n        },\n        (result) => {\n          // Dynamic stage\n          if (\n            result === null ||\n            initialStageController.currentStage === RenderStage.Abandoned\n          ) {\n            // If we abandoned the render in the static or runtime stage, we won't proceed further.\n            return null\n          }\n\n          // If we had cache misses in either of the previous stages,\n          // then we'll only use this render for filling caches.\n          // We won't advance the stage, and thus leave dynamic APIs hanging,\n          // because they won't be cached anyway, so it'd be wasted work.\n          if (cacheSignal.hasPendingReads()) {\n            initialStageController.abandonRender()\n            return null\n          }\n\n          // Regardless of whether we are going to abandon this\n          // render we need the unblock runtime b/c it's essential\n          // filling caches.\n          initialStageController.advanceStage(RenderStage.Dynamic)\n          return result\n        }\n      )\n  )\n\n  if (maybeInitialStreamResult !== null) {\n    // No cache misses. We can use the result as-is.\n    return {\n      stream: maybeInitialStreamResult.stream,\n      accumulatedChunksPromise:\n        maybeInitialStreamResult.accumulatedChunksPromise,\n      staticInterruptReason: initialStageController.getStaticInterruptReason(),\n      runtimeInterruptReason:\n        initialStageController.getRuntimeInterruptReason(),\n      staticStageEndTime: initialStageController.getStaticStageEndTime(),\n      runtimeStageEndTime: initialStageController.getRuntimeStageEndTime(),\n      debugChannel,\n      requestStore,\n    }\n  }\n\n  if (process.env.NODE_ENV === 'development' && setCacheStatus) {\n    setCacheStatus('filling', htmlRequestId)\n  }\n\n  // Cache miss. We will use the initial render to fill caches, and discard its result.\n  // Then, we can render again with warm caches.\n\n  // TODO(restart-on-cache-miss):\n  // This might end up waiting for more caches than strictly necessary,\n  // because we can't abort the render yet, and we'll let runtime/dynamic APIs resolve.\n  // Ideally we'd only wait for caches that are needed in the static stage.\n  // This will be optimized in the future by not allowing runtime/dynamic APIs to resolve.\n\n  await cacheSignal.cacheReady()\n  initialReactController.abort()\n\n  //===============================================\n  // Final render (restarted)\n  //===============================================\n\n  // The initial render acted as a prospective render to warm the caches.\n  requestStore = createRequestStore()\n\n  // We are going to render this pass all the way through because we've already\n  // filled any caches so we won't be aborting this time.\n  const abortSignal = null\n  const finalStageController = new StagedRenderingController(\n    abortSignal,\n    hasRuntimePrefetch\n  )\n\n  // We've filled the caches, so now we can render as usual,\n  // without any cache-filling mechanics.\n  requestStore.prerenderResumeDataCache = null\n  requestStore.renderResumeDataCache = createRenderResumeDataCache(\n    prerenderResumeDataCache\n  )\n  requestStore.stagedRendering = finalStageController\n  requestStore.cacheSignal = null\n  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n    finalStageController,\n    requestStore.cookies,\n    requestStore.mutableCookies,\n    requestStore.headers\n  )\n\n  // The initial render already wrote to its debug channel.\n  // We're not using it, so we need to create a new one.\n  debugChannel = setReactDebugChannel && createDebugChannel()\n\n  // Note: The stage controller starts out in the `Before` stage,\n  // where sync IO does not cause aborts, so it's okay if it happens before render.\n  const finalRscPayload = await getPayload(requestStore)\n\n  const finalStreamResult = await workUnitAsyncStorage.run(requestStore, () =>\n    pipelineInSequentialTasks(\n      () => {\n        // Static stage\n        finalStageController.advanceStage(RenderStage.Static)\n\n        const stream = ComponentMod.renderToReadableStream(\n          finalRscPayload,\n          clientModules,\n          {\n            onError,\n            environmentName,\n            filterStackFrame,\n            debugChannel: debugChannel?.serverSide,\n          }\n        )\n\n        const [continuationStream, accumulatingStream] = stream.tee()\n        const accumulatedChunksPromise = accumulateStreamChunks(\n          accumulatingStream,\n          finalStageController,\n          null\n        )\n        return { stream: continuationStream, accumulatedChunksPromise }\n      },\n      (result) => {\n        // Runtime stage\n        finalStageController.advanceStage(RenderStage.Runtime)\n        return result\n      },\n      (result) => {\n        // Dynamic stage\n        finalStageController.advanceStage(RenderStage.Dynamic)\n        return result\n      }\n    )\n  )\n\n  if (process.env.NODE_ENV === 'development' && setCacheStatus) {\n    setCacheStatus('filled', htmlRequestId)\n  }\n\n  return {\n    stream: finalStreamResult.stream,\n    accumulatedChunksPromise: finalStreamResult.accumulatedChunksPromise,\n    staticInterruptReason: finalStageController.getStaticInterruptReason(),\n    runtimeInterruptReason: finalStageController.getRuntimeInterruptReason(),\n    staticStageEndTime: finalStageController.getStaticStageEndTime(),\n    runtimeStageEndTime: finalStageController.getRuntimeStageEndTime(),\n    debugChannel,\n    requestStore,\n  }\n}\n\ninterface AccumulatedStreamChunks {\n  readonly staticChunks: Array<Uint8Array>\n  readonly runtimeChunks: Array<Uint8Array>\n  readonly dynamicChunks: Array<Uint8Array>\n}\n\nasync function accumulateStreamChunks(\n  stream: ReadableStream<Uint8Array>,\n  stageController: StagedRenderingController,\n  signal: AbortSignal | null\n): Promise<AccumulatedStreamChunks> {\n  const staticChunks: Array<Uint8Array> = []\n  const runtimeChunks: Array<Uint8Array> = []\n  const dynamicChunks: Array<Uint8Array> = []\n  const reader = stream.getReader()\n\n  let cancelled = false\n  function cancel() {\n    if (!cancelled) {\n      cancelled = true\n      reader.cancel()\n    }\n  }\n\n  if (signal) {\n    signal.addEventListener('abort', cancel, { once: true })\n  }\n\n  try {\n    while (!cancelled) {\n      const { done, value } = await reader.read()\n      if (done) {\n        cancel()\n        break\n      }\n      switch (stageController.currentStage) {\n        case RenderStage.Before:\n          throw new InvariantError(\n            'Unexpected stream chunk while in Before stage'\n          )\n        case RenderStage.Static:\n          staticChunks.push(value)\n        // fall through\n        case RenderStage.Runtime:\n          runtimeChunks.push(value)\n        // fall through\n        case RenderStage.Dynamic:\n          dynamicChunks.push(value)\n          break\n        case RenderStage.Abandoned:\n          // If the render was abandoned, we won't use the chunks,\n          // so there's no need to accumulate them\n          break\n        default:\n          stageController.currentStage satisfies never\n          break\n      }\n    }\n  } catch {\n    // When we release the lock we may reject the read\n  }\n\n  return { staticChunks, runtimeChunks, dynamicChunks }\n}\n\nfunction createAsyncApiPromisesInDev(\n  stagedRendering: StagedRenderingController,\n  cookies: RequestStore['cookies'],\n  mutableCookies: RequestStore['mutableCookies'],\n  headers: RequestStore['headers']\n): NonNullable<RequestStore['asyncApiPromises']> {\n  return {\n    // Runtime APIs\n    cookies: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      'cookies',\n      cookies\n    ),\n    mutableCookies: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      'cookies',\n      mutableCookies as RequestStore['cookies']\n    ),\n    headers: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      'headers',\n      headers\n    ),\n    // These are not used directly, but we chain other `params`/`searchParams` promises off of them.\n    sharedParamsParent: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      undefined,\n      '<internal params>'\n    ),\n    sharedSearchParamsParent: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      undefined,\n      '<internal searchParams>'\n    ),\n    connection: stagedRendering.delayUntilStage(\n      RenderStage.Dynamic,\n      'connection',\n      undefined\n    ),\n  }\n}\n\ntype DebugChannelPair = {\n  serverSide: DebugChannelServer\n  clientSide: DebugChannelClient\n}\n\ntype DebugChannelServer = {\n  readable?: ReadableStream<Uint8Array>\n  writable: WritableStream<Uint8Array>\n}\ntype DebugChannelClient = {\n  readable: ReadableStream<Uint8Array>\n  writable?: WritableStream<Uint8Array>\n}\n\nfunction createDebugChannel(): DebugChannelPair | undefined {\n  if (process.env.NODE_ENV === 'production') {\n    return undefined\n  }\n\n  let readableController: ReadableStreamDefaultController | undefined\n\n  let clientSideReadable = new ReadableStream<Uint8Array>({\n    start(controller) {\n      readableController = controller\n    },\n  })\n\n  return {\n    serverSide: {\n      writable: new WritableStream<Uint8Array>({\n        write(chunk) {\n          readableController?.enqueue(chunk)\n        },\n        close() {\n          readableController?.close()\n        },\n        abort(err) {\n          readableController?.error(err)\n        },\n      }),\n    },\n    clientSide: { readable: clientSideReadable },\n  }\n}\n\n/**\n * Logs the given messages, and sends the error instances to the browser as an\n * RSC stream, where they can be deserialized and logged (or otherwise presented\n * in the devtools), while leveraging React's capabilities to not only\n * source-map the stack frames (via findSourceMapURL), but also create virtual\n * server modules that allow users to inspect the server source code in the\n * browser.\n */\nasync function logMessagesAndSendErrorsToBrowser(\n  messages: unknown[],\n  ctx: AppRenderContext\n): Promise<void> {\n  const { componentMod: ComponentMod, htmlRequestId, renderOpts } = ctx\n  const { sendErrorsToBrowser } = renderOpts\n\n  const errors: Error[] = []\n  for (const message of messages) {\n    // Log the error to the CLI. Prevent the logs from being dimmed, which we\n    // apply for other logs during the spawned validation.\n    consoleAsyncStorage.exit(() => {\n      console.error(message)\n    })\n\n    // Error instances are also sent to the browser. We're currently using a\n    // non-Error message only in debug build mode as a message that is only\n    // meant for the CLI. FIXME: This is a bit spooky action at a distance. We\n    // should maybe have a more explicit way of determining which messages\n    // should be sent to the browser. Regardless, only real errors with a proper\n    // stack make sense to be \"replayed\" in the browser.\n    if (message instanceof Error) {\n      errors.push(message)\n    }\n  }\n\n  if (errors.length > 0) {\n    if (!sendErrorsToBrowser) {\n      throw new InvariantError(\n        'Expected `sendErrorsToBrowser` to be defined in renderOpts.'\n      )\n    }\n\n    const { clientModules } = getClientReferenceManifest()\n\n    const errorsRscStream = ComponentMod.renderToReadableStream(\n      errors,\n      clientModules,\n      { filterStackFrame }\n    )\n\n    sendErrorsToBrowser(errorsRscStream, htmlRequestId)\n  }\n}\n\n/**\n * This function is a fork of prerenderToStream cacheComponents branch.\n * While it doesn't return a stream we want it to have identical\n * prerender semantics to prerenderToStream and should update it\n * in conjunction with any changes to that function.\n */\nasync function spawnStaticShellValidationInDev(\n  accumulatedChunksPromise: Promise<AccumulatedStreamChunks>,\n  staticInterruptReason: Error | null,\n  runtimeInterruptReason: Error | null,\n  staticStageEndTime: number,\n  runtimeStageEndTime: number,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  debugChannelClient: Readable | undefined\n): Promise<void> {\n  const {\n    componentMod: ComponentMod,\n    getDynamicParamFromSegment,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  const { allowEmptyStaticShell = false } = renderOpts\n\n  const rootParams = getRootParams(\n    ComponentMod.routeModule.userland.loaderTree,\n    getDynamicParamFromSegment\n  )\n\n  const hmrRefreshHash = getHmrRefreshHash(workStore, requestStore)\n\n  // We don't need to continue the prerender process if we already\n  // detected invalid dynamic usage in the initial prerender phase.\n  const { invalidDynamicUsageError } = workStore\n  if (invalidDynamicUsageError) {\n    return logMessagesAndSendErrorsToBrowser([invalidDynamicUsageError], ctx)\n  }\n\n  if (staticInterruptReason) {\n    return logMessagesAndSendErrorsToBrowser([staticInterruptReason], ctx)\n  }\n\n  if (runtimeInterruptReason) {\n    return logMessagesAndSendErrorsToBrowser([runtimeInterruptReason], ctx)\n  }\n\n  const { staticChunks, runtimeChunks, dynamicChunks } =\n    await accumulatedChunksPromise\n\n  // First we warmup SSR with the runtime chunks. This ensures that when we do\n  // the full prerender pass with dynamic tracking module loading won't\n  // interrupt the prerender and can properly observe the entire content\n  await warmupModuleCacheForRuntimeValidationInDev(\n    runtimeChunks,\n    dynamicChunks,\n    rootParams,\n    fallbackRouteParams,\n    allowEmptyStaticShell,\n    ctx\n  )\n\n  let debugChunks: Uint8Array[] | null = null\n  if (debugChannelClient) {\n    debugChunks = []\n    debugChannelClient.on('data', (c) => debugChunks!.push(c))\n  }\n\n  const runtimeResult = await validateStagedShell(\n    runtimeChunks,\n    dynamicChunks,\n    debugChunks,\n    runtimeStageEndTime,\n    rootParams,\n    fallbackRouteParams,\n    allowEmptyStaticShell,\n    ctx,\n    hmrRefreshHash,\n    trackDynamicHoleInRuntimeShell\n  )\n\n  if (runtimeResult.length > 0) {\n    // We have something to report from the runtime validation\n    // We can skip the static validation\n    return logMessagesAndSendErrorsToBrowser(runtimeResult, ctx)\n  }\n\n  const staticResult = await validateStagedShell(\n    staticChunks,\n    dynamicChunks,\n    debugChunks,\n    staticStageEndTime,\n    rootParams,\n    fallbackRouteParams,\n    allowEmptyStaticShell,\n    ctx,\n    hmrRefreshHash,\n    trackDynamicHoleInStaticShell\n  )\n\n  return logMessagesAndSendErrorsToBrowser(staticResult, ctx)\n}\n\nasync function warmupModuleCacheForRuntimeValidationInDev(\n  runtimeServerChunks: Array<Uint8Array>,\n  allServerChunks: Array<Uint8Array>,\n  rootParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  allowEmptyStaticShell: boolean,\n  ctx: AppRenderContext\n) {\n  const { implicitTags, nonce, workStore } = ctx\n\n  // Warmup SSR\n  const initialClientPrerenderController = new AbortController()\n  const initialClientReactController = new AbortController()\n  const initialClientRenderController = new AbortController()\n\n  const preinitScripts = () => {}\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n\n  const initialClientPrerenderStore: PrerenderStore = {\n    type: 'prerender-client',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    renderSignal: initialClientRenderController.signal,\n    controller: initialClientPrerenderController,\n    // For HTML Generation the only cache tracked activity\n    // is module loading, which has it's own cache signal\n    cacheSignal: null,\n    dynamicTracking: null,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    // TODO should this be removed from client stores?\n    prerenderResumeDataCache: null,\n    renderResumeDataCache: null,\n    hmrRefreshHash: undefined,\n  }\n\n  const runtimeServerStream = createNodeStreamFromChunks(\n    runtimeServerChunks,\n    allServerChunks,\n    initialClientReactController.signal\n  )\n\n  const prerender = (\n    require('react-dom/static') as typeof import('react-dom/static')\n  ).prerender\n  const pendingInitialClientResult = workUnitAsyncStorage.run(\n    initialClientPrerenderStore,\n    prerender,\n    // eslint-disable-next-line @next/internal/no-ambiguous-jsx -- React Client\n    <App\n      reactServerStream={runtimeServerStream}\n      reactDebugStream={undefined}\n      debugEndTime={undefined}\n      preinitScripts={preinitScripts}\n      ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n      nonce={nonce}\n      images={ctx.renderOpts.images}\n    />,\n    {\n      signal: initialClientReactController.signal,\n      onError: (err) => {\n        const digest = getDigestForWellKnownError(err)\n\n        if (digest) {\n          return digest\n        }\n\n        if (isReactLargeShellError(err)) {\n          // TODO: Aggregate\n          console.error(err)\n          return undefined\n        }\n\n        if (initialClientReactController.signal.aborted) {\n          // These are expected errors that might error the prerender. we ignore them.\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          // We don't normally log these errors because we are going to retry anyway but\n          // it can be useful for debugging Next.js itself to get visibility here when needed\n          printDebugThrownValueForProspectiveRender(\n            err,\n            workStore.route,\n            Phase.ProspectiveRender\n          )\n        }\n      },\n      // We don't need bootstrap scripts in this prerender\n      // bootstrapScripts: [bootstrapScript],\n    }\n  )\n\n  // The listener to abort our own render controller must be added after React\n  // has added its listener, to ensure that pending I/O is not\n  // aborted/rejected too early.\n  initialClientReactController.signal.addEventListener(\n    'abort',\n    () => {\n      initialClientRenderController.abort()\n    },\n    { once: true }\n  )\n\n  pendingInitialClientResult.catch((err) => {\n    if (\n      initialClientReactController.signal.aborted ||\n      isPrerenderInterruptedError(err)\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(\n        err,\n        workStore.route,\n        Phase.ProspectiveRender\n      )\n    }\n  })\n\n  // This is mostly needed for dynamic `import()`s in client components.\n  // Promises passed to client were already awaited above (assuming that they came from cached functions)\n  const cacheSignal = new CacheSignal()\n  trackPendingModules(cacheSignal)\n  await cacheSignal.cacheReady()\n  initialClientReactController.abort()\n}\n\nasync function validateStagedShell(\n  stageChunks: Array<Uint8Array>,\n  allServerChunks: Array<Uint8Array>,\n  debugChunks: null | Array<Uint8Array>,\n  debugEndTime: number | undefined,\n  rootParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  allowEmptyStaticShell: boolean,\n  ctx: AppRenderContext,\n  hmrRefreshHash: string | undefined,\n  trackDynamicHole:\n    | typeof trackDynamicHoleInStaticShell\n    | typeof trackDynamicHoleInRuntimeShell\n): Promise<Array<unknown>> {\n  const { implicitTags, nonce, workStore } = ctx\n\n  const clientDynamicTracking = createDynamicTrackingState(\n    false //isDebugDynamicAccesses\n  )\n  const clientReactController = new AbortController()\n  const clientRenderController = new AbortController()\n\n  const preinitScripts = () => {}\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n\n  const finalClientPrerenderStore: PrerenderStore = {\n    type: 'prerender-client',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    renderSignal: clientRenderController.signal,\n    controller: clientReactController,\n    // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n    cacheSignal: null,\n    dynamicTracking: clientDynamicTracking,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    // TODO should this be removed from client stores?\n    prerenderResumeDataCache: null,\n    renderResumeDataCache: null,\n    hmrRefreshHash,\n  }\n\n  let runtimeDynamicValidation = createDynamicValidationState()\n\n  const serverStream = createNodeStreamFromChunks(\n    stageChunks,\n    allServerChunks,\n    clientReactController.signal\n  )\n\n  const debugChannelClient = debugChunks\n    ? createNodeStreamFromChunks(\n        debugChunks,\n        debugChunks,\n        clientReactController.signal\n      )\n    : undefined\n\n  const prerender = (\n    require('react-dom/static') as typeof import('react-dom/static')\n  ).prerender\n  try {\n    let { prelude: unprocessedPrelude } =\n      await prerenderAndAbortInSequentialTasks(\n        () => {\n          const pendingFinalClientResult = workUnitAsyncStorage.run(\n            finalClientPrerenderStore,\n            prerender,\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx -- React Client\n            <App\n              reactServerStream={serverStream}\n              reactDebugStream={debugChannelClient}\n              debugEndTime={debugEndTime}\n              preinitScripts={preinitScripts}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            {\n              signal: clientReactController.signal,\n              onError: (err: unknown, errorInfo: ErrorInfo) => {\n                if (\n                  isPrerenderInterruptedError(err) ||\n                  clientReactController.signal.aborted\n                ) {\n                  const componentStack = errorInfo.componentStack\n                  if (typeof componentStack === 'string') {\n                    trackDynamicHole(\n                      workStore,\n                      componentStack,\n                      runtimeDynamicValidation,\n                      clientDynamicTracking\n                    )\n                  }\n                  return\n                }\n\n                if (isReactLargeShellError(err)) {\n                  // TODO: Aggregate\n                  console.error(err)\n                  return undefined\n                }\n\n                return getDigestForWellKnownError(err)\n              },\n              // We don't need bootstrap scripts in this prerender\n              // bootstrapScripts: [bootstrapScript],\n            }\n          )\n\n          // The listener to abort our own render controller must be added after\n          // React has added its listener, to ensure that pending I/O is not\n          // aborted/rejected too early.\n          clientReactController.signal.addEventListener(\n            'abort',\n            () => {\n              clientRenderController.abort()\n            },\n            { once: true }\n          )\n\n          return pendingFinalClientResult\n        },\n        () => {\n          clientReactController.abort()\n        }\n      )\n\n    const { preludeIsEmpty } = await processPrelude(unprocessedPrelude)\n    return getStaticShellDisallowedDynamicReasons(\n      workStore,\n      preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,\n      runtimeDynamicValidation\n    )\n  } catch (thrownValue) {\n    // Even if the root errors we still want to report any cache components errors\n    // that were discovered before the root errored.\n    let errors: Array<unknown> = getStaticShellDisallowedDynamicReasons(\n      workStore,\n      PreludeState.Errored,\n      runtimeDynamicValidation\n    )\n\n    if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n      errors.unshift(\n        'During dynamic validation the root of the page errored. The next logged error is the thrown value. It may be a duplicate of errors reported during the normal development mode render.',\n        thrownValue\n      )\n    }\n\n    return errors\n  }\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n  renderResumeDataCache?: RenderResumeDataCache\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  tree: LoaderTree,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n\n  const {\n    assetPrefix,\n    getDynamicParamFromSegment,\n    implicitTags,\n    nonce,\n    pagePath,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  const {\n    allowEmptyStaticShell = false,\n    basePath,\n    buildManifest,\n    ComponentMod,\n    crossOrigin,\n    dev = false,\n    experimental,\n    isDebugDynamicAccesses,\n    nextExport = false,\n    onInstrumentationRequestError,\n    page,\n    reactMaxHeadersLength,\n    subresourceIntegrityManifest,\n    cacheComponents,\n  } = renderOpts\n\n  const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const getServerInsertedMetadata = createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: subresourceIntegrityManifest?.[polyfill],\n        crossOrigin,\n        noModule: true,\n        nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    crossOrigin,\n    subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    page\n  )\n\n  const { reactServerErrorsByDigest } = workStore\n  // We don't report errors during prerendering through our instrumentation hooks\n  const reportErrors = !experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError, silenceLog: boolean) {\n    if (reportErrors) {\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'react-server-components'),\n        silenceLog\n      )\n    }\n  }\n  const serverComponentsErrorHandler = createReactServerErrorHandler(\n    dev,\n    nextExport,\n    reactServerErrorsByDigest,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    if (reportErrors) {\n      // We don't need to silence logs here. onHTMLRenderSSRError won't be\n      // called at all if the error was logged before in the RSC error handler.\n      const silenceLog = false\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'server-rendering'),\n        silenceLog\n      )\n    }\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    dev,\n    nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult: null | ReactServerPrerenderResult = null\n  const setMetadataHeader = (name: string) => {\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n  }\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n    setMetadataHeader(name)\n    return res\n  }\n  const appendHeader = (name: string, value: string | string[]) => {\n    if (Array.isArray(value)) {\n      value.forEach((item) => {\n        res.appendHeader(name, item)\n      })\n    } else {\n      res.appendHeader(name, value)\n    }\n    setMetadataHeader(name)\n  }\n\n  const selectStaleTime = createSelectStaleTime(experimental)\n  const { clientModules } = getClientReferenceManifest()\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (cacheComponents) {\n      /**\n       * cacheComponents with PPR\n       *\n       * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n       * Once we have settled all cache reads we restart the render and abort after a single Task.\n       *\n       * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n       * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n       * and a synchronous abort might prevent us from filling all caches.\n       *\n       * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n       * and the reactServerIsDynamic value to determine how to treat the resulting render\n       */\n\n      // The prerender controller represents the lifetime of the prerender. It\n      // will be aborted when a task is complete or a synchronously aborting API\n      // is called. Notably, during prospective prerenders, this does not\n      // actually terminate the prerender itself, which will continue until all\n      // caches are filled.\n      const initialServerPrerenderController = new AbortController()\n\n      // This controller is used to abort the React prerender.\n      const initialServerReactController = new AbortController()\n\n      // This controller represents the lifetime of the React prerender. Its\n      // signal can be used for any I/O operation to abort the I/O and/or to\n      // reject, when prerendering aborts. This includes our own hanging\n      // promises for accessing request data, and for fetch calls. It might be\n      // replaced in the future by React.cacheSignal(). It's aborted after the\n      // React controller, so that no pending I/O can register abort listeners\n      // that are called before React's abort listener is called. This ensures\n      // that pending I/O is not rejected too early when aborting the prerender.\n      // Notably, during the prospective prerender, it is different from the\n      // prerender controller because we don't want to end the React prerender\n      // until all caches are filled.\n      const initialServerRenderController = new AbortController()\n\n      // The cacheSignal helps us track whether caches are still filling or we are ready\n      // to cut the render off.\n      const cacheSignal = new CacheSignal()\n\n      let resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache\n      let renderResumeDataCache: RenderResumeDataCache | null = null\n      let prerenderResumeDataCache: PrerenderResumeDataCache | null = null\n\n      if (renderOpts.renderResumeDataCache) {\n        // If a prefilled immutable render resume data cache is provided, e.g.\n        // when prerendering an optional fallback shell after having prerendered\n        // pages with defined params, we use this instead of a prerender resume\n        // data cache.\n        resumeDataCache = renderResumeDataCache =\n          renderOpts.renderResumeDataCache\n      } else {\n        // Otherwise we create a new mutable prerender resume data cache.\n        resumeDataCache = prerenderResumeDataCache =\n          createPrerenderResumeDataCache()\n      }\n\n      const initialServerPayloadPrerenderStore: PrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n        // various request data APIs bind to this controller to reject after completion.\n        renderSignal: initialServerRenderController.signal,\n        // When we generate the RSC payload we might abort this controller due to sync IO\n        // but we don't actually care about sync IO in this phase so we use a throw away controller\n        // that isn't connected to anything\n        controller: new AbortController(),\n        // During the initial prerender we need to track all cache reads to ensure\n        // we render long enough to fill every cache it is possible to visit during\n        // the final prerender.\n        cacheSignal,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n      }\n\n      // We're not going to use the result of this render because the only time it could be used\n      // is if it completes in a microtask and that's likely very rare for any non-trivial app\n      const initialServerPayload = await workUnitAsyncStorage.run(\n        initialServerPayloadPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: initialServerRenderController.signal,\n        controller: initialServerPrerenderController,\n        // During the initial prerender we need to track all cache reads to ensure\n        // we render long enough to fill every cache it is possible to visit during\n        // the final prerender.\n        cacheSignal,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n      })\n\n      const pendingInitialServerResult = workUnitAsyncStorage.run(\n        initialServerPrerenderStore,\n        ComponentMod.prerender,\n        initialServerPayload,\n        clientModules,\n        {\n          filterStackFrame,\n          onError: (err) => {\n            const digest = getDigestForWellKnownError(err)\n\n            if (digest) {\n              return digest\n            }\n\n            if (isReactLargeShellError(err)) {\n              // TODO: Aggregate\n              console.error(err)\n              return undefined\n            }\n\n            if (initialServerPrerenderController.signal.aborted) {\n              // The render aborted before this error was handled which indicates\n              // the error is caused by unfinished components within the render\n              return\n            } else if (\n              process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING\n            ) {\n              printDebugThrownValueForProspectiveRender(\n                err,\n                workStore.route,\n                Phase.ProspectiveRender\n              )\n            }\n          },\n          // We don't want to stop rendering until the cacheSignal is complete so we pass\n          // a different signal to this render call than is used by dynamic APIs to signify\n          // transitioning out of the prerender environment\n          signal: initialServerReactController.signal,\n        }\n      )\n\n      // The listener to abort our own render controller must be added after\n      // React has added its listener, to ensure that pending I/O is not\n      // aborted/rejected too early.\n      initialServerReactController.signal.addEventListener(\n        'abort',\n        () => {\n          initialServerRenderController.abort()\n          initialServerPrerenderController.abort()\n        },\n        { once: true }\n      )\n\n      // Wait for all caches to be finished filling and for async imports to resolve\n      trackPendingModules(cacheSignal)\n      await cacheSignal.cacheReady()\n\n      initialServerReactController.abort()\n\n      // We don't need to continue the prerender process if we already\n      // detected invalid dynamic usage in the initial prerender phase.\n      if (workStore.invalidDynamicUsageError) {\n        logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)\n        throw new StaticGenBailoutError()\n      }\n\n      let initialServerResult\n      try {\n        initialServerResult = await createReactServerPrerenderResult(\n          pendingInitialServerResult\n        )\n      } catch (err) {\n        if (\n          initialServerReactController.signal.aborted ||\n          initialServerPrerenderController.signal.aborted\n        ) {\n          // These are expected errors that might error the prerender. we ignore them.\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          // We don't normally log these errors because we are going to retry anyway but\n          // it can be useful for debugging Next.js itself to get visibility here when needed\n          printDebugThrownValueForProspectiveRender(\n            err,\n            workStore.route,\n            Phase.ProspectiveRender\n          )\n        }\n      }\n\n      if (initialServerResult) {\n        const initialClientPrerenderController = new AbortController()\n        const initialClientReactController = new AbortController()\n        const initialClientRenderController = new AbortController()\n\n        const initialClientPrerenderStore: PrerenderStore = {\n          type: 'prerender-client',\n          phase: 'render',\n          rootParams,\n          fallbackRouteParams,\n          implicitTags,\n          renderSignal: initialClientRenderController.signal,\n          controller: initialClientPrerenderController,\n          // For HTML Generation the only cache tracked activity\n          // is module loading, which has it's own cache signal\n          cacheSignal: null,\n          dynamicTracking: null,\n          allowEmptyStaticShell,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          renderResumeDataCache,\n          hmrRefreshHash: undefined,\n        }\n\n        const prerender = (\n          require('react-dom/static') as typeof import('react-dom/static')\n        ).prerender\n        const pendingInitialClientResult = workUnitAsyncStorage.run(\n          initialClientPrerenderStore,\n          prerender,\n          // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n          <App\n            reactServerStream={initialServerResult.asUnclosingStream()}\n            reactDebugStream={undefined}\n            debugEndTime={undefined}\n            preinitScripts={preinitScripts}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={nonce}\n            images={ctx.renderOpts.images}\n          />,\n          {\n            signal: initialClientReactController.signal,\n            onError: (err) => {\n              const digest = getDigestForWellKnownError(err)\n\n              if (digest) {\n                return digest\n              }\n\n              if (isReactLargeShellError(err)) {\n                // TODO: Aggregate\n                console.error(err)\n                return undefined\n              }\n\n              if (initialClientReactController.signal.aborted) {\n                // These are expected errors that might error the prerender. we ignore them.\n              } else if (\n                process.env.NEXT_DEBUG_BUILD ||\n                process.env.__NEXT_VERBOSE_LOGGING\n              ) {\n                // We don't normally log these errors because we are going to retry anyway but\n                // it can be useful for debugging Next.js itself to get visibility here when needed\n                printDebugThrownValueForProspectiveRender(\n                  err,\n                  workStore.route,\n                  Phase.ProspectiveRender\n                )\n              }\n            },\n            bootstrapScripts: [bootstrapScript],\n          }\n        )\n\n        // The listener to abort our own render controller must be added after\n        // React has added its listener, to ensure that pending I/O is not\n        // aborted/rejected too early.\n        initialClientReactController.signal.addEventListener(\n          'abort',\n          () => {\n            initialClientRenderController.abort()\n          },\n          { once: true }\n        )\n\n        pendingInitialClientResult.catch((err) => {\n          if (\n            initialClientReactController.signal.aborted ||\n            isPrerenderInterruptedError(err)\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(\n              err,\n              workStore.route,\n              Phase.ProspectiveRender\n            )\n          }\n        })\n\n        // This is mostly needed for dynamic `import()`s in client components.\n        // Promises passed to client were already awaited above (assuming that they came from cached functions)\n        trackPendingModules(cacheSignal)\n        await cacheSignal.cacheReady()\n        initialClientReactController.abort()\n      }\n\n      const finalServerReactController = new AbortController()\n      const finalServerRenderController = new AbortController()\n\n      const finalServerPayloadPrerenderStore: PrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n        // various request data APIs bind to this controller to reject after completion.\n        renderSignal: finalServerRenderController.signal,\n        // When we generate the RSC payload we might abort this controller due to sync IO\n        // but we don't actually care about sync IO in this phase so we use a throw away controller\n        // that isn't connected to anything\n        controller: new AbortController(),\n        // All caches we could read must already be filled so no tracking is necessary\n        cacheSignal: null,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n      }\n\n      const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n        finalServerPayloadPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const serverDynamicTracking = createDynamicTrackingState(\n        isDebugDynamicAccesses\n      )\n      let serverIsDynamic = false\n\n      const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: finalServerRenderController.signal,\n        controller: finalServerReactController,\n        // All caches we could read must already be filled so no tracking is necessary\n        cacheSignal: null,\n        dynamicTracking: serverDynamicTracking,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n      })\n\n      let prerenderIsPending = true\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResult(\n          prerenderAndAbortInSequentialTasks(\n            async () => {\n              const pendingPrerenderResult = workUnitAsyncStorage.run(\n                // The store to scope\n                finalServerPrerenderStore,\n                // The function to run\n                ComponentMod.prerender,\n                // ... the arguments for the function to run\n                finalAttemptRSCPayload,\n                clientModules,\n                {\n                  filterStackFrame,\n                  onError: (err: unknown) => {\n                    return serverComponentsErrorHandler(err)\n                  },\n                  signal: finalServerReactController.signal,\n                }\n              )\n\n              // The listener to abort our own render controller must be added\n              // after React has added its listener, to ensure that pending I/O\n              // is not aborted/rejected too early.\n              finalServerReactController.signal.addEventListener(\n                'abort',\n                () => {\n                  finalServerRenderController.abort()\n                },\n                { once: true }\n              )\n\n              const prerenderResult = await pendingPrerenderResult\n              prerenderIsPending = false\n\n              return prerenderResult\n            },\n            () => {\n              if (finalServerReactController.signal.aborted) {\n                // If the server controller is already aborted we must have called something\n                // that required aborting the prerender synchronously such as with new Date()\n                serverIsDynamic = true\n                return\n              }\n\n              if (prerenderIsPending) {\n                // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                // there is something unfinished.\n                serverIsDynamic = true\n              }\n\n              finalServerReactController.abort()\n            }\n          )\n        ))\n\n      const clientDynamicTracking = createDynamicTrackingState(\n        isDebugDynamicAccesses\n      )\n\n      const finalClientReactController = new AbortController()\n      const finalClientRenderController = new AbortController()\n\n      const finalClientPrerenderStore: PrerenderStore = {\n        type: 'prerender-client',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: finalClientRenderController.signal,\n        controller: finalClientReactController,\n        // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n        cacheSignal: null,\n        dynamicTracking: clientDynamicTracking,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n      }\n\n      let dynamicValidation = createDynamicValidationState()\n\n      const prerender = (\n        require('react-dom/static') as typeof import('react-dom/static')\n      ).prerender\n      let { prelude: unprocessedPrelude, postponed } =\n        await prerenderAndAbortInSequentialTasks(\n          () => {\n            const pendingFinalClientResult = workUnitAsyncStorage.run(\n              finalClientPrerenderStore,\n              prerender,\n              // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                reactDebugStream={undefined}\n                debugEndTime={undefined}\n                preinitScripts={preinitScripts}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={nonce}\n                images={ctx.renderOpts.images}\n              />,\n              {\n                signal: finalClientReactController.signal,\n                onError: (err: unknown, errorInfo: ErrorInfo) => {\n                  if (\n                    isPrerenderInterruptedError(err) ||\n                    finalClientReactController.signal.aborted\n                  ) {\n                    const componentStack: string | undefined = (\n                      errorInfo as any\n                    ).componentStack\n                    if (typeof componentStack === 'string') {\n                      trackAllowedDynamicAccess(\n                        workStore,\n                        componentStack,\n                        dynamicValidation,\n                        clientDynamicTracking\n                      )\n                    }\n                    return\n                  }\n\n                  return htmlRendererErrorHandler(err, errorInfo)\n                },\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    appendHeader(key, value)\n                  })\n                },\n                maxHeadersLength: reactMaxHeadersLength,\n                bootstrapScripts: [bootstrapScript],\n              }\n            )\n\n            // The listener to abort our own render controller must be added\n            // after React has added its listener, to ensure that pending I/O is\n            // not aborted/rejected too early.\n            finalClientReactController.signal.addEventListener(\n              'abort',\n              () => {\n                finalClientRenderController.abort()\n              },\n              { once: true }\n            )\n\n            return pendingFinalClientResult\n          },\n          () => {\n            finalClientReactController.abort()\n          }\n        )\n\n      const { prelude, preludeIsEmpty } =\n        await processPrelude(unprocessedPrelude)\n\n      // If we've disabled throwing on empty static shell, then we don't need to\n      // track any dynamic access that occurs above the suspense boundary because\n      // we'll do so in the route shell.\n      if (!allowEmptyStaticShell) {\n        throwIfDisallowedDynamic(\n          workStore,\n          preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,\n          dynamicValidation,\n          serverDynamicTracking\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n      metadata.flightData = flightData\n      metadata.segmentData = await collectSegmentData(\n        flightData,\n        finalServerPrerenderStore,\n        ComponentMod,\n        renderOpts\n      )\n\n      if (serverIsDynamic) {\n        // Dynamic case\n        // We will always need to perform a \"resume\" render of some kind when this route is accessed\n        // because the RSC data itself is dynamic. We determine if there are any HTML holes or not\n        // but generally this is a \"partial\" prerender in that there will be a per-request compute\n        // concatenated to the static shell.\n        if (postponed != null) {\n          // Dynamic HTML case\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            preludeIsEmpty\n              ? DynamicHTMLPreludeState.Empty\n              : DynamicHTMLPreludeState.Full,\n            fallbackRouteParams,\n            resumeDataCache,\n            cacheComponents\n          )\n        } else {\n          // Dynamic Data case\n          metadata.postponed = await getDynamicDataPostponedState(\n            resumeDataCache,\n            cacheComponents\n          )\n        }\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n          collectedTags: finalServerPrerenderStore.tags,\n          renderResumeDataCache: createRenderResumeDataCache(resumeDataCache),\n        }\n      } else {\n        // Static case\n        // We will not perform resumption per request. The result can be served statically to the requestor\n        // and if there was anything dynamic it will only be rendered in the browser.\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n            <App\n              reactServerStream={foreverStream}\n              reactDebugStream={undefined}\n              debugEndTime={undefined}\n              preinitScripts={() => {}}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createRenderInBrowserAbortSignal(),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        let finalStream\n        const hasFallbackRouteParams =\n          fallbackRouteParams && fallbackRouteParams.size > 0\n        if (hasFallbackRouteParams) {\n          // This is a \"static fallback\" prerender: although the page didn't\n          // access any runtime params in a Server Component, it may have\n          // accessed a runtime param in a client segment.\n          //\n          // TODO: If there were no client segments, we can use the fully static\n          // path instead.\n          //\n          // Rather than use a dynamic server resume to fill in the params,\n          // we can rely on the client to parse the params from the URL and use\n          // that to hydrate the page.\n          //\n          // Send an empty InitialRSCPayload to the server component renderer\n          // The data will be fetched by the client instead.\n          // TODO: In the future, rather than defer the entire hydration payload\n          // to be fetched by the client, we should only defer the client\n          // segments, since those are the only ones whose data is not complete.\n          const emptyReactServerResult =\n            await createReactServerPrerenderResultFromRender(\n              ComponentMod.renderToReadableStream([], clientModules, {\n                filterStackFrame,\n                onError: serverComponentsErrorHandler,\n              })\n            )\n          finalStream = await continueStaticFallbackPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              emptyReactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n          })\n        } else {\n          // Normal static prerender case, no fallback param handling needed\n          finalStream = await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n          })\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: finalStream,\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n          collectedTags: finalServerPrerenderStore.tags,\n          renderResumeDataCache: createRenderResumeDataCache(resumeDataCache),\n        }\n      }\n    } else if (experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(isDebugDynamicAccesses)\n\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      }\n      const prerender = (\n        require('react-dom/static') as typeof import('react-dom/static')\n      ).prerender\n      const { prelude: unprocessedPrelude, postponed } =\n        await workUnitAsyncStorage.run(\n          ssrPrerenderStore,\n          prerender,\n          // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n          <App\n            reactServerStream={reactServerResult.asUnclosingStream()}\n            reactDebugStream={undefined}\n            debugEndTime={undefined}\n            preinitScripts={preinitScripts}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={nonce}\n            images={ctx.renderOpts.images}\n          />,\n          {\n            onError: htmlRendererErrorHandler,\n            onHeaders: (headers: Headers) => {\n              headers.forEach((value, key) => {\n                appendHeader(key, value)\n              })\n            },\n            maxHeadersLength: reactMaxHeadersLength,\n            bootstrapScripts: [bootstrapScript],\n          }\n        )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          ssrPrerenderStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      const { prelude, preludeIsEmpty } =\n        await processPrelude(unprocessedPrelude)\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            preludeIsEmpty\n              ? DynamicHTMLPreludeState.Empty\n              : DynamicHTMLPreludeState.Full,\n            fallbackRouteParams,\n            prerenderResumeDataCache,\n            cacheComponents\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache,\n            cacheComponents\n          )\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = await getDynamicDataPostponedState(\n          prerenderResumeDataCache,\n          cacheComponents\n        )\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n            <App\n              reactServerStream={foreverStream}\n              reactDebugStream={undefined}\n              debugEndTime={undefined}\n              preinitScripts={() => {}}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createRenderInBrowserAbortSignal(),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = (\n        require('react-dom/server') as typeof import('react-dom/server')\n      ).renderToReadableStream\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          reactDebugStream={undefined}\n          debugEndTime={undefined}\n          preinitScripts={preinitScripts}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={nonce}\n          images={ctx.renderOpts.images}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: selectStaleTime(prerenderLegacyStore.stale),\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      metadata.statusCode = res.statusCode\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n      metadata.statusCode = res.statusCode\n\n      const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n      metadata.statusCode = res.statusCode\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      buildManifest,\n      assetPrefix,\n      crossOrigin,\n      subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      rootParams,\n      implicitTags: implicitTags,\n      revalidate:\n        typeof prerenderStore?.revalidate !== 'undefined'\n          ? prerenderStore.revalidate\n          : INFINITE_CACHE,\n      expire:\n        typeof prerenderStore?.expire !== 'undefined'\n          ? prerenderStore.expire\n          : INFINITE_CACHE,\n      stale:\n        typeof prerenderStore?.stale !== 'undefined'\n          ? prerenderStore.stale\n          : INFINITE_CACHE,\n      tags: [...(prerenderStore?.tags || implicitTags.tags)],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientModules,\n      {\n        filterStackFrame,\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      // TODO we should use the same prerender semantics that we initially rendered\n      // with in this case too. The only reason why this is ok atm is because it's essentially\n      // an empty page and no user code runs.\n      const fizzStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer:\n            require('react-dom/server') as typeof import('react-dom/server'),\n          element: (\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n            <ErrorApp\n              reactServerStream={errorServerStream}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              preinitScripts={errorPreinitScripts}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />\n          ),\n          streamOptions: {\n            nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      // This is intentionally using the readable datastream from the main\n      // render rather than the flight data from the error page render\n      const flightStream = reactServerPrerenderResult.consumeAsStream()\n\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            flightStream,\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout: dev,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale: selectStaleTime(\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE\n        ),\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst getGlobalErrorStyles = async (\n  tree: LoaderTree,\n  ctx: AppRenderContext\n): Promise<{\n  GlobalError: GlobalErrorComponent\n  styles: ReactNode | undefined\n}> => {\n  const {\n    modules: { 'global-error': globalErrorModule },\n  } = parseLoaderTree(tree)\n\n  const {\n    componentMod: { createElement },\n  } = ctx\n  const GlobalErrorComponent: GlobalErrorComponent =\n    ctx.componentMod.GlobalError\n  let globalErrorStyles\n  if (globalErrorModule) {\n    const [, styles] = await createComponentStylesAndScripts({\n      ctx,\n      filePath: globalErrorModule[1],\n      getComponent: globalErrorModule[0],\n      injectedCSS: new Set(),\n      injectedJS: new Set(),\n    })\n    globalErrorStyles = styles\n  }\n  if (ctx.renderOpts.dev) {\n    const dir =\n      (process.env.NEXT_RUNTIME === 'edge'\n        ? process.env.__NEXT_EDGE_PROJECT_DIR\n        : ctx.renderOpts.dir) || ''\n\n    const globalErrorModulePath = normalizeConventionFilePath(\n      dir,\n      globalErrorModule?.[1]\n    )\n    if (globalErrorModulePath) {\n      const SegmentViewNode = ctx.componentMod.SegmentViewNode\n      globalErrorStyles =\n        // This will be rendered next to GlobalError component under ErrorBoundary,\n        // it requires a key to avoid React warning about duplicate keys.\n        createElement(\n          SegmentViewNode,\n          {\n            key: 'ge-svn',\n            type: 'global-error',\n            pagePath: globalErrorModulePath,\n          },\n          globalErrorStyles\n        )\n    }\n  }\n\n  return {\n    GlobalError: GlobalErrorComponent,\n    styles: globalErrorStyles,\n  }\n}\n\nfunction createSelectStaleTime(experimental: ExperimentalConfig) {\n  return (stale: number) =>\n    stale === INFINITE_CACHE &&\n    typeof experimental.staleTimes?.static === 'number'\n      ? experimental.staleTimes.static\n      : stale\n}\n\nasync function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  prerenderStore: PrerenderStore,\n  ComponentMod: AppPageModule,\n  renderOpts: RenderOpts\n): Promise<Map<string, Buffer> | undefined> {\n  // Per-segment prefetch data\n  //\n  // All of the segments for a page are generated simultaneously, including\n  // during revalidations. This is to ensure consistency, because it's\n  // possible for a mismatch between a layout and page segment can cause the\n  // client to error during rendering. We want to preserve the ability of the\n  // client to recover from such a mismatch by re-requesting all the segments\n  // to get a consistent view of the page.\n  //\n  // For performance, we reuse the Flight output that was created when\n  // generating the initial page HTML. The Flight stream for the whole page is\n  // decomposed into a separate stream per segment.\n\n  const { clientModules, edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifest()\n\n  // Manifest passed to the Flight client for reading the full-page Flight\n  // stream. Based off similar code in use-cache-wrapper.ts.\n  const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n    serverModuleMap: getServerModuleMap(),\n  }\n\n  const selectStaleTime = createSelectStaleTime(renderOpts.experimental)\n  const staleTime = selectStaleTime(prerenderStore.stale)\n  return await ComponentMod.collectSegmentData(\n    renderOpts.cacheComponents,\n    fullPageDataBuffer,\n    staleTime,\n    clientModules,\n    serverConsumerManifest\n  )\n}\n\nfunction isBypassingCachesInDev(\n  renderOpts: RenderOpts,\n  requestStore: RequestStore\n): boolean {\n  return (\n    process.env.NODE_ENV === 'development' &&\n    !!renderOpts.dev &&\n    requestStore.headers.get('cache-control') === 'no-cache'\n  )\n}\n\nfunction WarnForBypassCachesInDev({ route }: { route: string }) {\n  warnOnce(\n    `Route ${route} is rendering with server caches disabled. For this navigation, Component Metadata in React DevTools will not accurately reflect what is statically prerenderable and runtime prefetchable. See more info here: https://nextjs.org/docs/messages/cache-bypass-in-dev`\n  )\n  return null\n}\n\nfunction nodeStreamFromReadableStream<T>(stream: ReadableStream<T>) {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'nodeStreamFromReadableStream cannot be used in the edge runtime'\n    )\n  } else {\n    const reader = stream.getReader()\n\n    const { Readable } = require('node:stream') as typeof import('node:stream')\n\n    return new Readable({\n      read() {\n        reader\n          .read()\n          .then(({ done, value }) => {\n            if (done) {\n              this.push(null)\n            } else {\n              this.push(value)\n            }\n          })\n          .catch((err) => this.destroy(err))\n      },\n    })\n  }\n}\n\nfunction createNodeStreamFromChunks(\n  partialChunks: Array<Uint8Array>,\n  allChunks: Array<Uint8Array>,\n  signal: AbortSignal\n): Readable {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'createNodeStreamFromChunks cannot be used in the edge runtime'\n    )\n  } else {\n    const { Readable } = require('node:stream') as typeof import('node:stream')\n\n    let nextIndex = 0\n\n    const readable = new Readable({\n      read() {\n        while (nextIndex < partialChunks.length) {\n          this.push(partialChunks[nextIndex])\n          nextIndex++\n        }\n      },\n    })\n\n    signal.addEventListener(\n      'abort',\n      () => {\n        // Flush any remaining chunks from the original set\n        while (nextIndex < partialChunks.length) {\n          readable.push(partialChunks[nextIndex])\n          nextIndex++\n        }\n        // Flush all chunks since we're now aborted and can't schedule\n        // any new work but these chunks might unblock debugInfo\n        while (nextIndex < allChunks.length) {\n          readable.push(allChunks[nextIndex])\n          nextIndex++\n        }\n\n        setImmediate(() => {\n          readable.push(null)\n        })\n      },\n      { once: true }\n    )\n\n    return readable\n  }\n}\n"],"names":["workAsyncStorage","ReactClient","RenderResult","chainStreams","renderToInitialFizzStream","createDocumentClosingStream","continueFizzStream","continueDynamicPrerender","continueStaticPrerender","continueDynamicHTMLResume","streamToBuffer","streamToString","continueStaticFallbackPrerender","stripInternalQueries","NEXT_HMR_REFRESH_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_URL","RSC_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_HTML_REQUEST_ID_HEADER","createMetadataContext","createRequestStoreForRender","createWorkStore","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getURLFromRedirectError","getRedirectStatusCodeFromError","isRedirectError","getImplicitTags","AppRenderSpan","NextNodeServerSpan","getTracer","SpanStatusCode","FlightRenderResult","createReactServerErrorHandler","createHTMLErrorHandler","isUserLandError","getDigestForWellKnownError","dynamicParamTypes","getSegmentParam","getScriptNonceFromHeader","parseAndValidateFlightRouterState","createFlightRouterStateFromLoaderTree","handleAction","isBailoutToCSRError","warn","error","appendMutableCookies","createServerInsertedHTML","getRequiredScripts","addPathPrefix","makeGetServerInsertedHTML","walkTreeWithFlightRouterState","createComponentTree","getRootParams","getAssetQueryString","getClientReferenceManifest","getServerModuleMap","DynamicState","DynamicHTMLPreludeState","parsePostponedState","getDynamicDataPostponedState","getDynamicHTMLPostponedState","getPostponedFromState","isDynamicServerError","getFlightStream","createInlinedDataReadableStream","StaticGenBailoutError","isStaticGenBailoutError","getStackWithoutErrorMessage","accessedDynamicData","createRenderInBrowserAbortSignal","formatDynamicAPIAccesses","isPrerenderInterruptedError","createDynamicTrackingState","createDynamicValidationState","trackAllowedDynamicAccess","throwIfDisallowedDynamic","PreludeState","consumeDynamicAccess","logDisallowedDynamicError","trackDynamicHoleInRuntimeShell","trackDynamicHoleInStaticShell","getStaticShellDisallowedDynamicReasons","getClientComponentLoaderMetrics","wrapClientComponentLoader","isNodeNextRequest","parseRelativeUrl","AppRouter","getIsPossibleServerAction","createInitialRouterState","createMutableActionQueue","getRevalidateReason","PAGE_SEGMENT_KEY","prerenderAndAbortInSequentialTasksWithStages","processPrelude","ReactServerResult","createReactServerPrerenderResult","createReactServerPrerenderResultFromRender","prerenderAndAbortInSequentialTasks","Phase","printDebugThrownValueForProspectiveRender","pipelineInSequentialTasks","scheduleInSequentialTasks","waitAtLeastOneReactRenderTask","getHmrRefreshHash","workUnitAsyncStorage","consoleAsyncStorage","CacheSignal","getTracedMetadata","InvariantError","HTML_CONTENT_TYPE_HEADER","INFINITE_CACHE","createComponentStylesAndScripts","parseLoaderTree","createPrerenderResumeDataCache","createRenderResumeDataCache","isError","createServerInsertedMetadata","getPreviouslyRevalidatedTags","executeRevalidates","trackPendingChunkLoad","trackPendingImport","trackPendingModules","isReactLargeShellError","normalizeConventionFilePath","getRequestMeta","getDynamicParam","interpolateParallelRouteParams","createPromiseWithResolvers","ImageConfigContext","imageConfigDefault","RenderStage","StagedRenderingController","anySegmentHasRuntimePrefetchEnabled","warnOnce","flightDataPathHeadKey","getFlightViewportKey","requestId","getFlightMetadataKey","filterStackFrame","process","env","NODE_ENV","require","filterStackFrameDEV","undefined","parseRequestHeaders","headers","options","isPrefetchRequest","isRuntimePrefetchRequest","isHmrRefresh","isRSCRequest","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","isRouteTreePrefetchRequest","csp","nonce","previouslyRevalidatedTags","previewModeId","htmlRequestId","createNotFoundLoaderTree","loaderTree","components","hasGlobalNotFound","notFoundTreeComponents","layout","page","children","makeGetDynamicParamFromSegment","interpolatedParams","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","segmentKey","paramName","dynamicParamType","paramType","NonIndex","createElement","pagePath","statusCode","isPossibleServerAction","is404Page","isInvalidStatusCode","name","content","generateDynamicRSCPayload","ctx","flightData","componentMod","routeModule","userland","createMetadataComponents","Fragment","query","workStore","url","serveStreamingMetadata","renderOpts","skipPageRendering","preloadCallbacks","Viewport","Metadata","MetadataOutlet","tree","parsedQuery","pathname","metadataContext","loaderTreeToFilter","parentParams","rscHead","key","res","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","map","path","slice","varyHeader","getHeader","couldBeIntercepted","includes","actionResult","a","f","b","sharedContext","buildId","q","getRenderedSearch","i","baseResponse","S","isStaticGeneration","runtimePrefetchSentinel","rp","createErrorContext","renderSource","routerKind","routePath","routeType","revalidateReason","generateDynamicFlightRenderResult","req","requestStore","renderToReadableStream","dev","onInstrumentationRequestError","setReactDebugChannel","nextExport","onFlightDataRenderError","err","silenceLog","onError","reactServerErrorsByDigest","debugChannel","createDebugChannel","clientSide","clientModules","rscPayload","run","flightReadableStream","temporaryReferences","serverSide","fetchMetrics","waitUntil","stagedRenderToReadableStreamWithoutCachesInDev","getPayload","hasRuntimePrefetch","abortSignal","stageController","environmentName","currentStage","Before","Static","Runtime","Dynamic","Abandoned","stagedRendering","asyncApiPromises","createAsyncApiPromisesInDev","cookies","mutableCookies","advanceStage","generateDynamicFlightRenderResultWithStagesInDev","initialRequestStore","createRequestStore","devFallbackParams","setCacheStatus","shouldValidate","isBypassingCachesInDev","payload","_bypassCachesInDev","WarnForBypassCachesInDev","route","c","prepareInitialCanonicalUrl","stream","serverStream","accumulatedChunksPromise","staticInterruptReason","runtimeInterruptReason","staticStageEndTime","runtimeStageEndTime","returnedDebugChannel","finalRequestStore","renderWithRestartOnCacheMissInDev","validationDebugChannelClient","t1","t2","readable","tee","nodeStreamFromReadableStream","dim","spawnStaticShellValidationInDev","generateRuntimePrefetchResult","metadata","Math","floor","random","Number","MAX_SAFE_INTEGER","generatePayload","rootParams","prerenderResumeDataCache","renderResumeDataCache","prospectiveRuntimeServerPrerender","draftMode","response","finalRuntimeServerPrerender","applyMetadataFromPrerenderResult","result","prelude","implicitTags","ComponentMod","initialServerPrerenderController","AbortController","initialServerRenderController","cacheSignal","initialServerPrerenderStore","type","phase","renderSignal","signal","controller","dynamicTracking","revalidate","expire","stale","tags","hmrRefreshHash","runtimeStagePromise","initialServerPayload","pendingInitialServerResult","prerender","digest","aborted","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","ProspectiveRender","cacheReady","abort","invalidDynamicUsageError","createRuntimePrefetchTransformStream","sentinel","isPartial","staleTime","encoder","TextEncoder","search","encode","first","replace","searchLen","length","currentChunk","found","processChunk","nextChunk","enqueue","exclusiveUpperBound","min","currentIndex","indexOf","candidateLoop","matchIndex","candidateIndex","candidateValue","subarray","overflowBytes","truncatedChunk","TransformStream","transform","chunk","flush","experimental","isDebugDynamicAccesses","selectStaleTime","createSelectStaleTime","serverIsDynamic","finalServerController","serverDynamicTracking","promise","resolve","resolveBlockedRuntimeAPIs","finalServerPrerenderStore","finalRSCPayload","prerenderIsPending","prerenderResult","collectedStale","pipeThrough","dynamicAccess","collectedRevalidate","collectedExpire","collectedTags","split","pairs","value","Array","isArray","v","push","encodeURIComponent","String","join","getRSCPayload","is404","missingSlots","appUsingSizeAdjustment","initialTree","errorType","seedData","authInterrupts","initialHead","GlobalError","styles","globalErrorStyles","getGlobalErrorStyles","isPossiblyPartialHead","P","Preloads","m","G","forEach","preloadFn","getErrorRSCPayload","ssrError","Error","id","message","stack","App","reactServerStream","reactDebugStream","debugEndTime","preinitScripts","ServerInsertedHTMLProvider","images","use","initialState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialRenderedSearch","location","actionQueue","HeadManagerContext","Provider","appDir","globalErrorState","ErrorApp","renderToHTMLOrFlightImpl","parsedRequestHeaders","postponedState","serverComponentsHmrCache","isNotFoundPath","requestTimestamp","Date","now","nextFontManifest","serverActions","assetPrefix","enableTainting","cacheComponents","__next_app__","instrumented","shouldTrackModuleLoading","workUnitStore","getStore","__next_require__","args","exportsOrPromise","globalThis","__next_chunk_load__","loadingChunk","loadChunk","setIsrStatus","URL","NEXT_RUNTIME","onClose","shouldTrackFetchMetrics","originalRequest","on","metrics","reset","startSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","appUsingSizeAdjust","patchFetch","taintObjectReference","Buffer","from","crypto","subtle","toString","randomUUID","nanoid","isPossibleActionRequest","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","getBodyResult","spanName","prerenderToStream","access","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","find","contentType","pendingRevalidates","pendingRevalidateWrites","pendingRevalidatedTags","pendingPromise","finally","NEXT_PRIVATE_DEBUG_CACHE","console","log","bind","onUpdateCookies","previewProps","isStatic","usedDynamic","forceDynamic","didExecuteServerAction","formState","actionRequestResult","generateFlight","notFoundLoaderTree","renderToStream","assignMetadata","renderToHTMLOrFlight","postponed","params","maxPostponedStateSizeBytes","definition","fetchTags","staleHeader","forceStatic","cacheControl","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","basePath","buildManifest","serverRenderToReadableStream","crossOrigin","reactMaxHeadersLength","shouldWaitOnAllReady","subresourceIntegrityManifest","supportsDynamicResponse","renderServerInsertedHTML","getServerInsertedMetadata","tracingMetadata","getTracePropagationData","clientTraceMetadata","polyfills","polyfillFiles","filter","polyfill","endsWith","src","integrity","noModule","bootstrapScript","bootstrapScriptContent","JSON","stringify","renderSpan","endSpanWithError","isRecording","recordException","setAttribute","setStatus","code","ERROR","withSpan","onHTMLRenderRSCError","serverComponentsErrorHandler","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","reactServerResult","setHeader","appendHeader","readableSsr","readableBrowser","RSCPayload","DATA","inlinedReactServerDataStream","preludeState","resume","htmlStream","allReady","getServerInsertedHTML","serverCapturedErrors","delayDataUntilFirstHtmlChunk","Empty","inlinedDataStream","consume","onHeaders","maxHeadersLength","bootstrapScripts","generateStaticHTML","isBuildTimePrerendering","validateRootLayout","shouldBailoutToCSR","reason","redirectUrl","Headers","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","has","setupErr","fizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnRootNotFound","initialReactController","initialDataController","initialStageController","initialRscPayload","maybeInitialStreamResult","addEventListener","continuationStream","accumulatingStream","accumulateStreamChunks","hasPendingReads","abandonRender","getStaticInterruptReason","getRuntimeInterruptReason","getStaticStageEndTime","getRuntimeStageEndTime","finalStageController","finalRscPayload","finalStreamResult","staticChunks","runtimeChunks","dynamicChunks","reader","getReader","cancelled","cancel","once","done","read","delayUntilStage","sharedParamsParent","sharedSearchParamsParent","connection","readableController","clientSideReadable","ReadableStream","start","writable","WritableStream","write","close","logMessagesAndSendErrorsToBrowser","messages","sendErrorsToBrowser","errors","exit","errorsRscStream","debugChannelClient","allowEmptyStaticShell","warmupModuleCacheForRuntimeValidationInDev","debugChunks","runtimeResult","validateStagedShell","staticResult","runtimeServerChunks","allServerChunks","initialClientPrerenderController","initialClientReactController","initialClientRenderController","initialClientPrerenderStore","runtimeServerStream","createNodeStreamFromChunks","pendingInitialClientResult","catch","stageChunks","trackDynamicHole","clientDynamicTracking","clientReactController","clientRenderController","finalClientPrerenderStore","runtimeDynamicValidation","unprocessedPrelude","pendingFinalClientResult","errorInfo","componentStack","preludeIsEmpty","Full","thrownValue","Errored","unshift","shouldGenerateStaticFlightData","reportErrors","reactServerPrerenderResult","setMetadataHeader","item","prerenderStore","initialServerReactController","resumeDataCache","initialServerPayloadPrerenderStore","initialServerResult","asUnclosingStream","finalServerReactController","finalServerRenderController","finalServerPayloadPrerenderStore","finalAttemptRSCPayload","pendingPrerenderResult","finalClientReactController","finalClientRenderController","dynamicValidation","asStream","segmentData","collectSegmentData","foreverStream","resumeStream","parse","finalStream","hasFallbackRouteParams","emptyReactServerResult","consumeAsStream","reactServerPrerenderStore","ssrPrerenderStore","dynamicAccesses","prerenderLegacyStore","flightStream","modules","globalErrorModule","GlobalErrorComponent","filePath","getComponent","dir","__NEXT_EDGE_PROJECT_DIR","globalErrorModulePath","SegmentViewNode","staleTimes","static","fullPageDataBuffer","edgeRscModuleMapping","rscModuleMapping","isEdgeRuntime","serverConsumerManifest","moduleLoading","moduleMap","serverModuleMap","get","Readable","then","destroy","partialChunks","allChunks","nextIndex","setImmediate"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9550, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/interop-default.ts"],"sourcesContent":["/**\n * Interop between \"export default\" and \"module.exports\".\n */\nexport function interopDefault(mod: any) {\n  return mod.default || mod\n}\n"],"names":["interopDefault","mod","default"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA,eAAeC,GAAQ;IACrC,OAAOA,IAAIC,OAAO,IAAID;AACxB","ignoreList":[0]}},
    {"offset": {"line": 9563, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/strip-flight-headers.ts"],"sourcesContent":["import type { IncomingHttpHeaders } from 'node:http'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\n\n/**\n * Removes the flight headers from the request.\n *\n * @param req the request to strip the headers from\n */\nexport function stripFlightHeaders(headers: IncomingHttpHeaders) {\n  for (const header of FLIGHT_HEADERS) {\n    delete headers[header]\n  }\n}\n"],"names":["FLIGHT_HEADERS","stripFlightHeaders","headers","header"],"mappings":";;;;AAEA,SAASA,cAAc,QAAQ,6CAA4C;;AAOpE,SAASC,mBAAmBC,OAA4B;IAC7D,KAAK,MAAMC,UAAUH,gOAAAA,CAAgB;QACnC,OAAOE,OAAO,CAACC,OAAO;IACxB;AACF","ignoreList":[0]}},
    {"offset": {"line": 9578, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/get-short-dynamic-param-type.tsx"],"sourcesContent":["import type {\n  DynamicParamTypes,\n  DynamicParamTypesShort,\n} from '../../shared/lib/app-router-types'\n\nexport const dynamicParamTypes: Record<\n  DynamicParamTypes,\n  DynamicParamTypesShort\n> = {\n  catchall: 'c',\n  'catchall-intercepted-(..)(..)': 'ci(..)(..)',\n  'catchall-intercepted-(.)': 'ci(.)',\n  'catchall-intercepted-(..)': 'ci(..)',\n  'catchall-intercepted-(...)': 'ci(...)',\n  'optional-catchall': 'oc',\n  dynamic: 'd',\n  'dynamic-intercepted-(..)(..)': 'di(..)(..)',\n  'dynamic-intercepted-(.)': 'di(.)',\n  'dynamic-intercepted-(..)': 'di(..)',\n  'dynamic-intercepted-(...)': 'di(...)',\n}\n"],"names":["dynamicParamTypes","catchall","dynamic"],"mappings":";;;;AAKO,MAAMA,oBAGT;IACFC,UAAU;IACV,iCAAiC;IACjC,4BAA4B;IAC5B,6BAA6B;IAC7B,8BAA8B;IAC9B,qBAAqB;IACrBC,SAAS;IACT,gCAAgC;IAChC,2BAA2B;IAC3B,4BAA4B;IAC5B,6BAA6B;AAC/B,EAAC","ignoreList":[0]}},
    {"offset": {"line": 9599, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/manifests-singleton.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nexport interface ServerModuleMap {\n  readonly [name: string]: {\n    readonly id: string | number\n    readonly name: string\n    readonly chunks: Readonly<Array<string>> // currently not used\n    readonly async?: boolean\n  }\n}\n\n// This is a global singleton that is, among other things, also used to\n// encode/decode bound args of server function closures. This can't be using a\n// AsyncLocalStorage as it might happen at the module level.\nconst MANIFESTS_SINGLETON = Symbol.for('next.server.manifests')\n\ninterface ManifestsSingleton {\n  readonly clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n  readonly proxiedClientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: ServerModuleMap\n}\n\ntype GlobalThisWithManifests = typeof globalThis & {\n  [MANIFESTS_SINGLETON]?: ManifestsSingleton\n}\n\ntype ClientReferenceManifestMappingProp =\n  | 'clientModules'\n  | 'rscModuleMapping'\n  | 'edgeRscModuleMapping'\n  | 'ssrModuleMapping'\n  | 'edgeSSRModuleMapping'\n\nconst globalThisWithManifests = globalThis as GlobalThisWithManifests\n\nfunction createProxiedClientReferenceManifest(\n  clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n): DeepReadonly<ClientReferenceManifest> {\n  const createMappingProxy = (prop: ClientReferenceManifestMappingProp) => {\n    return new Proxy(\n      {},\n      {\n        get(_, id: string) {\n          const workStore = workAsyncStorage.getStore()\n\n          if (workStore) {\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (currentManifest?.[prop][id]) {\n              return currentManifest[prop][id]\n            }\n\n            // In development, we also check all other manifests to see if the\n            // module exists there. This is to support a scenario where React's\n            // I/O tracking (dev-only) creates a connection from one page to\n            // another through an emitted async I/O node that references client\n            // components from the other page, e.g. in owner props.\n            // TODO: Maybe we need to add a `debugBundlerConfig` option to React\n            // to avoid this workaround. The current workaround has the\n            // disadvantage that one might accidentally or intentionally share\n            // client references across pages (e.g. by storing them in a global\n            // variable), which would then only be caught in production.\n            if (process.env.NODE_ENV !== 'production') {\n              for (const [\n                route,\n                manifest,\n              ] of clientReferenceManifestsPerRoute) {\n                if (route === workStore.route) {\n                  continue\n                }\n\n                const entry = manifest[prop][id]\n\n                if (entry !== undefined) {\n                  return entry\n                }\n              }\n            }\n          } else {\n            // If there's no work store defined, we can assume that a client\n            // reference manifest is needed during module evaluation, e.g. to\n            // create a server function using a higher-order function. This\n            // might also use client components which need to be serialized by\n            // Flight, and therefore client references need to be resolvable. In\n            // that case we search all page manifests to find the module.\n            for (const manifest of clientReferenceManifestsPerRoute.values()) {\n              const entry = manifest[prop][id]\n\n              if (entry !== undefined) {\n                return entry\n              }\n            }\n          }\n\n          return undefined\n        },\n      }\n    )\n  }\n\n  const mappingProxies = new Map<\n    ClientReferenceManifestMappingProp,\n    ReturnType<typeof createMappingProxy>\n  >()\n\n  return new Proxy(\n    {},\n    {\n      get(_, prop) {\n        const workStore = workAsyncStorage.getStore()\n\n        switch (prop) {\n          case 'moduleLoading':\n          case 'entryCSSFiles':\n          case 'entryJSFiles': {\n            if (!workStore) {\n              throw new InvariantError(\n                `Cannot access \"${prop}\" without a work store.`\n              )\n            }\n\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (!currentManifest) {\n              throw new InvariantError(\n                `The client reference manifest for route \"${workStore.route}\" does not exist.`\n              )\n            }\n\n            return currentManifest[prop]\n          }\n          case 'clientModules':\n          case 'rscModuleMapping':\n          case 'edgeRscModuleMapping':\n          case 'ssrModuleMapping':\n          case 'edgeSSRModuleMapping': {\n            let proxy = mappingProxies.get(prop)\n\n            if (!proxy) {\n              proxy = createMappingProxy(prop)\n              mappingProxies.set(prop, proxy)\n            }\n\n            return proxy\n          }\n          default: {\n            throw new InvariantError(\n              `This is a proxied client reference manifest. The property \"${String(prop)}\" is not handled.`\n            )\n          }\n        }\n      },\n    }\n  ) as DeepReadonly<ClientReferenceManifest>\n}\n\n/**\n * This function creates a Flight-acceptable server module map proxy from our\n * Server Reference Manifest similar to our client module map. This is because\n * our manifest contains a lot of internal Next.js data that are relevant to the\n * runtime, workers, etc. that React doesn't need to know.\n */\nfunction createServerModuleMap(): ServerModuleMap {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          getServerActionsManifest()[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ]?.[id]?.workers\n\n        if (!workers) {\n          return undefined\n        }\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n * with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page\n * name.\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string\n): string | undefined {\n  const serverActionsManifest = getServerActionsManifest()\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n\n  // There are no workers to handle this action, nothing to forward to.\n  if (!workers) {\n    return\n  }\n\n  // If there is an entry for the current page, we don't need to forward.\n  if (workers[normalizeWorkerPageName(pageName)]) {\n    return\n  }\n\n  // Otherwise, grab the first worker that has a handler for this action id.\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\nexport function setManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n}) {\n  const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (existingSingleton) {\n    existingSingleton.clientReferenceManifestsPerRoute.set(\n      normalizeAppPath(page),\n      clientReferenceManifest\n    )\n\n    existingSingleton.serverActionsManifest = serverActionsManifest\n  } else {\n    const clientReferenceManifestsPerRoute = new Map<\n      string,\n      DeepReadonly<ClientReferenceManifest>\n    >([[normalizeAppPath(page), clientReferenceManifest]])\n\n    const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(\n      clientReferenceManifestsPerRoute\n    )\n\n    globalThisWithManifests[MANIFESTS_SINGLETON] = {\n      clientReferenceManifestsPerRoute,\n      proxiedClientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap(),\n    }\n  }\n}\n\nfunction getManifestsSingleton(): ManifestsSingleton {\n  const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (!manifestSingleton) {\n    throw new InvariantError('The manifests singleton was not initialized.')\n  }\n\n  return manifestSingleton\n}\n\nexport function getClientReferenceManifest(): DeepReadonly<ClientReferenceManifest> {\n  return getManifestsSingleton().proxiedClientReferenceManifest\n}\n\nexport function getServerActionsManifest(): DeepReadonly<ActionManifest> {\n  return getManifestsSingleton().serverActionsManifest\n}\n\nexport function getServerModuleMap() {\n  return getManifestsSingleton().serverModuleMap\n}\n"],"names":["InvariantError","normalizeAppPath","pathHasPrefix","removePathPrefix","workAsyncStorage","MANIFESTS_SINGLETON","Symbol","for","globalThisWithManifests","globalThis","createProxiedClientReferenceManifest","clientReferenceManifestsPerRoute","createMappingProxy","prop","Proxy","get","_","id","workStore","getStore","currentManifest","route","process","env","NODE_ENV","manifest","entry","undefined","values","mappingProxies","Map","proxy","set","String","createServerModuleMap","getServerActionsManifest","workers","NEXT_RUNTIME","workerEntry","normalizeWorkerPageName","page","Object","at","moduleId","async","name","chunks","pageName","denormalizeWorkerPageName","bundlePath","selectWorkerForForwarding","actionId","serverActionsManifest","keys","setManifestsSingleton","clientReferenceManifest","existingSingleton","proxiedClientReferenceManifest","serverModuleMap","getManifestsSingleton","manifestSingleton","getClientReferenceManifest","getServerModuleMap"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9842, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/action-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { actionAsyncStorageInstance } from './action-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nexport interface ActionStore {\n  readonly isAction?: boolean\n  readonly isAppRoute?: boolean\n}\n\nexport type ActionAsyncStorage = AsyncLocalStorage<ActionStore>\n\nexport { actionAsyncStorageInstance as actionAsyncStorage }\n"],"names":["actionAsyncStorageInstance","actionAsyncStorage"],"mappings":";AAEA,qDAAqD;AACrD,SAASA,0BAA0B,QAAQ,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 9852, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  dynamicMetadata: null | Error\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    dynamicMetadata: null,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nexport function useDynamicSearchParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore) {\n    // We assume pages router context and just return\n    return\n  }\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(expression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-client': {\n      React.use(\n        makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      )\n      break\n    }\n    case 'prerender-legacy':\n    case 'prerender-ppr': {\n      if (workStore.forceStatic) {\n        return\n      }\n      throw new BailoutToCSRError(expression)\n    }\n    case 'prerender':\n    case 'prerender-runtime':\n      throw new InvariantError(\n        `\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'cache':\n    case 'unstable-cache':\n    case 'private-cache':\n      throw new InvariantError(\n        `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'request':\n      return\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message =\n      `Route \"${workStore.route}\": Uncached data was accessed outside of ` +\n      '<Suspense>. This delays the entire page from rendering, resulting in a ' +\n      'slow user experience. Learn more: ' +\n      'https://nextjs.org/docs/messages/blocking-route'\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nexport function trackDynamicHoleInRuntimeShell(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed inside \\`generateMetadata\\`. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicMetadata = error\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed inside \\`generateViewport\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed outside of \\`<Suspense>\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nexport function trackDynamicHoleInStaticShell(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed inside \\`generateMetadata\\` or you have file-based metadata such as icons that depend on dynamic params segments. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicMetadata = error\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed inside \\`generateViewport\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed outside of \\`<Suspense>\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  // TODO go back to owner stack here if available. This is temporarily using componentStack to get the right\n  //\n  error.stack = error.name + ': ' + message + (ownerStack || componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    logDisallowedDynamicError(\n      workStore,\n      serverDynamic.syncDynamicErrorWithStack\n    )\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function getStaticShellDisallowedDynamicReasons(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState\n): Array<Error> {\n  if (dynamicValidation.hasSuspenseAboveBody) {\n    // This route has opted into allowing fully dynamic rendering\n    // by including a Suspense boundary above the body. In this case\n    // a lack of a shell is not considered disallowed so we simply return\n    return []\n  }\n\n  if (prelude !== PreludeState.Full) {\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      return dynamicErrors\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      return [\n        new InvariantError(\n          `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason.`\n        ),\n      ]\n    }\n  } else {\n    // We have a prelude but we might still have dynamic metadata without any other dynamic access\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.dynamicErrors.length === 0 &&\n      dynamicValidation.dynamicMetadata\n    ) {\n      return [dynamicValidation.dynamicMetadata]\n    }\n  }\n  // We had a non-empty prelude and there are no dynamic holes\n  return []\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n"],"names":["React","DynamicServerError","StaticGenBailoutError","getRuntimeStagePromise","throwForMissingRequestStore","workUnitAsyncStorage","workAsyncStorage","makeHangingPromise","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","scheduleOnNextTick","BailoutToCSRError","InvariantError","hasPostpone","unstable_postpone","createDynamicTrackingState","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","createDynamicValidationState","hasSuspenseAboveBody","hasDynamicMetadata","dynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","getFirstDynamicReason","trackingState","expression","markCurrentScopeAsDynamic","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","route","postponeWithTracking","dynamicTracking","revalidate","err","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","throwToInterruptStaticGeneration","prerenderStore","trackDynamicDataInDynamicRender","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","undefined","abortOnSynchronousPlatformIOAccess","errorWithStack","abortAndThrowOnSynchronousRequestDataAccess","prerenderSignal","signal","aborted","Postpone","getStore","assertPostpone","createPostponeReason","isDynamicPostpone","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","isPrerenderInterruptedError","accessedDynamicData","length","consumeDynamicAccess","serverDynamic","clientDynamic","formatDynamicAPIAccesses","filter","access","map","split","slice","line","join","createRenderInBrowserAbortSignal","AbortController","createHangingInputAbortSignal","cacheSignal","inputReady","then","runtimeStagePromise","annotateDynamicAccess","useDynamicRouteParams","workStore","fallbackParams","fallbackRouteParams","size","use","renderSignal","useDynamicSearchParams","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","hasMetadataRegex","hasViewportRegex","hasOutletRegex","trackAllowedDynamicAccess","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","trackDynamicHoleInRuntimeShell","trackDynamicHoleInStaticShell","ownerStack","captureOwnerStack","name","PreludeState","logDisallowedDynamicError","console","dev","hasReadableErrorStacks","throwIfDisallowedDynamic","prelude","i","getStaticShellDisallowedDynamicReasons","delayUntilRuntimeStage","result"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10622, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/staged-rendering.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n\nexport enum RenderStage {\n  Before = 1,\n  Static = 2,\n  Runtime = 3,\n  Dynamic = 4,\n  Abandoned = 5,\n}\n\nexport type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n\nexport class StagedRenderingController {\n  currentStage: RenderStage = RenderStage.Before\n\n  staticInterruptReason: Error | null = null\n  runtimeInterruptReason: Error | null = null\n  staticStageEndTime: number = Infinity\n  runtimeStageEndTime: number = Infinity\n\n  private runtimeStageListeners: Array<() => void> = []\n  private dynamicStageListeners: Array<() => void> = []\n\n  private runtimeStagePromise = createPromiseWithResolvers<void>()\n  private dynamicStagePromise = createPromiseWithResolvers<void>()\n\n  private mayAbandon: boolean = false\n\n  constructor(\n    private abortSignal: AbortSignal | null = null,\n    private hasRuntimePrefetch: boolean\n  ) {\n    if (abortSignal) {\n      abortSignal.addEventListener(\n        'abort',\n        () => {\n          const { reason } = abortSignal\n          if (this.currentStage < RenderStage.Runtime) {\n            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.runtimeStagePromise.reject(reason)\n          }\n          if (\n            this.currentStage < RenderStage.Dynamic ||\n            this.currentStage === RenderStage.Abandoned\n          ) {\n            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.dynamicStagePromise.reject(reason)\n          }\n        },\n        { once: true }\n      )\n\n      this.mayAbandon = true\n    }\n  }\n\n  onStage(stage: NonStaticRenderStage, callback: () => void) {\n    if (this.currentStage >= stage) {\n      callback()\n    } else if (stage === RenderStage.Runtime) {\n      this.runtimeStageListeners.push(callback)\n    } else if (stage === RenderStage.Dynamic) {\n      this.dynamicStageListeners.push(callback)\n    } else {\n      // This should never happen\n      throw new InvariantError(`Invalid render stage: ${stage}`)\n    }\n  }\n\n  canSyncInterrupt() {\n    // If we haven't started the render yet, it can't be interrupted.\n    if (this.currentStage === RenderStage.Before) {\n      return false\n    }\n\n    const boundaryStage = this.hasRuntimePrefetch\n      ? RenderStage.Dynamic\n      : RenderStage.Runtime\n    return this.currentStage < boundaryStage\n  }\n\n  syncInterruptCurrentStageWithReason(reason: Error) {\n    if (this.currentStage === RenderStage.Before) {\n      return\n    }\n\n    // If Sync IO occurs during the initial (abandonable) render, we'll retry it,\n    // so we want a slightly different flow.\n    // See the implementation of `abandonRenderImpl` for more explanation.\n    if (this.mayAbandon) {\n      return this.abandonRenderImpl()\n    }\n\n    // If we're in the final render, we cannot abandon it. We need to advance to the Dynamic stage\n    // and capture the interruption reason.\n    switch (this.currentStage) {\n      case RenderStage.Static: {\n        this.staticInterruptReason = reason\n        this.advanceStage(RenderStage.Dynamic)\n        return\n      }\n      case RenderStage.Runtime: {\n        // We only error for Sync IO in the runtime stage if the route\n        // is configured to use runtime prefetching.\n        // We do this to reflect the fact that during a runtime prefetch,\n        // Sync IO aborts aborts the render.\n        // Note that `canSyncInterrupt` should prevent us from getting here at all\n        // if runtime prefetching isn't enabled.\n        if (this.hasRuntimePrefetch) {\n          this.runtimeInterruptReason = reason\n          this.advanceStage(RenderStage.Dynamic)\n        }\n        return\n      }\n      case RenderStage.Dynamic:\n      case RenderStage.Abandoned:\n      default:\n    }\n  }\n\n  getStaticInterruptReason() {\n    return this.staticInterruptReason\n  }\n\n  getRuntimeInterruptReason() {\n    return this.runtimeInterruptReason\n  }\n\n  getStaticStageEndTime() {\n    return this.staticStageEndTime\n  }\n\n  getRuntimeStageEndTime() {\n    return this.runtimeStageEndTime\n  }\n\n  abandonRender() {\n    if (!this.mayAbandon) {\n      throw new InvariantError(\n        '`abandonRender` called on a stage controller that cannot be abandoned.'\n      )\n    }\n\n    this.abandonRenderImpl()\n  }\n\n  private abandonRenderImpl() {\n    // In staged rendering, only the initial render is abandonable.\n    // We can abandon the initial render if\n    //   1. We notice a cache miss, and need to wait for caches to fill\n    //   2. A sync IO error occurs, and the render should be interrupted\n    //      (this might be a lazy intitialization of a module,\n    //       so we still want to restart in this case and see if it still occurs)\n    // In either case, we'll be doing another render after this one,\n    // so we only want to unblock the Runtime stage, not Dynamic, because\n    // unblocking the dynamic stage would likely lead to wasted (uncached) IO.\n    const { currentStage } = this\n    switch (currentStage) {\n      case RenderStage.Static: {\n        this.currentStage = RenderStage.Abandoned\n        this.resolveRuntimeStage()\n        return\n      }\n      case RenderStage.Runtime: {\n        this.currentStage = RenderStage.Abandoned\n        return\n      }\n      case RenderStage.Dynamic:\n      case RenderStage.Before:\n      case RenderStage.Abandoned:\n        break\n      default: {\n        currentStage satisfies never\n      }\n    }\n  }\n\n  advanceStage(\n    stage: RenderStage.Static | RenderStage.Runtime | RenderStage.Dynamic\n  ) {\n    // If we're already at the target stage or beyond, do nothing.\n    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n    if (stage <= this.currentStage) {\n      return\n    }\n\n    let currentStage = this.currentStage\n    this.currentStage = stage\n\n    if (currentStage < RenderStage.Runtime && stage >= RenderStage.Runtime) {\n      this.staticStageEndTime = performance.now() + performance.timeOrigin\n      this.resolveRuntimeStage()\n    }\n    if (currentStage < RenderStage.Dynamic && stage >= RenderStage.Dynamic) {\n      this.runtimeStageEndTime = performance.now() + performance.timeOrigin\n      this.resolveDynamicStage()\n      return\n    }\n  }\n\n  /** Fire the `onStage` listeners for the runtime stage and unblock any promises waiting for it. */\n  private resolveRuntimeStage() {\n    const runtimeListeners = this.runtimeStageListeners\n    for (let i = 0; i < runtimeListeners.length; i++) {\n      runtimeListeners[i]()\n    }\n    runtimeListeners.length = 0\n    this.runtimeStagePromise.resolve()\n  }\n\n  /** Fire the `onStage` listeners for the dynamic stage and unblock any promises waiting for it. */\n  private resolveDynamicStage() {\n    const dynamicListeners = this.dynamicStageListeners\n    for (let i = 0; i < dynamicListeners.length; i++) {\n      dynamicListeners[i]()\n    }\n    dynamicListeners.length = 0\n    this.dynamicStagePromise.resolve()\n  }\n\n  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n    switch (stage) {\n      case RenderStage.Runtime: {\n        return this.runtimeStagePromise.promise\n      }\n      case RenderStage.Dynamic: {\n        return this.dynamicStagePromise.promise\n      }\n      default: {\n        stage satisfies never\n        throw new InvariantError(`Invalid render stage: ${stage}`)\n      }\n    }\n  }\n\n  waitForStage(stage: NonStaticRenderStage) {\n    return this.getStagePromise(stage)\n  }\n\n  delayUntilStage<T>(\n    stage: NonStaticRenderStage,\n    displayName: string | undefined,\n    resolvedValue: T\n  ) {\n    const ioTriggerPromise = this.getStagePromise(stage)\n\n    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n      ioTriggerPromise,\n      displayName,\n      resolvedValue\n    )\n\n    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n    if (this.abortSignal) {\n      promise.catch(ignoreReject)\n    }\n    return promise\n  }\n}\n\nfunction ignoreReject() {}\n\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger<T>(\n  ioTrigger: Promise<any>,\n  displayName: string | undefined,\n  resolvedValue: T\n): Promise<T> {\n  // If we create a `new Promise` and give it a displayName\n  // (with no userspace code above us in the stack)\n  // React Devtools will use it as the IO cause when determining \"suspended by\".\n  // In particular, it should shadow any inner IO that resolved/rejected the promise\n  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n  const promise = new Promise<T>((resolve, reject) => {\n    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n  })\n  if (displayName !== undefined) {\n    // @ts-expect-error\n    promise.displayName = displayName\n  }\n  return promise\n}\n"],"names":["InvariantError","createPromiseWithResolvers","RenderStage","StagedRenderingController","constructor","abortSignal","hasRuntimePrefetch","currentStage","staticInterruptReason","runtimeInterruptReason","staticStageEndTime","Infinity","runtimeStageEndTime","runtimeStageListeners","dynamicStageListeners","runtimeStagePromise","dynamicStagePromise","mayAbandon","addEventListener","reason","promise","catch","ignoreReject","reject","once","onStage","stage","callback","push","canSyncInterrupt","boundaryStage","syncInterruptCurrentStageWithReason","abandonRenderImpl","advanceStage","getStaticInterruptReason","getRuntimeInterruptReason","getStaticStageEndTime","getRuntimeStageEndTime","abandonRender","resolveRuntimeStage","performance","now","timeOrigin","resolveDynamicStage","runtimeListeners","i","length","resolve","dynamicListeners","getStagePromise","waitForStage","delayUntilStage","displayName","resolvedValue","ioTriggerPromise","makeDevtoolsIOPromiseFromIOTrigger","ioTrigger","Promise","then","bind","undefined"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10883, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/dynamic-access-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { DynamicAccessStorage } from './dynamic-access-async-storage.external'\n\nexport const dynamicAccessAsyncStorageInstance: DynamicAccessStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","dynamicAccessAsyncStorageInstance"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAGxD,MAAMC,wCACXD,gPAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 10894, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/dynamic-access-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { dynamicAccessAsyncStorageInstance } from './dynamic-access-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport interface DynamicAccessAsyncStore {\n  readonly abortController: AbortController\n}\n\nexport type DynamicAccessStorage = AsyncLocalStorage<DynamicAccessAsyncStore>\nexport { dynamicAccessAsyncStorageInstance as dynamicAccessAsyncStorage }\n"],"names":["dynamicAccessAsyncStorageInstance","dynamicAccessAsyncStorage"],"mappings":";AAEA,qDAAqD;AACrD,SAASA,iCAAiC,QAAQ,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 10913, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/rsc/preloads.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\nimport ReactDOM from 'react-dom'\n\nexport function preloadStyle(\n  href: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = { as: 'style' }\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ReactDOM.preload(href, opts)\n}\n\nexport function preloadFont(\n  href: string,\n  type: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = { as: 'font', type }\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ReactDOM.preload(href, opts)\n}\n\nexport function preconnect(\n  href: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = {}\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ;(ReactDOM as any).preconnect(href, opts)\n}\n"],"names":["ReactDOM","preloadStyle","href","crossOrigin","nonce","opts","as","preload","preloadFont","type","preconnect"],"mappings":";;;;;;;;AAAA;;;;AAIA,GAEA,OAAOA,cAAc,YAAW;;AAEzB,SAASC,aACdC,IAAY,EACZC,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY;QAAEC,IAAI;IAAQ;IAChC,IAAI,OAAOH,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;IACAJ,6NAAAA,CAASO,OAAO,CAACL,MAAMG;AACzB;AAEO,SAASG,YACdN,IAAY,EACZO,IAAY,EACZN,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY;QAAEC,IAAI;QAAQG;IAAK;IACrC,IAAI,OAAON,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;IACAJ,6NAAAA,CAASO,OAAO,CAACL,MAAMG;AACzB;AAEO,SAASK,WACdR,IAAY,EACZC,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY,CAAC;IACnB,IAAI,OAAOF,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;;IACEJ,6NAAAA,CAAiBU,UAAU,CAACR,MAAMG;AACtC","ignoreList":[0]}},
    {"offset": {"line": 10967, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/rsc/postpone.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\n// When postpone is available in canary React we can switch to importing it directly\nexport { Postpone } from '../dynamic-rendering'\n"],"names":["Postpone"],"mappings":";AAAA;;;;AAIA,GAEA,oFAAoF;AACpF,SAASA,QAAQ,QAAQ,uBAAsB","ignoreList":[0]}},
    {"offset": {"line": 10979, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/rsc/taint.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\nimport * as React from 'react'\n\ntype Reference = object\ntype TaintableUniqueValue = string | bigint | ArrayBufferView\n\nfunction notImplemented() {\n  throw new Error('Taint can only be used with the taint flag.')\n}\n\nexport const taintObjectReference: (\n  message: string | undefined,\n  object: Reference\n) => void = process.env.__NEXT_EXPERIMENTAL_REACT\n  ? // @ts-ignore\n    React.experimental_taintObjectReference\n  : notImplemented\nexport const taintUniqueValue: (\n  message: string | undefined,\n  lifetime: Reference,\n  value: TaintableUniqueValue\n) => void = process.env.__NEXT_EXPERIMENTAL_REACT\n  ? // @ts-ignore\n    React.experimental_taintUniqueValue\n  : notImplemented\n"],"names":["React","notImplemented","Error","taintObjectReference","process","env","__NEXT_EXPERIMENTAL_REACT","experimental_taintObjectReference","taintUniqueValue","experimental_taintUniqueValue"],"mappings":";;;;;;AAAA;;;;AAIA,GAEA,YAAYA,WAAW,QAAO;;AAK9B,SAASC;IACP,MAAM,OAAA,cAAwD,CAAxD,IAAIC,MAAM,gDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAuD;AAC/D;AAEO,MAAMC,uBAGDC,QAAQC,GAAG,CAACC,yBAAyB,CAE7CN,MAAMO,oBACNN,aADuC,EACzB;AACX,MAAMO,mBAIDJ,QAAQC,GAAG,CAACC,yBAAyB,CAE7CN,MAAMS,oBACNR,SADmC,MACrB","ignoreList":[0]}},
    {"offset": {"line": 11004, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/react-large-shell-error.ts"],"sourcesContent":["// TODO: isWellKnownError -> isNextInternalError\n// isReactLargeShellError -> isWarning\nexport function isReactLargeShellError(\n  error: unknown\n): error is Error & { digest?: string } {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof error.message === 'string' &&\n    error.message.startsWith('This rendered a large document (>')\n  )\n}\n"],"names":["isReactLargeShellError","error","message","startsWith"],"mappings":"AAAA,gDAAgD;AAChD,sCAAsC;;;;;AAC/B,SAASA,uBACdC,KAAc;IAEd,OACE,OAAOA,UAAU,YACjBA,UAAU,QACV,aAAaA,SACb,OAAOA,MAAMC,OAAO,KAAK,YACzBD,MAAMC,OAAO,CAACC,UAAU,CAAC;AAE7B","ignoreList":[0]}},
    {"offset": {"line": 11017, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/create-error-handler.tsx"],"sourcesContent":["import type { ErrorInfo } from 'react'\nimport stringHash from 'next/dist/compiled/string-hash'\n\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\n\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\nimport { isReactLargeShellError } from './react-large-shell-error'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string; environmentName?: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  // If this is a prerender interrupted error, we don't need to log the error.\n  if (isPrerenderInterruptedError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  onReactServerRenderError: (err: DigestedError, silenceLog: boolean) => void,\n  spanToRecordOn?: any\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let err = getProperError(thrownValue) as DigestedError\n    let silenceLog = false\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (\n        process.env.NODE_ENV === 'production' &&\n        reactServerErrors.has(err.digest)\n      ) {\n        // This error is likely an obfuscated error from another react-server\n        // environment (e.g. 'use cache'). We recover the original error here\n        // for reporting purposes.\n        err = reactServerErrors.get(err.digest)!\n        // We don't log it again though, as it was already logged in the\n        // original environment.\n        silenceLog = true\n      } else {\n        // Either we're in development (where we want to keep the transported\n        // error with environmentName), or the error is not in reactServerErrors\n        // but has a digest from other means. Keep the error as-is.\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n        stringHash(err.message + (err.stack || '')).toString()\n      )\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception on the provided span if available, otherwise try active span.\n      const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setAttribute('error.type', err.name)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      onReactServerRenderError(err, silenceLog)\n    }\n\n    return err.digest\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void,\n  spanToRecordOn?: any\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        stringHash(\n          err.message + (errorInfo?.componentStack || err.stack || '')\n        ).toString()\n      )\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // HTML errors contain RSC errors as well, filter them out before reporting\n      if (isSSRError) {\n        // Record exception on the provided span if available, otherwise try active span.\n        const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n        if (span) {\n          span.recordException(err)\n          span.setAttribute('error.type', err.name)\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message,\n          })\n        }\n\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return err.digest\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n"],"names":["stringHash","formatServerError","SpanStatusCode","getTracer","isAbortError","isBailoutToCSRError","isDynamicServerError","isNextRouterError","isPrerenderInterruptedError","getProperError","createDigestWithErrorCode","isReactLargeShellError","getDigestForWellKnownError","error","digest","undefined","createReactServerErrorHandler","shouldFormatError","isNextExport","reactServerErrors","onReactServerRenderError","spanToRecordOn","thrownValue","err","toString","console","silenceLog","process","env","NODE_ENV","has","get","message","stack","set","includes","span","getActiveScopeSpan","recordException","setAttribute","name","setStatus","code","ERROR","createHTMLErrorHandler","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","push","componentStack","isUserLandError"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11185, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/prospective-render-utils.ts"],"sourcesContent":["import { getDigestForWellKnownError } from './create-error-handler'\nimport { isReactLargeShellError } from './react-large-shell-error'\n\nexport enum Phase {\n  ProspectiveRender = 'the prospective render',\n  SegmentCollection = 'segment collection',\n}\n\nexport function printDebugThrownValueForProspectiveRender(\n  thrownValue: unknown,\n  route: string,\n  phase: Phase\n) {\n  // We don't need to print well-known Next.js errors.\n  if (getDigestForWellKnownError(thrownValue)) {\n    return\n  }\n\n  if (isReactLargeShellError(thrownValue)) {\n    // TODO: Aggregate\n    console.error(thrownValue)\n    return undefined\n  }\n\n  let message: undefined | string\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    typeof (thrownValue as any).message === 'string'\n  ) {\n    message = (thrownValue as any).message\n    if (typeof (thrownValue as any).stack === 'string') {\n      const originalErrorStack: string = (thrownValue as any).stack\n      const stackStart = originalErrorStack.indexOf('\\n')\n      if (stackStart > -1) {\n        const error = new Error(\n          `Route ${route} errored during ${phase}. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled.\n          \nOriginal Error: ${message}`\n        )\n        error.stack =\n          'Error: ' + error.message + originalErrorStack.slice(stackStart)\n        console.error(error)\n        return\n      }\n    }\n  } else if (typeof thrownValue === 'string') {\n    message = thrownValue\n  }\n\n  if (message) {\n    console.error(`Route ${route} errored during ${phase}. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. No stack was provided.\n          \nOriginal Message: ${message}`)\n    return\n  }\n\n  console.error(\n    `Route ${route} errored during ${phase}. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. The thrown value is logged just following this message`\n  )\n  console.error(thrownValue)\n  return\n}\n"],"names":["getDigestForWellKnownError","isReactLargeShellError","Phase","printDebugThrownValueForProspectiveRender","thrownValue","route","phase","console","error","undefined","message","stack","originalErrorStack","stackStart","indexOf","Error","slice"],"mappings":";;;;;;AAAA,SAASA,0BAA0B,QAAQ,yBAAwB;AACnE,SAASC,sBAAsB,QAAQ,4BAA2B;;;AAE3D,IAAKC,QAAAA,WAAAA,GAAAA,SAAAA,KAAAA;;;WAAAA;MAGX;AAEM,SAASC,0CACdC,WAAoB,EACpBC,KAAa,EACbC,KAAY;IAEZ,oDAAoD;IACpD,QAAIN,iPAAAA,EAA2BI,cAAc;QAC3C;IACF;IAEA,QAAIH,mPAAAA,EAAuBG,cAAc;QACvC,kBAAkB;QAClBG,QAAQC,KAAK,CAACJ;QACd,OAAOK;IACT;IAEA,IAAIC;IACJ,IACE,OAAON,gBAAgB,YACvBA,gBAAgB,QAChB,OAAQA,YAAoBM,OAAO,KAAK,UACxC;QACAA,UAAWN,YAAoBM,OAAO;QACtC,IAAI,OAAQN,YAAoBO,KAAK,KAAK,UAAU;YAClD,MAAMC,qBAA8BR,YAAoBO,KAAK;YAC7D,MAAME,aAAaD,mBAAmBE,OAAO,CAAC;YAC9C,IAAID,aAAa,CAAC,GAAG;gBACnB,MAAML,QAAQ,OAAA,cAIb,CAJa,IAAIO,MAChB,CAAC,MAAM,EAAEV,MAAM,gBAAgB,EAAEC,MAAM;;gBAEjC,EAAEI,SAAS,GAHL,qBAAA;2BAAA;gCAAA;kCAAA;gBAId;gBACAF,MAAMG,KAAK,GACT,YAAYH,MAAME,OAAO,GAAGE,mBAAmBI,KAAK,CAACH;gBACvDN,QAAQC,KAAK,CAACA;gBACd;YACF;QACF;IACF,OAAO,IAAI,OAAOJ,gBAAgB,UAAU;QAC1CM,UAAUN;IACZ;IAEA,IAAIM,SAAS;QACXH,QAAQC,KAAK,CAAC,CAAC,MAAM,EAAEH,MAAM,gBAAgB,EAAEC,MAAM;;kBAEvC,EAAEI,SAAS;QACzB;IACF;IAEAH,QAAQC,KAAK,CACX,CAAC,MAAM,EAAEH,MAAM,gBAAgB,EAAEC,MAAM,kMAAkM,CAAC;IAE5OC,QAAQC,KAAK,CAACJ;IACd;AACF","ignoreList":[0]}},
    {"offset": {"line": 11246, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/collect-segment-data.tsx"],"sourcesContent":["/* eslint-disable @next/internal/no-ambiguous-jsx -- Bundled in entry-base so it gets the right JSX runtime. */\nimport type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  InitialRSCPayload,\n  DynamicParamTypesShort,\n  HeadData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-types'\nimport type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { prerender } from 'react-server-dom-webpack/static'\n\nimport {\n  streamFromBuffer,\n  streamToBuffer,\n} from '../stream-utils/node-web-streams-helper'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  type SegmentRequestKey,\n  createSegmentRequestKeyPart,\n  appendSegmentRequestKeyPart,\n  ROOT_SEGMENT_REQUEST_KEY,\n  HEAD_REQUEST_KEY,\n} from '../../shared/lib/segment-cache/segment-value-encoding'\nimport { getDigestForWellKnownError } from './create-error-handler'\nimport {\n  Phase,\n  printDebugThrownValueForProspectiveRender,\n} from './prospective-render-utils'\nimport { workAsyncStorage } from './work-async-storage.external'\n\n// Contains metadata about the route tree. The client must fetch this before\n// it can fetch any actual segment data.\nexport type RootTreePrefetch = {\n  buildId: string\n  tree: TreePrefetch\n  staleTime: number\n}\n\nexport type TreePrefetch = {\n  name: string\n  paramType: DynamicParamTypesShort | null\n  // When cacheComponents is enabled, this field is always null.\n  // Instead we parse the param on the client, allowing us to omit it from\n  // the prefetch response and increase its cacheability.\n  paramKey: string | null\n\n  // Child segments.\n  slots: null | {\n    [parallelRouteKey: string]: TreePrefetch\n  }\n\n  /** Whether this segment should be fetched using a runtime prefetch */\n  hasRuntimePrefetch: boolean\n\n  // Extra fields that only exist so we can reconstruct a FlightRouterState on\n  // the client. We may be able to unify TreePrefetch and FlightRouterState\n  // after some refactoring, but in the meantime it would be wasteful to add a\n  // bunch of new prefetch-only fields to FlightRouterState. So think of\n  // TreePrefetch as a superset of FlightRouterState.\n  isRootLayout: boolean\n}\n\nexport type SegmentPrefetch = {\n  buildId: string\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n}\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\nfunction onSegmentPrerenderError(error: unknown) {\n  const digest = getDigestForWellKnownError(error)\n  if (digest) {\n    return digest\n  }\n  // We don't need to log the errors because we would have already done that\n  // when generating the original Flight stream for the whole page.\n  if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n    const workStore = workAsyncStorage.getStore()\n    printDebugThrownValueForProspectiveRender(\n      error,\n      workStore?.route ?? 'unknown route',\n      Phase.SegmentCollection\n    )\n  }\n}\n\nexport async function collectSegmentData(\n  isCacheComponentsEnabled: boolean,\n  fullPageDataBuffer: Buffer,\n  staleTime: number,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any\n): Promise<Map<SegmentRequestKey, Buffer>> {\n  // Traverse the router tree and generate a prefetch response for each segment.\n\n  // A mutable map to collect the results as we traverse the route tree.\n  const resultMap = new Map<SegmentRequestKey, Buffer>()\n\n  // Before we start, warm up the module cache by decoding the page data once.\n  // Then we can assume that any remaining async tasks that occur the next time\n  // are due to hanging promises caused by dynamic data access. Note we only\n  // have to do this once per page, not per individual segment.\n  //\n  try {\n    await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n      findSourceMapURL,\n      serverConsumerManifest,\n    })\n    await waitAtLeastOneReactRenderTask()\n  } catch {}\n\n  // Create an abort controller that we'll use to stop the stream.\n  const abortController = new AbortController()\n  const onCompletedProcessingRouteTree = async () => {\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // serializing the stream takes longer than a microtask, it must because of\n    // hanging promises caused by dynamic data.\n    await waitAtLeastOneReactRenderTask()\n    abortController.abort()\n  }\n\n  // Generate a stream for the route tree prefetch. While we're walking the\n  // tree, we'll also spawn additional tasks to generate the segment prefetches.\n  // The promises for these tasks are pushed to a mutable array that we will\n  // await once the route tree is fully rendered.\n  const segmentTasks: Array<Promise<[SegmentRequestKey, Buffer]>> = []\n  const { prelude: treeStream } = await prerender(\n    // RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    <PrefetchTreeData\n      isClientParamParsingEnabled={isCacheComponentsEnabled}\n      fullPageDataBuffer={fullPageDataBuffer}\n      serverConsumerManifest={serverConsumerManifest}\n      clientModules={clientModules}\n      staleTime={staleTime}\n      segmentTasks={segmentTasks}\n      onCompletedProcessingRouteTree={onCompletedProcessingRouteTree}\n    />,\n    clientModules,\n    {\n      filterStackFrame,\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n\n  // Write the route tree to a special `/_tree` segment.\n  const treeBuffer = await streamToBuffer(treeStream)\n  resultMap.set('/_tree' as SegmentRequestKey, treeBuffer)\n\n  // Also output the entire full page data response\n  resultMap.set('/_full' as SegmentRequestKey, fullPageDataBuffer)\n\n  // Now that we've finished rendering the route tree, all the segment tasks\n  // should have been spawned. Await them in parallel and write the segment\n  // prefetches to the result map.\n  for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {\n    resultMap.set(segmentPath, buffer)\n  }\n\n  return resultMap\n}\n\nasync function PrefetchTreeData({\n  isClientParamParsingEnabled,\n  fullPageDataBuffer,\n  serverConsumerManifest,\n  clientModules,\n  staleTime,\n  segmentTasks,\n  onCompletedProcessingRouteTree,\n}: {\n  isClientParamParsingEnabled: boolean\n  fullPageDataBuffer: Buffer\n  serverConsumerManifest: any\n  clientModules: ManifestNode\n  staleTime: number\n  segmentTasks: Array<Promise<[SegmentRequestKey, Buffer]>>\n  onCompletedProcessingRouteTree: () => void\n}): Promise<RootTreePrefetch | null> {\n  // We're currently rendering a Flight response for the route tree prefetch.\n  // Inside this component, decode the Flight stream for the whole page. This is\n  // a hack to transfer the side effects from the original Flight stream (e.g.\n  // Float preloads) onto the Flight stream for the tree prefetch.\n  // TODO: React needs a better way to do this. Needed for Server Actions, too.\n  const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(\n    createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)),\n    {\n      findSourceMapURL,\n      serverConsumerManifest,\n    }\n  )\n\n  const buildId = initialRSCPayload.b\n\n  // FlightDataPath is an unsound type, hence the additional checks.\n  const flightDataPaths = initialRSCPayload.f\n  if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n    console.error(\n      'Internal Next.js error: InitialRSCPayload does not match the expected ' +\n        'shape for a prerendered page during segment prefetch generation.'\n    )\n    return null\n  }\n  const flightRouterState: FlightRouterState = flightDataPaths[0][0]\n  const seedData: CacheNodeSeedData = flightDataPaths[0][1]\n  const head: HeadData = flightDataPaths[0][2]\n\n  // Compute the route metadata tree by traversing the FlightRouterState. As we\n  // walk the tree, we will also spawn a task to produce a prefetch response for\n  // each segment.\n  const tree = collectSegmentDataImpl(\n    isClientParamParsingEnabled,\n    flightRouterState,\n    buildId,\n    seedData,\n    clientModules,\n    ROOT_SEGMENT_REQUEST_KEY,\n    segmentTasks\n  )\n\n  // Also spawn a task to produce a prefetch response for the \"head\" segment.\n  // The head contains metadata, like the title; it's not really a route\n  // segment, but it contains RSC data, so it's treated like a segment by\n  // the client cache.\n  segmentTasks.push(\n    waitAtLeastOneReactRenderTask().then(() =>\n      renderSegmentPrefetch(\n        buildId,\n        head,\n        null,\n        HEAD_REQUEST_KEY,\n        clientModules\n      )\n    )\n  )\n\n  // Notify the abort controller that we're done processing the route tree.\n  // Anything async that happens after this point must be due to hanging\n  // promises in the original stream.\n  onCompletedProcessingRouteTree()\n\n  // Render the route tree to a special `/_tree` segment.\n  const treePrefetch: RootTreePrefetch = {\n    buildId,\n    tree,\n    staleTime,\n  }\n  return treePrefetch\n}\n\nfunction collectSegmentDataImpl(\n  isClientParamParsingEnabled: boolean,\n  route: FlightRouterState,\n  buildId: string,\n  seedData: CacheNodeSeedData | null,\n  clientModules: ManifestNode,\n  requestKey: SegmentRequestKey,\n  segmentTasks: Array<Promise<[string, Buffer]>>\n): TreePrefetch {\n  // Metadata about the segment. Sent as part of the tree prefetch. Null if\n  // there are no children.\n  let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null\n\n  const children = route[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  for (const parallelRouteKey in children) {\n    const childRoute = children[parallelRouteKey]\n    const childSegment = childRoute[0]\n    const childSeedData =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      createSegmentRequestKeyPart(childSegment)\n    )\n    const childTree = collectSegmentDataImpl(\n      isClientParamParsingEnabled,\n      childRoute,\n      buildId,\n      childSeedData,\n      clientModules,\n      childRequestKey,\n      segmentTasks\n    )\n    if (slotMetadata === null) {\n      slotMetadata = {}\n    }\n    slotMetadata[parallelRouteKey] = childTree\n  }\n\n  const hasRuntimePrefetch = seedData !== null ? seedData[4] : false\n\n  if (seedData !== null) {\n    // Spawn a task to write the segment data to a new Flight stream.\n    segmentTasks.push(\n      // Since we're already in the middle of a render, wait until after the\n      // current task to escape the current rendering context.\n      waitAtLeastOneReactRenderTask().then(() =>\n        renderSegmentPrefetch(\n          buildId,\n          seedData[0],\n          seedData[2],\n          requestKey,\n          clientModules\n        )\n      )\n    )\n  } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n  }\n\n  const segment = route[0]\n  let name\n  let paramType: DynamicParamTypesShort | null = null\n  let paramKey: string | null = null\n  if (typeof segment === 'string') {\n    name = segment\n    paramKey = segment\n    paramType = null\n  } else {\n    name = segment[0]\n    paramKey = segment[1]\n    paramType = segment[2] as DynamicParamTypesShort\n  }\n\n  // Metadata about the segment. Sent to the client as part of the\n  // tree prefetch.\n  return {\n    name,\n    paramType,\n    // This value is ommitted from the prefetch response when cacheComponents\n    // is enabled.\n    paramKey: isClientParamParsingEnabled ? null : paramKey,\n    hasRuntimePrefetch,\n    slots: slotMetadata,\n    isRootLayout: route[4] === true,\n  }\n}\n\nasync function renderSegmentPrefetch(\n  buildId: string,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  requestKey: SegmentRequestKey,\n  clientModules: ManifestNode\n): Promise<[SegmentRequestKey, Buffer]> {\n  // Render the segment data to a stream.\n  // In the future, this is where we can include additional metadata, like the\n  // stale time and cache tags.\n  const segmentPrefetch: SegmentPrefetch = {\n    buildId,\n    rsc,\n    loading,\n    isPartial: await isPartialRSCData(rsc, clientModules),\n  }\n  // Since all we're doing is decoding and re-encoding a cached prerender, if\n  // it takes longer than a microtask, it must because of hanging promises\n  // caused by dynamic data. Abort the stream at the end of the current task.\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => abortController.abort())\n  const { prelude: segmentStream } = await prerender(\n    segmentPrefetch,\n    clientModules,\n    {\n      filterStackFrame,\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n  const segmentBuffer = await streamToBuffer(segmentStream)\n  if (requestKey === ROOT_SEGMENT_REQUEST_KEY) {\n    return ['/_index' as SegmentRequestKey, segmentBuffer]\n  } else {\n    return [requestKey, segmentBuffer]\n  }\n}\n\nasync function isPartialRSCData(\n  rsc: React.ReactNode,\n  clientModules: ManifestNode\n): Promise<boolean> {\n  // We can determine if a segment contains only partial data if it takes longer\n  // than a task to encode, because dynamic data is encoded as an infinite\n  // promise. We must do this in a separate Flight prerender from the one that\n  // actually generates the prefetch stream because we need to include\n  // `isPartial` in the stream itself.\n  let isPartial = false\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => {\n    // If we haven't yet finished the outer task, then it must be because we\n    // accessed dynamic data.\n    isPartial = true\n    abortController.abort()\n  })\n  await prerender(rsc, clientModules, {\n    filterStackFrame,\n    signal: abortController.signal,\n    onError() {},\n  })\n  return isPartial\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFromReadableStream","prerender","streamFromBuffer","streamToBuffer","waitAtLeastOneReactRenderTask","createSegmentRequestKeyPart","appendSegmentRequestKeyPart","ROOT_SEGMENT_REQUEST_KEY","HEAD_REQUEST_KEY","getDigestForWellKnownError","Phase","printDebugThrownValueForProspectiveRender","workAsyncStorage","filterStackFrame","process","env","NODE_ENV","require","filterStackFrameDEV","undefined","findSourceMapURL","findSourceMapURLDEV","onSegmentPrerenderError","error","digest","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","workStore","getStore","route","SegmentCollection","collectSegmentData","isCacheComponentsEnabled","fullPageDataBuffer","staleTime","clientModules","serverConsumerManifest","resultMap","Map","abortController","AbortController","onCompletedProcessingRouteTree","abort","segmentTasks","prelude","treeStream","PrefetchTreeData","isClientParamParsingEnabled","signal","onError","treeBuffer","set","segmentPath","buffer","Promise","all","initialRSCPayload","createUnclosingPrefetchStream","buildId","b","flightDataPaths","f","length","console","flightRouterState","seedData","head","tree","collectSegmentDataImpl","push","then","renderSegmentPrefetch","treePrefetch","requestKey","slotMetadata","children","seedDataChildren","parallelRouteKey","childRoute","childSegment","childSeedData","childRequestKey","childTree","hasRuntimePrefetch","segment","name","paramType","paramKey","slots","isRootLayout","rsc","loading","segmentPrefetch","isPartial","isPartialRSCData","segmentStream","segmentBuffer","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11528, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/app-render/entry-base.ts"],"sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nexport {\n  createTemporaryReferenceSet,\n  renderToReadableStream,\n  decodeReply,\n  decodeAction,\n  decodeFormState,\n} from 'react-server-dom-webpack/server'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { prerender } from 'react-server-dom-webpack/static'\n\n// TODO: Just re-export `* as ReactServer`\nexport { captureOwnerStack, createElement, Fragment } from 'react'\n\nexport { default as LayoutRouter } from '../../client/components/layout-router'\nexport { default as RenderFromTemplateContext } from '../../client/components/render-from-template-context'\nexport { workAsyncStorage } from '../app-render/work-async-storage.external'\nexport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nexport { actionAsyncStorage } from '../app-render/action-async-storage.external'\n\nexport { ClientPageRoot } from '../../client/components/client-page'\nexport { ClientSegmentRoot } from '../../client/components/client-segment'\nexport {\n  createServerSearchParamsForServerPage,\n  createPrerenderSearchParamsForClientPage,\n} from '../request/search-params'\nexport {\n  createServerParamsForServerSegment,\n  createPrerenderParamsForClientSegment,\n} from '../request/params'\nexport * as serverHooks from '../../client/components/hooks-server-context'\nexport { HTTPAccessFallbackBoundary } from '../../client/components/http-access-fallback/error-boundary'\nexport { createMetadataComponents } from '../../lib/metadata/metadata'\nexport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\n\nexport { preloadStyle, preloadFont, preconnect } from './rsc/preloads'\nexport { Postpone } from './rsc/postpone'\nexport { taintObjectReference } from './rsc/taint'\nexport { collectSegmentData } from './collect-segment-data'\n\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { patchFetch as _patchFetch } from '../lib/patch-fetch'\n\nlet SegmentViewNode: typeof import('../../next-devtools/userspace/app/segment-explorer-node').SegmentViewNode =\n  () => null\nlet SegmentViewStateNode: typeof import('../../next-devtools/userspace/app/segment-explorer-node').SegmentViewStateNode =\n  () => null\nif (process.env.NODE_ENV === 'development') {\n  const mod =\n    require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n  SegmentViewNode = mod.SegmentViewNode\n  SegmentViewStateNode = mod.SegmentViewStateNode\n}\n\n// For hot-reloader\ndeclare global {\n  var __next__clear_chunk_cache__: (() => void) | null | undefined\n  var __turbopack_clear_chunk_cache__: () => void | null | undefined\n}\n// hot-reloader modules are not bundled so we need to inject `__next__clear_chunk_cache__`\n// into globalThis from this file which is bundled.\nif (process.env.TURBOPACK) {\n  globalThis.__next__clear_chunk_cache__ = __turbopack_clear_chunk_cache__\n} else {\n  // Webpack does not have chunks on the server\n  globalThis.__next__clear_chunk_cache__ = null\n}\n\n// patchFetch makes use of APIs such as `React.unstable_postpone` which are only available\n// in the experimental channel of React, so export it from here so that it comes from the bundled runtime\nexport function patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\n// Development only\nexport { SegmentViewNode, SegmentViewStateNode }\n"],"names":["createTemporaryReferenceSet","renderToReadableStream","decodeReply","decodeAction","decodeFormState","prerender","captureOwnerStack","createElement","Fragment","default","LayoutRouter","RenderFromTemplateContext","workAsyncStorage","workUnitAsyncStorage","actionAsyncStorage","ClientPageRoot","ClientSegmentRoot","createServerSearchParamsForServerPage","createPrerenderSearchParamsForClientPage","createServerParamsForServerSegment","createPrerenderParamsForClientSegment","serverHooks","HTTPAccessFallbackBoundary","createMetadataComponents","RootLayoutBoundary","preloadStyle","preloadFont","preconnect","Postpone","taintObjectReference","collectSegmentData","patchFetch","_patchFetch","SegmentViewNode","SegmentViewStateNode","process","env","NODE_ENV","mod","require","TURBOPACK","globalThis","__next__clear_chunk_cache__","__turbopack_clear_chunk_cache__"],"mappings":";;;;;;;;AAAA,6DAA6D;AAC7D,SACEA,2BAA2B,EAC3BC,sBAAsB,EACtBC,WAAW,EACXC,YAAY,EACZC,eAAe,QACV,kCAAiC;AAExC,6DAA6D;AAC7D,SAASC,SAAS,QAAQ,kCAAiC;AAE3D,0CAA0C;AAC1C,SAASC,iBAAiB,EAAEC,aAAa,EAAEC,QAAQ,QAAQ,QAAO;AAElE,SAASC,WAAWC,YAAY,QAAQ,wCAAuC;AAC/E,SAASD,WAAWE,yBAAyB,QAAQ,uDAAsD;AAC3G,SAASC,gBAAgB,QAAQ,4CAA2C;AAC5E,SAASC,oBAAoB,QAAQ,qCAAoC;AACzE,SAASC,kBAAkB,QAAQ,8CAA6C;AAEhF,SAASC,cAAc,QAAQ,sCAAqC;AACpE,SAASC,iBAAiB,QAAQ,yCAAwC;AAC1E,SACEC,qCAAqC,EACrCC,wCAAwC,QACnC,2BAA0B;AACjC,SACEC,kCAAkC,EAClCC,qCAAqC,QAChC,oBAAmB;AAC1B,OAAO,KAAKC,WAAW,MAAM,+CAA8C;AAC3E,SAASC,0BAA0B,QAAQ,8DAA6D;AACxG,SAASC,wBAAwB,QAAQ,8BAA6B;AACtE,SAASC,kBAAkB,QAAQ,0CAAyC;AAE5E,SAASC,YAAY,EAAEC,WAAW,EAAEC,UAAU,QAAQ,iBAAgB;AACtE,SAASC,QAAQ,QAAQ,iBAAgB;AACzC,SAASC,oBAAoB,QAAQ,cAAa;AAClD,SAASC,kBAAkB,QAAQ,yBAAwB;AAE3D,SAASlB,gBAAgB,QAAQ,4CAA2C;AAC5E,SAASC,oBAAoB,QAAQ,qCAAoC;AACzE,SAASkB,cAAcC,WAAW,QAAQ,qBAAoB;;;;;;;;;;;;;;;;;;;;;;;;AAE9D,IAAIC,kBACF,IAAM;AACR,IAAIC,uBACF,IAAM;AACR,IAAIC,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAe;IAC1C,MAAMC,MACJC,QAAQ;IACVN,kBAAkBK,IAAIL,eAAe;IACrCC,uBAAuBI,IAAIJ,oBAAoB;AACjD;AAOA,0FAA0F;AAC1F,mDAAmD;AACnD,IAAIC,QAAQC,GAAG,CAACI,SAAS,eAAE;IACzBC,WAAWC,2BAA2B,GAAGC;AAC3C,OAAO;;AAOA,SAASZ;IACd,WAAOC,2MAAAA,EAAY;0BACjBpB,oTAAAA;8BACAC,wUAAAA;IACF;AACF","ignoreList":[0]}}]
}