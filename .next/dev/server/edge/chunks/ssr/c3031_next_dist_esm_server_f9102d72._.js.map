{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/internal-utils.ts"],"sourcesContent":["import type { NextParsedUrlQuery } from './request-meta'\n\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n\nconst INTERNAL_QUERY_NAMES = [NEXT_RSC_UNION_QUERY] as const\n\nexport function stripInternalQueries(query: NextParsedUrlQuery) {\n  for (const name of INTERNAL_QUERY_NAMES) {\n    delete query[name]\n  }\n}\n\nexport function stripInternalSearchParams<T extends string | URL>(url: T): T {\n  const isStringUrl = typeof url === 'string'\n  const instance = isStringUrl ? new URL(url) : (url as URL)\n\n  instance.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  return (isStringUrl ? instance.toString() : instance) as T\n}\n"],"names":["NEXT_RSC_UNION_QUERY","INTERNAL_QUERY_NAMES","stripInternalQueries","query","name","stripInternalSearchParams","url","isStringUrl","instance","URL","searchParams","delete","toString"],"mappings":";;;;;;AAEA,SAASA,oBAAoB,QAAQ,0CAAyC;;AAE9E,MAAMC,uBAAuB;IAACD,sOAAAA;CAAqB;AAE5C,SAASE,qBAAqBC,KAAyB;IAC5D,KAAK,MAAMC,QAAQH,qBAAsB;QACvC,OAAOE,KAAK,CAACC,KAAK;IACpB;AACF;AAEO,SAASC,0BAAkDC,GAAM;IACtE,MAAMC,cAAc,OAAOD,QAAQ;IACnC,MAAME,WAAWD,cAAc,IAAIE,IAAIH,OAAQA;IAE/CE,SAASE,YAAY,CAACC,MAAM,CAACX,sOAAAA;IAE7B,OAAQO,cAAcC,SAASI,QAAQ,KAAKJ;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/api-utils/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { CookieSerializeOptions } from 'next/dist/compiled/cookie'\nimport type { NextApiResponse } from '../../shared/lib/utils'\n\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport {\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n} from '../../lib/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NodeSpan } from '../lib/trace/constants'\n\nexport type NextApiRequestCookies = Partial<{ [key: string]: string }>\nexport type NextApiRequestQuery = Partial<{ [key: string]: string | string[] }>\n\nexport type __ApiPreviewProps = {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\n\nexport function wrapApiHandler<T extends (...args: any[]) => any>(\n  page: string,\n  handler: T\n): T {\n  return ((...args) => {\n    getTracer().setRootSpanAttribute('next.route', page)\n    // Call API route method\n    return getTracer().trace(\n      NodeSpan.runHandler,\n      {\n        spanName: `executing api route (pages) ${page}`,\n      },\n      () => handler(...args)\n    )\n  }) as T\n}\n\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */\nexport function sendStatusCode(\n  res: NextApiResponse,\n  statusCode: number\n): NextApiResponse<any> {\n  res.statusCode = statusCode\n  return res\n}\n\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */\nexport function redirect(\n  res: NextApiResponse,\n  statusOrUrl: string | number,\n  url?: string\n): NextApiResponse<any> {\n  if (typeof statusOrUrl === 'string') {\n    url = statusOrUrl\n    statusOrUrl = 307\n  }\n  if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n    throw new Error(\n      `Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`\n    )\n  }\n  res.writeHead(statusOrUrl, { Location: url })\n  res.write(url)\n  res.end()\n  return res\n}\n\nexport function checkIsOnDemandRevalidate(\n  req: Request | IncomingMessage | BaseNextRequest,\n  previewProps: __ApiPreviewProps\n): {\n  isOnDemandRevalidate: boolean\n  revalidateOnlyGenerated: boolean\n} {\n  const headers = HeadersAdapter.from(req.headers)\n\n  const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)\n  const isOnDemandRevalidate = previewModeId === previewProps.previewModeId\n\n  const revalidateOnlyGenerated = headers.has(\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER\n  )\n\n  return { isOnDemandRevalidate, revalidateOnlyGenerated }\n}\n\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`\n\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024\n\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)\n\nexport function clearPreviewData<T>(\n  res: NextApiResponse<T>,\n  options: {\n    path?: string\n  } = {}\n): NextApiResponse<T> {\n  if (SYMBOL_CLEARED_COOKIES in res) {\n    return res\n  }\n\n  const { serialize } =\n    require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')\n  const previous = res.getHeader('Set-Cookie')\n  res.setHeader(`Set-Cookie`, [\n    ...(typeof previous === 'string'\n      ? [previous]\n      : Array.isArray(previous)\n        ? previous\n        : []),\n    serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n    serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n  ])\n\n  Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n    value: true,\n    enumerable: false,\n  })\n  return res\n}\n\n/**\n * Custom error class\n */\nexport class ApiError extends Error {\n  readonly statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n    this.statusCode = statusCode\n  }\n}\n\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */\nexport function sendError(\n  res: NextApiResponse,\n  statusCode: number,\n  message: string\n): void {\n  res.statusCode = statusCode\n  res.statusMessage = message\n  res.end(message)\n}\n\ninterface LazyProps {\n  req: IncomingMessage\n}\n\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */\nexport function setLazyProp<T>(\n  { req }: LazyProps,\n  prop: string,\n  getter: () => T\n): void {\n  const opts = { configurable: true, enumerable: true }\n  const optsReset = { ...opts, writable: true }\n\n  Object.defineProperty(req, prop, {\n    ...opts,\n    get: () => {\n      const value = getter()\n      // we set the property on the object to avoid recalculating it\n      Object.defineProperty(req, prop, { ...optsReset, value })\n      return value\n    },\n    set: (value) => {\n      Object.defineProperty(req, prop, { ...optsReset, value })\n    },\n  })\n}\n"],"names":["HeadersAdapter","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","getTracer","NodeSpan","wrapApiHandler","page","handler","args","setRootSpanAttribute","trace","runHandler","spanName","sendStatusCode","res","statusCode","redirect","statusOrUrl","url","Error","writeHead","Location","write","end","checkIsOnDemandRevalidate","req","previewProps","headers","from","previewModeId","get","isOnDemandRevalidate","revalidateOnlyGenerated","has","COOKIE_NAME_PRERENDER_BYPASS","COOKIE_NAME_PRERENDER_DATA","RESPONSE_LIMIT_DEFAULT","SYMBOL_PREVIEW_DATA","Symbol","SYMBOL_CLEARED_COOKIES","clearPreviewData","options","serialize","require","previous","getHeader","setHeader","Array","isArray","expires","Date","httpOnly","sameSite","process","env","NODE_ENV","secure","path","undefined","Object","defineProperty","value","enumerable","ApiError","constructor","message","sendError","statusMessage","setLazyProp","prop","getter","opts","configurable","optsReset","writable","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/api-utils/get-cookie-parser.ts"],"sourcesContent":["import type { NextApiRequestCookies } from '.'\n\n/**\n * Parse cookies from the `headers` of request\n * @param req request object\n */\n\nexport function getCookieParser(headers: {\n  [key: string]: string | string[] | null | undefined\n}): () => NextApiRequestCookies {\n  return function parseCookie(): NextApiRequestCookies {\n    const { cookie } = headers\n\n    if (!cookie) {\n      return {}\n    }\n\n    const { parse: parseCookieFn } =\n      require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')\n    return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)\n  }\n}\n"],"names":["getCookieParser","headers","parseCookie","cookie","parse","parseCookieFn","require","Array","isArray","join"],"mappings":"AAEA;;;CAGC,GAED;;;;AAAO,SAASA,gBAAgBC,OAE/B;IACC,OAAO,SAASC;QACd,MAAM,EAAEC,MAAM,EAAE,GAAGF;QAEnB,IAAI,CAACE,QAAQ;YACX,OAAO,CAAC;QACV;QAEA,MAAM,EAAEC,OAAOC,aAAa,EAAE,GAC5BC,QAAQ;QACV,OAAOD,cAAcE,MAAMC,OAAO,CAACL,UAAUA,OAAOM,IAAI,CAAC,QAAQN;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/api-utils/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { CookieSerializeOptions } from 'next/dist/compiled/cookie'\nimport type { NextApiResponse } from '../../shared/lib/utils'\n\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport {\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n} from '../../lib/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NodeSpan } from '../lib/trace/constants'\n\nexport type NextApiRequestCookies = Partial<{ [key: string]: string }>\nexport type NextApiRequestQuery = Partial<{ [key: string]: string | string[] }>\n\nexport type __ApiPreviewProps = {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\n\nexport function wrapApiHandler<T extends (...args: any[]) => any>(\n  page: string,\n  handler: T\n): T {\n  return ((...args) => {\n    getTracer().setRootSpanAttribute('next.route', page)\n    // Call API route method\n    return getTracer().trace(\n      NodeSpan.runHandler,\n      {\n        spanName: `executing api route (pages) ${page}`,\n      },\n      () => handler(...args)\n    )\n  }) as T\n}\n\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */\nexport function sendStatusCode(\n  res: NextApiResponse,\n  statusCode: number\n): NextApiResponse<any> {\n  res.statusCode = statusCode\n  return res\n}\n\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */\nexport function redirect(\n  res: NextApiResponse,\n  statusOrUrl: string | number,\n  url?: string\n): NextApiResponse<any> {\n  if (typeof statusOrUrl === 'string') {\n    url = statusOrUrl\n    statusOrUrl = 307\n  }\n  if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n    throw new Error(\n      `Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`\n    )\n  }\n  res.writeHead(statusOrUrl, { Location: url })\n  res.write(url)\n  res.end()\n  return res\n}\n\nexport function checkIsOnDemandRevalidate(\n  req: Request | IncomingMessage | BaseNextRequest,\n  previewProps: __ApiPreviewProps\n): {\n  isOnDemandRevalidate: boolean\n  revalidateOnlyGenerated: boolean\n} {\n  const headers = HeadersAdapter.from(req.headers)\n\n  const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)\n  const isOnDemandRevalidate = previewModeId === previewProps.previewModeId\n\n  const revalidateOnlyGenerated = headers.has(\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER\n  )\n\n  return { isOnDemandRevalidate, revalidateOnlyGenerated }\n}\n\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`\n\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024\n\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)\n\nexport function clearPreviewData<T>(\n  res: NextApiResponse<T>,\n  options: {\n    path?: string\n  } = {}\n): NextApiResponse<T> {\n  if (SYMBOL_CLEARED_COOKIES in res) {\n    return res\n  }\n\n  const { serialize } =\n    require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')\n  const previous = res.getHeader('Set-Cookie')\n  res.setHeader(`Set-Cookie`, [\n    ...(typeof previous === 'string'\n      ? [previous]\n      : Array.isArray(previous)\n        ? previous\n        : []),\n    serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n    serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n  ])\n\n  Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n    value: true,\n    enumerable: false,\n  })\n  return res\n}\n\n/**\n * Custom error class\n */\nexport class ApiError extends Error {\n  readonly statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n    this.statusCode = statusCode\n  }\n}\n\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */\nexport function sendError(\n  res: NextApiResponse,\n  statusCode: number,\n  message: string\n): void {\n  res.statusCode = statusCode\n  res.statusMessage = message\n  res.end(message)\n}\n\ninterface LazyProps {\n  req: IncomingMessage\n}\n\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */\nexport function setLazyProp<T>(\n  { req }: LazyProps,\n  prop: string,\n  getter: () => T\n): void {\n  const opts = { configurable: true, enumerable: true }\n  const optsReset = { ...opts, writable: true }\n\n  Object.defineProperty(req, prop, {\n    ...opts,\n    get: () => {\n      const value = getter()\n      // we set the property on the object to avoid recalculating it\n      Object.defineProperty(req, prop, { ...optsReset, value })\n      return value\n    },\n    set: (value) => {\n      Object.defineProperty(req, prop, { ...optsReset, value })\n    },\n  })\n}\n"],"names":["HeadersAdapter","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","getTracer","NodeSpan","wrapApiHandler","page","handler","args","setRootSpanAttribute","trace","runHandler","spanName","sendStatusCode","res","statusCode","redirect","statusOrUrl","url","Error","writeHead","Location","write","end","checkIsOnDemandRevalidate","req","previewProps","headers","from","previewModeId","get","isOnDemandRevalidate","revalidateOnlyGenerated","has","COOKIE_NAME_PRERENDER_BYPASS","COOKIE_NAME_PRERENDER_DATA","RESPONSE_LIMIT_DEFAULT","SYMBOL_PREVIEW_DATA","Symbol","SYMBOL_CLEARED_COOKIES","clearPreviewData","options","serialize","require","previous","getHeader","setHeader","Array","isArray","expires","Date","httpOnly","sameSite","process","env","NODE_ENV","secure","path","undefined","Object","defineProperty","value","enumerable","ApiError","constructor","message","sendError","statusMessage","setLazyProp","prop","getter","opts","configurable","optsReset","writable","set"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,SAASA,cAAc,QAAQ,yCAAwC;AACvE,SACEC,2BAA2B,EAC3BC,0CAA0C,QACrC,sBAAqB;AAC5B,SAASC,SAAS,QAAQ,sBAAqB;AAC/C,SAASC,QAAQ,QAAQ,yBAAwB;;;;;AAW1C,SAASC,eACdC,IAAY,EACZC,OAAU;IAEV,OAAQ,CAAC,GAAGC;YACVL,2MAAAA,IAAYM,oBAAoB,CAAC,cAAcH;QAC/C,wBAAwB;QACxB,WAAOH,2MAAAA,IAAYO,KAAK,CACtBN,6MAAAA,CAASO,UAAU,EACnB;YACEC,UAAU,CAAC,4BAA4B,EAAEN,MAAM;QACjD,GACA,IAAMC,WAAWC;IAErB;AACF;AAOO,SAASK,eACdC,GAAoB,EACpBC,UAAkB;IAElBD,IAAIC,UAAU,GAAGA;IACjB,OAAOD;AACT;AAQO,SAASE,SACdF,GAAoB,EACpBG,WAA4B,EAC5BC,GAAY;IAEZ,IAAI,OAAOD,gBAAgB,UAAU;QACnCC,MAAMD;QACNA,cAAc;IAChB;IACA,IAAI,OAAOA,gBAAgB,YAAY,OAAOC,QAAQ,UAAU;QAC9D,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,qKAAqK,CAAC,GADnK,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAL,IAAIM,SAAS,CAACH,aAAa;QAAEI,UAAUH;IAAI;IAC3CJ,IAAIQ,KAAK,CAACJ;IACVJ,IAAIS,GAAG;IACP,OAAOT;AACT;AAEO,SAASU,0BACdC,GAAgD,EAChDC,YAA+B;IAK/B,MAAMC,UAAU3B,yOAAAA,CAAe4B,IAAI,CAACH,IAAIE,OAAO;IAE/C,MAAME,gBAAgBF,QAAQG,GAAG,CAAC7B,6MAAAA;IAClC,MAAM8B,uBAAuBF,kBAAkBH,aAAaG,aAAa;IAEzE,MAAMG,0BAA0BL,QAAQM,GAAG,CACzC/B,4NAAAA;IAGF,OAAO;QAAE6B;QAAsBC;IAAwB;AACzD;AAEO,MAAME,+BAA+B,CAAC,kBAAkB,CAAC,CAAA;AACzD,MAAMC,6BAA6B,CAAC,mBAAmB,CAAC,CAAA;AAExD,MAAMC,yBAAyB,IAAI,OAAO,KAAI;AAE9C,MAAMC,sBAAsBC,OAAOH,4BAA2B;AAC9D,MAAMI,yBAAyBD,OAAOJ,8BAA6B;AAEnE,SAASM,iBACd1B,GAAuB,EACvB2B,UAEI,CAAC,CAAC;IAEN,IAAIF,0BAA0BzB,KAAK;QACjC,OAAOA;IACT;IAEA,MAAM,EAAE4B,SAAS,EAAE,GACjBC,QAAQ;IACV,MAAMC,WAAW9B,IAAI+B,SAAS,CAAC;IAC/B/B,IAAIgC,SAAS,CAAC,CAAC,UAAU,CAAC,EAAE;WACtB,OAAOF,aAAa,WACpB;YAACA;SAAS,GACVG,MAAMC,OAAO,CAACJ,YACZA,WACA,EAAE;QACRF,UAAUR,8BAA8B,IAAI;YAC1C,2DAA2D;YAC3D,oDAAoD;YACpD,wEAAwE;YACxEe,SAAS,IAAIC,KAAK;YAClBC,UAAU;YACVC,UAAUC,QAAQC,GAAG,CAACC,QAAQ,KAAK,aAAgB,0BAAS;YAC5DC,QAAQH,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCE,MAAM;YACN,GAAIhB,QAAQgB,IAAI,KAAKC,YAChB;gBAAED,MAAMhB,QAAQgB,IAAI;YAAC,IACtBC,SAAS;QACf;QACAhB,UAAUP,4BAA4B,IAAI;YACxC,2DAA2D;YAC3D,oDAAoD;YACpD,wEAAwE;YACxEc,SAAS,IAAIC,KAAK;YAClBC,UAAU;YACVC,UAAUC,QAAQC,GAAG,CAACC,QAAQ,KAAK,aAAgB,0BAAS;YAC5DC,QAAQH,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCE,MAAM;YACN,GAAIhB,QAAQgB,IAAI,KAAKC,YAChB;gBAAED,MAAMhB,QAAQgB,IAAI;YAAC,IACtBC,SAAS;QACf;KACD;IAEDC,OAAOC,cAAc,CAAC9C,KAAKyB,wBAAwB;QACjDsB,OAAO;QACPC,YAAY;IACd;IACA,OAAOhD;AACT;AAKO,MAAMiD,iBAAiB5C;IAG5B6C,YAAYjD,UAAkB,EAAEkD,OAAe,CAAE;QAC/C,KAAK,CAACA;QACN,IAAI,CAAClD,UAAU,GAAGA;IACpB;AACF;AAQO,SAASmD,UACdpD,GAAoB,EACpBC,UAAkB,EAClBkD,OAAe;IAEfnD,IAAIC,UAAU,GAAGA;IACjBD,IAAIqD,aAAa,GAAGF;IACpBnD,IAAIS,GAAG,CAAC0C;AACV;AAYO,SAASG,YACd,EAAE3C,GAAG,EAAa,EAClB4C,IAAY,EACZC,MAAe;IAEf,MAAMC,OAAO;QAAEC,cAAc;QAAMV,YAAY;IAAK;IACpD,MAAMW,YAAY;QAAE,GAAGF,IAAI;QAAEG,UAAU;IAAK;IAE5Cf,OAAOC,cAAc,CAACnC,KAAK4C,MAAM;QAC/B,GAAGE,IAAI;QACPzC,KAAK;YACH,MAAM+B,QAAQS;YACd,8DAA8D;YAC9DX,OAAOC,cAAc,CAACnC,KAAK4C,MAAM;gBAAE,GAAGI,SAAS;gBAAEZ;YAAM;YACvD,OAAOA;QACT;QACAc,KAAK,CAACd;YACJF,OAAOC,cAAc,CAACnC,KAAK4C,MAAM;gBAAE,GAAGI,SAAS;gBAAEZ;YAAM;QACzD;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 389, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/api-utils/get-cookie-parser.ts"],"sourcesContent":["import type { NextApiRequestCookies } from '.'\n\n/**\n * Parse cookies from the `headers` of request\n * @param req request object\n */\n\nexport function getCookieParser(headers: {\n  [key: string]: string | string[] | null | undefined\n}): () => NextApiRequestCookies {\n  return function parseCookie(): NextApiRequestCookies {\n    const { cookie } = headers\n\n    if (!cookie) {\n      return {}\n    }\n\n    const { parse: parseCookieFn } =\n      require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')\n    return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)\n  }\n}\n"],"names":["getCookieParser","headers","parseCookie","cookie","parse","parseCookieFn","require","Array","isArray","join"],"mappings":"AAEA;;;CAGC,GAED;;;;AAAO,SAASA,gBAAgBC,OAE/B;IACC,OAAO,SAASC;QACd,MAAM,EAAEC,MAAM,EAAE,GAAGF;QAEnB,IAAI,CAACE,QAAQ;YACX,OAAO,CAAC;QACV;QAEA,MAAM,EAAEC,OAAOC,aAAa,EAAE,GAC5BC,QAAQ;QACV,OAAOD,cAAcE,MAAMC,OAAO,CAACL,UAAUA,OAAOM,IAAI,CAAC,QAAQN;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/async-storage/draft-mode-provider.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { BaseNextRequest } from '../base-http'\nimport type { NextRequest } from '../web/spec-extension/request'\n\nimport {\n  COOKIE_NAME_PRERENDER_BYPASS,\n  checkIsOnDemandRevalidate,\n} from '../api-utils'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nexport class DraftModeProvider {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private _isEnabled: boolean\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _previewModeId: string | undefined\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _mutableCookies: ResponseCookies\n\n  constructor(\n    previewProps: __ApiPreviewProps | undefined,\n    req: IncomingMessage | BaseNextRequest<unknown> | NextRequest,\n    cookies: ReadonlyRequestCookies,\n    mutableCookies: ResponseCookies\n  ) {\n    // The logic for draftMode() is very similar to tryGetPreviewData()\n    // but Draft Mode does not have any data associated with it.\n    const isOnDemandRevalidate =\n      previewProps &&\n      checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate\n\n    const cookieValue = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value\n\n    this._isEnabled = Boolean(\n      !isOnDemandRevalidate &&\n        cookieValue &&\n        previewProps &&\n        (cookieValue === previewProps.previewModeId ||\n          // In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.\n          (process.env.NODE_ENV !== 'production' &&\n            previewProps.previewModeId === 'development-id'))\n    )\n\n    this._previewModeId = previewProps?.previewModeId\n    this._mutableCookies = mutableCookies\n  }\n\n  get isEnabled() {\n    return this._isEnabled\n  }\n\n  enable() {\n    if (!this._previewModeId) {\n      throw new Error(\n        'Invariant: previewProps missing previewModeId this should never happen'\n      )\n    }\n\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: this._previewModeId,\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n    })\n\n    this._isEnabled = true\n  }\n\n  disable() {\n    // To delete a cookie, set `expires` to a date in the past:\n    // https://tools.ietf.org/html/rfc6265#section-4.1.1\n    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: '',\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      expires: new Date(0),\n    })\n\n    this._isEnabled = false\n  }\n}\n"],"names":["COOKIE_NAME_PRERENDER_BYPASS","checkIsOnDemandRevalidate","DraftModeProvider","constructor","previewProps","req","cookies","mutableCookies","isOnDemandRevalidate","cookieValue","get","value","_isEnabled","Boolean","previewModeId","process","env","NODE_ENV","_previewModeId","_mutableCookies","isEnabled","enable","Error","set","name","httpOnly","sameSite","secure","path","disable","expires","Date"],"mappings":";;;;AAMA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,eAAc;;AAGd,MAAMC;IAgBXC,YACEC,YAA2C,EAC3CC,GAA6D,EAC7DC,OAA+B,EAC/BC,cAA+B,CAC/B;YAOoBD;QANpB,mEAAmE;QACnE,4DAA4D;QAC5D,MAAME,uBACJJ,oBACAH,0NAAAA,EAA0BI,KAAKD,cAAcI,oBAAoB;QAEnE,MAAMC,cAAAA,CAAcH,eAAAA,QAAQI,GAAG,CAACV,6NAAAA,CAAAA,KAAAA,OAAAA,KAAAA,IAAZM,aAA2CK,KAAK;QAEpE,IAAI,CAACC,UAAU,GAAGC,QAChB,CAACL,wBACCC,eACAL,gBACCK,CAAAA,gBAAgBL,aAAaU,aAAa,IACzC,mHAAmH;QAClHC,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBACxBb,aAAaU,aAAa,KAAK,gBAAgB;QAGvD,IAAI,CAACI,cAAc,GAAGd,gBAAAA,OAAAA,KAAAA,IAAAA,aAAcU,aAAa;QACjD,IAAI,CAACK,eAAe,GAAGZ;IACzB;IAEA,IAAIa,YAAY;QACd,OAAO,IAAI,CAACR,UAAU;IACxB;IAEAS,SAAS;QACP,IAAI,CAAC,IAAI,CAACH,cAAc,EAAE;YACxB,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,2EADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,IAAI,CAACH,eAAe,CAACI,GAAG,CAAC;YACvBC,MAAMxB,6NAAAA;YACNW,OAAO,IAAI,CAACO,cAAc;YAC1BO,UAAU;YACVC,UAAUX,QAAQC,GAAG,CAACC,QAAQ,KAAK,aAAgB,0BAAS;YAC5DU,QAAQZ,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCW,MAAM;QACR;QAEA,IAAI,CAAChB,UAAU,GAAG;IACpB;IAEAiB,UAAU;QACR,2DAA2D;QAC3D,oDAAoD;QACpD,wEAAwE;QACxE,IAAI,CAACV,eAAe,CAACI,GAAG,CAAC;YACvBC,MAAMxB,6NAAAA;YACNW,OAAO;YACPc,UAAU;YACVC,UAAUX,QAAQC,GAAG,CAACC,QAAQ,KAAK,aAAgB,0BAAS;YAC5DU,QAAQZ,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCW,MAAM;YACNE,SAAS,IAAIC,KAAK;QACpB;QAEA,IAAI,CAACnB,UAAU,GAAG;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/async-storage/request-store.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { RenderOpts } from '../app-render/types'\nimport type { NextRequest } from '../web/spec-extension/request'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\nimport {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  MutableRequestCookiesAdapter,\n  RequestCookiesAdapter,\n  responseCookiesToRequestCookies,\n  createCookiesWithMutableAccessCheck,\n  type ReadonlyRequestCookies,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { ResponseCookies, RequestCookies } from '../web/spec-extension/cookies'\nimport { DraftModeProvider } from './draft-mode-provider'\nimport { splitCookiesString } from '../web/utils'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n\nfunction getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n  const cleaned = HeadersAdapter.from(headers)\n  for (const header of FLIGHT_HEADERS) {\n    cleaned.delete(header)\n  }\n\n  return HeadersAdapter.seal(cleaned)\n}\n\nfunction getMutableCookies(\n  headers: Headers | IncomingHttpHeaders,\n  onUpdateCookies?: (cookies: string[]) => void\n): ResponseCookies {\n  const cookies = new RequestCookies(HeadersAdapter.from(headers))\n  return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies)\n}\n\nexport type WrapperRenderOpts = Partial<Pick<RenderOpts, 'onUpdateCookies'>> & {\n  previewProps?: __ApiPreviewProps\n}\n\ntype RequestContext = RequestResponsePair & {\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL. This is only undefined when generating static paths (ie,\n   * there is no request in progress, nor do we know one).\n   */\n  url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    search?: string\n  }\n  phase: RequestStore['phase']\n  renderOpts?: WrapperRenderOpts\n  isHmrRefresh?: boolean\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  implicitTags: ImplicitTags\n}\n\ntype RequestResponsePair =\n  | { req: BaseNextRequest; res: BaseNextResponse } // for an app page\n  | { req: NextRequest; res: undefined } // in an api route or middleware\n\n/**\n * If middleware set cookies in this request (indicated by `x-middleware-set-cookie`),\n * then merge those into the existing cookie object, so that when `cookies()` is accessed\n * it's able to read the newly set cookies.\n */\nfunction mergeMiddlewareCookies(\n  req: RequestContext['req'],\n  existingCookies: RequestCookies | ResponseCookies\n) {\n  if (\n    'x-middleware-set-cookie' in req.headers &&\n    typeof req.headers['x-middleware-set-cookie'] === 'string'\n  ) {\n    const setCookieValue = req.headers['x-middleware-set-cookie']\n    const responseHeaders = new Headers()\n\n    for (const cookie of splitCookiesString(setCookieValue)) {\n      responseHeaders.append('set-cookie', cookie)\n    }\n\n    const responseCookies = new ResponseCookies(responseHeaders)\n\n    // Transfer cookies from ResponseCookies to RequestCookies\n    for (const cookie of responseCookies.getAll()) {\n      existingCookies.set(cookie)\n    }\n  }\n}\n\nexport function createRequestStoreForRender(\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n  renderResumeDataCache: RenderResumeDataCache | null,\n  devFallbackParams: OpaqueFallbackRouteParams | null\n): RequestStore {\n  return createRequestStoreImpl(\n    // Pages start in render phase by default\n    'render',\n    req,\n    res,\n    url,\n    rootParams,\n    implicitTags,\n    onUpdateCookies,\n    renderResumeDataCache,\n    previewProps,\n    isHmrRefresh,\n    serverComponentsHmrCache,\n    devFallbackParams\n  )\n}\n\nexport function createRequestStoreForAPI(\n  req: RequestContext['req'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps']\n): RequestStore {\n  return createRequestStoreImpl(\n    // API routes start in action phase by default\n    'action',\n    req,\n    undefined,\n    url,\n    {},\n    implicitTags,\n    onUpdateCookies,\n    null,\n    previewProps,\n    false,\n    undefined,\n    null\n  )\n}\n\nfunction createRequestStoreImpl(\n  phase: RequestStore['phase'],\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | null,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n  devFallbackParams: OpaqueFallbackRouteParams | null | undefined\n): RequestStore {\n  function defaultOnUpdateCookies(cookies: string[]) {\n    if (res) {\n      res.setHeader('Set-Cookie', cookies)\n    }\n  }\n\n  const cache: {\n    headers?: ReadonlyHeaders\n    cookies?: ReadonlyRequestCookies\n    mutableCookies?: ResponseCookies\n    userspaceMutableCookies?: ResponseCookies\n    draftMode?: DraftModeProvider\n  } = {}\n\n  return {\n    type: 'request',\n    phase,\n    implicitTags,\n    // Rather than just using the whole `url` here, we pull the parts we want\n    // to ensure we don't use parts of the URL that we shouldn't. This also\n    // lets us avoid requiring an empty string for `search` in the type.\n    url: { pathname: url.pathname, search: url.search ?? '' },\n    rootParams,\n    get headers() {\n      if (!cache.headers) {\n        // Seal the headers object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.headers = getHeaders(req.headers)\n      }\n\n      return cache.headers\n    },\n    get cookies() {\n      if (!cache.cookies) {\n        // if middleware is setting cookie(s), then include those in\n        // the initial cached cookies so they can be read in render\n        const requestCookies = new RequestCookies(\n          HeadersAdapter.from(req.headers)\n        )\n\n        mergeMiddlewareCookies(req, requestCookies)\n\n        // Seal the cookies object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.cookies = RequestCookiesAdapter.seal(requestCookies)\n      }\n\n      return cache.cookies\n    },\n    set cookies(value: ReadonlyRequestCookies) {\n      cache.cookies = value\n    },\n    get mutableCookies() {\n      if (!cache.mutableCookies) {\n        const mutableCookies = getMutableCookies(\n          req.headers,\n          onUpdateCookies || (res ? defaultOnUpdateCookies : undefined)\n        )\n\n        mergeMiddlewareCookies(req, mutableCookies)\n\n        cache.mutableCookies = mutableCookies\n      }\n      return cache.mutableCookies\n    },\n    get userspaceMutableCookies() {\n      if (!cache.userspaceMutableCookies) {\n        const userspaceMutableCookies =\n          createCookiesWithMutableAccessCheck(this)\n        cache.userspaceMutableCookies = userspaceMutableCookies\n      }\n      return cache.userspaceMutableCookies\n    },\n    get draftMode() {\n      if (!cache.draftMode) {\n        cache.draftMode = new DraftModeProvider(\n          previewProps,\n          req,\n          this.cookies,\n          this.mutableCookies\n        )\n      }\n\n      return cache.draftMode\n    },\n    renderResumeDataCache: renderResumeDataCache ?? null,\n    isHmrRefresh,\n    serverComponentsHmrCache:\n      serverComponentsHmrCache ||\n      (globalThis as any).__serverComponentsHmrCache,\n    devFallbackParams,\n  }\n}\n\nexport function synchronizeMutableCookies(store: RequestStore) {\n  // TODO: does this need to update headers as well?\n  store.cookies = RequestCookiesAdapter.seal(\n    responseCookiesToRequestCookies(store.mutableCookies)\n  )\n}\n"],"names":["FLIGHT_HEADERS","HeadersAdapter","MutableRequestCookiesAdapter","RequestCookiesAdapter","responseCookiesToRequestCookies","createCookiesWithMutableAccessCheck","ResponseCookies","RequestCookies","DraftModeProvider","splitCookiesString","getHeaders","headers","cleaned","from","header","delete","seal","getMutableCookies","onUpdateCookies","cookies","wrap","mergeMiddlewareCookies","req","existingCookies","setCookieValue","responseHeaders","Headers","cookie","append","responseCookies","getAll","set","createRequestStoreForRender","res","url","rootParams","implicitTags","previewProps","isHmrRefresh","serverComponentsHmrCache","renderResumeDataCache","devFallbackParams","createRequestStoreImpl","createRequestStoreForAPI","undefined","phase","defaultOnUpdateCookies","setHeader","cache","type","pathname","search","requestCookies","value","mutableCookies","userspaceMutableCookies","draftMode","globalThis","__serverComponentsHmrCache","synchronizeMutableCookies","store"],"mappings":";;;;;;;;AAOA,SAASA,cAAc,QAAQ,6CAA4C;AAC3E,SACEC,cAAc,QAET,yCAAwC;AAC/C,SACEC,4BAA4B,EAC5BC,qBAAqB,EACrBC,+BAA+B,EAC/BC,mCAAmC,QAE9B,iDAAgD;;AACvD,SAASC,eAAe,EAAEC,cAAc,QAAQ,gCAA+B;AAC/E,SAASC,iBAAiB,QAAQ,wBAAuB;AACzD,SAASC,kBAAkB,QAAQ,eAAc;;;;;;;AAOjD,SAASC,WAAWC,OAAsC;IACxD,MAAMC,UAAUX,yOAAAA,CAAeY,IAAI,CAACF;IACpC,KAAK,MAAMG,UAAUd,gOAAAA,CAAgB;QACnCY,QAAQG,MAAM,CAACD;IACjB;IAEA,OAAOb,yOAAAA,CAAee,IAAI,CAACJ;AAC7B;AAEA,SAASK,kBACPN,OAAsC,EACtCO,eAA6C;IAE7C,MAAMC,UAAU,IAAIZ,0NAAAA,CAAeN,yOAAAA,CAAeY,IAAI,CAACF;IACvD,OAAOT,kQAAAA,CAA6BkB,IAAI,CAACD,SAASD;AACpD;AAmCA;;;;CAIC,GACD,SAASG,uBACPC,GAA0B,EAC1BC,eAAiD;IAEjD,IACE,6BAA6BD,IAAIX,OAAO,IACxC,OAAOW,IAAIX,OAAO,CAAC,0BAA0B,KAAK,UAClD;QACA,MAAMa,iBAAiBF,IAAIX,OAAO,CAAC,0BAA0B;QAC7D,MAAMc,kBAAkB,IAAIC;QAE5B,KAAK,MAAMC,cAAUlB,0MAAAA,EAAmBe,gBAAiB;YACvDC,gBAAgBG,MAAM,CAAC,cAAcD;QACvC;QAEA,MAAME,kBAAkB,IAAIvB,2NAAAA,CAAgBmB;QAE5C,0DAA0D;QAC1D,KAAK,MAAME,UAAUE,gBAAgBC,MAAM,GAAI;YAC7CP,gBAAgBQ,GAAG,CAACJ;QACtB;IACF;AACF;AAEO,SAASK,4BACdV,GAA0B,EAC1BW,GAA0B,EAC1BC,GAA0B,EAC1BC,UAAkB,EAClBC,YAA4C,EAC5ClB,eAA8C,EAC9CmB,YAA+C,EAC/CC,YAA4C,EAC5CC,wBAAoE,EACpEC,qBAAmD,EACnDC,iBAAmD;IAEnD,OAAOC,uBACL,AACA,UACApB,KACAW,KACAC,KACAC,YACAC,IANyC,UAOzClB,iBACAsB,uBACAH,cACAC,cACAC,0BACAE;AAEJ;AAEO,SAASE,yBACdrB,GAA0B,EAC1BY,GAA0B,EAC1BE,YAA4C,EAC5ClB,eAA8C,EAC9CmB,YAA+C;IAE/C,OAAOK,uBACL,AACA,UACApB,KACAsB,WACAV,KACA,CAAC,GACDE,WAN8C,GAO9ClB,iBACA,MACAmB,cACA,OACAO,WACA;AAEJ;AAEA,SAASF,uBACPG,KAA4B,EAC5BvB,GAA0B,EAC1BW,GAA0B,EAC1BC,GAA0B,EAC1BC,UAAkB,EAClBC,YAA4C,EAC5ClB,eAA8C,EAC9CsB,qBAAmD,EACnDH,YAA+C,EAC/CC,YAA4C,EAC5CC,wBAAoE,EACpEE,iBAA+D;IAE/D,SAASK,uBAAuB3B,OAAiB;QAC/C,IAAIc,KAAK;YACPA,IAAIc,SAAS,CAAC,cAAc5B;QAC9B;IACF;IAEA,MAAM6B,QAMF,CAAC;IAEL,OAAO;QACLC,MAAM;QACNJ;QACAT;QACA,yEAAyE;QACzE,uEAAuE;QACvE,oEAAoE;QACpEF,KAAK;YAAEgB,UAAUhB,IAAIgB,QAAQ;YAAEC,QAAQjB,IAAIiB,MAAM,IAAI;QAAG;QACxDhB;QACA,IAAIxB,WAAU;YACZ,IAAI,CAACqC,MAAMrC,OAAO,EAAE;gBAClB,oEAAoE;gBACpE,8BAA8B;gBAC9BqC,MAAMrC,OAAO,GAAGD,WAAWY,IAAIX,OAAO;YACxC;YAEA,OAAOqC,MAAMrC,OAAO;QACtB;QACA,IAAIQ,WAAU;YACZ,IAAI,CAAC6B,MAAM7B,OAAO,EAAE;gBAClB,4DAA4D;gBAC5D,2DAA2D;gBAC3D,MAAMiC,iBAAiB,IAAI7C,0NAAAA,CACzBN,yOAAAA,CAAeY,IAAI,CAACS,IAAIX,OAAO;gBAGjCU,uBAAuBC,KAAK8B;gBAE5B,oEAAoE;gBACpE,8BAA8B;gBAC9BJ,MAAM7B,OAAO,GAAGhB,2PAAAA,CAAsBa,IAAI,CAACoC;YAC7C;YAEA,OAAOJ,MAAM7B,OAAO;QACtB;QACA,IAAIA,SAAQkC,MAA+B;YACzCL,MAAM7B,OAAO,GAAGkC;QAClB;QACA,IAAIC,kBAAiB;YACnB,IAAI,CAACN,MAAMM,cAAc,EAAE;gBACzB,MAAMA,iBAAiBrC,kBACrBK,IAAIX,OAAO,EACXO,mBAAoBe,CAAAA,MAAMa,yBAAyBF,SAAQ;gBAG7DvB,uBAAuBC,KAAKgC;gBAE5BN,MAAMM,cAAc,GAAGA;YACzB;YACA,OAAON,MAAMM,cAAc;QAC7B;QACA,IAAIC,2BAA0B;YAC5B,IAAI,CAACP,MAAMO,uBAAuB,EAAE;gBAClC,MAAMA,8BACJlD,yQAAAA,EAAoC,IAAI;gBAC1C2C,MAAMO,uBAAuB,GAAGA;YAClC;YACA,OAAOP,MAAMO,uBAAuB;QACtC;QACA,IAAIC,aAAY;YACd,IAAI,CAACR,MAAMQ,SAAS,EAAE;gBACpBR,MAAMQ,SAAS,GAAG,IAAIhD,0OAAAA,CACpB6B,cACAf,KACA,IAAI,CAACH,OAAO,EACZ,IAAI,CAACmC,cAAc;YAEvB;YAEA,OAAON,MAAMQ,SAAS;QACxB;QACAhB,uBAAuBA,yBAAyB;QAChDF;QACAC,0BACEA,4BACCkB,WAAmBC,0BAA0B;QAChDjB;IACF;AACF;AAEO,SAASkB,0BAA0BC,KAAmB;IAC3D,kDAAkD;IAClDA,MAAMzC,OAAO,GAAGhB,2PAAAA,CAAsBa,IAAI,KACxCZ,qQAAAA,EAAgCwD,MAAMN,cAAc;AAExD","ignoreList":[0]}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/async-storage/work-store.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOpts } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { CacheLife } from '../use-cache/cache-life'\n\nimport { AfterContext } from '../after/after-context'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { createLazyResult, type LazyResult } from '../lib/lazy-result'\nimport { getCacheHandlerEntries } from '../use-cache/handlers'\nimport { createSnapshot } from '../app-render/async-local-storage'\n\nexport type WorkStoreContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  isPrefetchRequest?: boolean\n  nonce?: string\n  renderOpts: {\n    cacheLifeProfiles?: { [profile: string]: CacheLife }\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    cacheComponents: boolean\n    fetchCache?: AppSegmentConfig['fetchCache']\n    isPossibleServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOpts['experimental'],\n      'isRoutePPREnabled' | 'authInterrupts'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: WorkStore\n  } & Pick<\n    // Pull some properties from RenderOpts so that the docs are also\n    // mirrored.\n    RenderOpts,\n    | 'assetPrefix'\n    | 'supportsDynamicResponse'\n    | 'shouldWaitOnAllReady'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n    | 'dev'\n    | 'hasReadableErrorStacks'\n  > &\n    RequestLifecycleOpts &\n    Partial<Pick<RenderOpts, 'reactLoadableManifest'>>\n\n  /**\n   * The build ID of the current build.\n   */\n  buildId: string\n\n  // Tags that were previously revalidated (e.g. by a redirecting server action)\n  // and have already been sent to cache handlers.\n  previouslyRevalidatedTags: string[]\n}\n\nexport function createWorkStore({\n  page,\n  renderOpts,\n  isPrefetchRequest,\n  buildId,\n  previouslyRevalidatedTags,\n  nonce,\n}: WorkStoreContext): WorkStore {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.shouldWaitOnAllReady &&\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isPossibleServerAction\n\n  const isDevelopment = renderOpts.dev ?? false\n\n  const shouldTrackFetchMetrics =\n    isDevelopment ||\n    // The only times we want to track fetch metrics outside of development is\n    // when we are performing a static generation and we either are in debug\n    // mode, or tracking fetch metrics was specifically opted into.\n    (isStaticGeneration &&\n      (!!process.env.NEXT_DEBUG_BUILD ||\n        process.env.NEXT_SSG_FETCH_METRICS === '1'))\n\n  const store: WorkStore = {\n    isStaticGeneration,\n    page,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    cacheLifeProfiles: renderOpts.cacheLifeProfiles,\n    isBuildTimePrerendering: renderOpts.nextExport,\n    hasReadableErrorStacks: renderOpts.hasReadableErrorStacks,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    isPrefetchRequest,\n    buildId,\n    reactLoadableManifest: renderOpts?.reactLoadableManifest || {},\n    assetPrefix: renderOpts?.assetPrefix || '',\n    nonce,\n\n    afterContext: createAfterContext(renderOpts),\n    cacheComponentsEnabled: renderOpts.cacheComponents,\n    dev: isDevelopment,\n    previouslyRevalidatedTags,\n    refreshTagsByCacheKind: createRefreshTagsByCacheKind(),\n    runInCleanSnapshot: createSnapshot(),\n    shouldTrackFetchMetrics,\n    reactServerErrorsByDigest: new Map(),\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return store\n}\n\nfunction createAfterContext(renderOpts: RequestLifecycleOpts): AfterContext {\n  const { waitUntil, onClose, onAfterTaskError } = renderOpts\n  return new AfterContext({\n    waitUntil,\n    onClose,\n    onTaskError: onAfterTaskError,\n  })\n}\n\n/**\n * Creates a map with lazy results that refresh tags for the respective cache\n * kind when they're awaited for the first time.\n */\nfunction createRefreshTagsByCacheKind(): Map<string, LazyResult<void>> {\n  const refreshTagsByCacheKind = new Map<string, LazyResult<void>>()\n  const cacheHandlers = getCacheHandlerEntries()\n\n  if (cacheHandlers) {\n    for (const [kind, cacheHandler] of cacheHandlers) {\n      if ('refreshTags' in cacheHandler) {\n        refreshTagsByCacheKind.set(\n          kind,\n          createLazyResult(async () => cacheHandler.refreshTags())\n        )\n      }\n    }\n  }\n\n  return refreshTagsByCacheKind\n}\n"],"names":["AfterContext","normalizeAppPath","createLazyResult","getCacheHandlerEntries","createSnapshot","createWorkStore","page","renderOpts","isPrefetchRequest","buildId","previouslyRevalidatedTags","nonce","isStaticGeneration","shouldWaitOnAllReady","supportsDynamicResponse","isDraftMode","isPossibleServerAction","isDevelopment","dev","shouldTrackFetchMetrics","process","env","NEXT_DEBUG_BUILD","NEXT_SSG_FETCH_METRICS","store","route","incrementalCache","globalThis","__incrementalCache","cacheLifeProfiles","isBuildTimePrerendering","nextExport","hasReadableErrorStacks","fetchCache","isOnDemandRevalidate","reactLoadableManifest","assetPrefix","afterContext","createAfterContext","cacheComponentsEnabled","cacheComponents","refreshTagsByCacheKind","createRefreshTagsByCacheKind","runInCleanSnapshot","reactServerErrorsByDigest","Map","waitUntil","onClose","onAfterTaskError","onTaskError","cacheHandlers","kind","cacheHandler","set","refreshTags"],"mappings":";;;;AAQA,SAASA,YAAY,QAAQ,yBAAwB;AAErD,SAASC,gBAAgB,QAAQ,0CAAyC;AAC1E,SAASC,gBAAgB,QAAyB,qBAAoB;AACtE,SAASC,sBAAsB,QAAQ,wBAAuB;AAC9D,SAASC,cAAc,QAAQ,oCAAmC;;;;;;AA+D3D,SAASC,gBAAgB,EAC9BC,IAAI,EACJC,UAAU,EACVC,iBAAiB,EACjBC,OAAO,EACPC,yBAAyB,EACzBC,KAAK,EACY;IACjB;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACL,WAAWM,oBAAoB,IAChC,CAACN,WAAWO,uBAAuB,IACnC,CAACP,WAAWQ,WAAW,IACvB,CAACR,WAAWS,sBAAsB;IAEpC,MAAMC,gBAAgBV,WAAWW,GAAG,IAAI;IAExC,MAAMC,0BACJF,iBACA,0EAA0E;IAC1E,wEAAwE;IACxE,+DAA+D;IAC9DL,sBACE,CAAA,CAAC,CAACQ,QAAQC,GAAG,CAACC,gBAAgB,IAC7BF,QAAQC,GAAG,CAACE,sBAAsB,KAAK,GAAE;IAE/C,MAAMC,QAAmB;QACvBZ;QACAN;QACAmB,WAAOxB,kOAAAA,EAAiBK;QACxBoB,kBACE,AACA,mDAAmD,kBADkB;QAErEnB,WAAWmB,gBAAgB,IAAKC,WAAmBC,kBAAkB;QACvEC,mBAAmBtB,WAAWsB,iBAAiB;QAC/CC,yBAAyBvB,WAAWwB,UAAU;QAC9CC,wBAAwBzB,WAAWyB,sBAAsB;QACzDC,YAAY1B,WAAW0B,UAAU;QACjCC,sBAAsB3B,WAAW2B,oBAAoB;QAErDnB,aAAaR,WAAWQ,WAAW;QAEnCP;QACAC;QACA0B,uBAAuB5B,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAY4B,qBAAqB,KAAI,CAAC;QAC7DC,aAAa7B,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAY6B,WAAW,KAAI;QACxCzB;QAEA0B,cAAcC,mBAAmB/B;QACjCgC,wBAAwBhC,WAAWiC,eAAe;QAClDtB,KAAKD;QACLP;QACA+B,wBAAwBC;QACxBC,wBAAoBvC,oOAAAA;QACpBe;QACAyB,2BAA2B,IAAIC;IACjC;IAEA,sFAAsF;IACtFtC,WAAWiB,KAAK,GAAGA;IAEnB,OAAOA;AACT;AAEA,SAASc,mBAAmB/B,UAAgC;IAC1D,MAAM,EAAEuC,SAAS,EAAEC,OAAO,EAAEC,gBAAgB,EAAE,GAAGzC;IACjD,OAAO,IAAIP,iNAAAA,CAAa;QACtB8C;QACAC;QACAE,aAAaD;IACf;AACF;AAEA;;;CAGC,GACD,SAASN;IACP,MAAMD,yBAAyB,IAAII;IACnC,MAAMK,oBAAgB/C,0NAAAA;IAEtB,IAAI+C,eAAe;QACjB,KAAK,MAAM,CAACC,MAAMC,aAAa,IAAIF,cAAe;YAChD,IAAI,iBAAiBE,cAAc;gBACjCX,uBAAuBY,GAAG,CACxBF,UACAjD,iNAAAA,EAAiB,UAAYkD,aAAaE,WAAW;YAEzD;QACF;IACF;IAEA,OAAOb;AACT","ignoreList":[0]}},
    {"offset": {"line": 696, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/async-storage/draft-mode-provider.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { BaseNextRequest } from '../base-http'\nimport type { NextRequest } from '../web/spec-extension/request'\n\nimport {\n  COOKIE_NAME_PRERENDER_BYPASS,\n  checkIsOnDemandRevalidate,\n} from '../api-utils'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nexport class DraftModeProvider {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private _isEnabled: boolean\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _previewModeId: string | undefined\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _mutableCookies: ResponseCookies\n\n  constructor(\n    previewProps: __ApiPreviewProps | undefined,\n    req: IncomingMessage | BaseNextRequest<unknown> | NextRequest,\n    cookies: ReadonlyRequestCookies,\n    mutableCookies: ResponseCookies\n  ) {\n    // The logic for draftMode() is very similar to tryGetPreviewData()\n    // but Draft Mode does not have any data associated with it.\n    const isOnDemandRevalidate =\n      previewProps &&\n      checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate\n\n    const cookieValue = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value\n\n    this._isEnabled = Boolean(\n      !isOnDemandRevalidate &&\n        cookieValue &&\n        previewProps &&\n        (cookieValue === previewProps.previewModeId ||\n          // In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.\n          (process.env.NODE_ENV !== 'production' &&\n            previewProps.previewModeId === 'development-id'))\n    )\n\n    this._previewModeId = previewProps?.previewModeId\n    this._mutableCookies = mutableCookies\n  }\n\n  get isEnabled() {\n    return this._isEnabled\n  }\n\n  enable() {\n    if (!this._previewModeId) {\n      throw new Error(\n        'Invariant: previewProps missing previewModeId this should never happen'\n      )\n    }\n\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: this._previewModeId,\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n    })\n\n    this._isEnabled = true\n  }\n\n  disable() {\n    // To delete a cookie, set `expires` to a date in the past:\n    // https://tools.ietf.org/html/rfc6265#section-4.1.1\n    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: '',\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      expires: new Date(0),\n    })\n\n    this._isEnabled = false\n  }\n}\n"],"names":["COOKIE_NAME_PRERENDER_BYPASS","checkIsOnDemandRevalidate","DraftModeProvider","constructor","previewProps","req","cookies","mutableCookies","isOnDemandRevalidate","cookieValue","get","value","_isEnabled","Boolean","previewModeId","process","env","NODE_ENV","_previewModeId","_mutableCookies","isEnabled","enable","Error","set","name","httpOnly","sameSite","secure","path","disable","expires","Date"],"mappings":";;;;AAMA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,eAAc;;AAGd,MAAMC;IAgBXC,YACEC,YAA2C,EAC3CC,GAA6D,EAC7DC,OAA+B,EAC/BC,cAA+B,CAC/B;YAOoBD;QANpB,mEAAmE;QACnE,4DAA4D;QAC5D,MAAME,uBACJJ,oBACAH,0NAAAA,EAA0BI,KAAKD,cAAcI,oBAAoB;QAEnE,MAAMC,cAAAA,CAAcH,eAAAA,QAAQI,GAAG,CAACV,6NAAAA,CAAAA,KAAAA,OAAAA,KAAAA,IAAZM,aAA2CK,KAAK;QAEpE,IAAI,CAACC,UAAU,GAAGC,QAChB,CAACL,wBACCC,eACAL,gBACCK,CAAAA,gBAAgBL,aAAaU,aAAa,IACzC,mHAAmH;QAClHC,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBACxBb,aAAaU,aAAa,KAAK,gBAAgB;QAGvD,IAAI,CAACI,cAAc,GAAGd,gBAAAA,OAAAA,KAAAA,IAAAA,aAAcU,aAAa;QACjD,IAAI,CAACK,eAAe,GAAGZ;IACzB;IAEA,IAAIa,YAAY;QACd,OAAO,IAAI,CAACR,UAAU;IACxB;IAEAS,SAAS;QACP,IAAI,CAAC,IAAI,CAACH,cAAc,EAAE;YACxB,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,2EADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,IAAI,CAACH,eAAe,CAACI,GAAG,CAAC;YACvBC,MAAMxB,6NAAAA;YACNW,OAAO,IAAI,CAACO,cAAc;YAC1BO,UAAU;YACVC,UAAUX,QAAQC,GAAG,CAACC,QAAQ,KAAK,aAAgB,0BAAS;YAC5DU,QAAQZ,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCW,MAAM;QACR;QAEA,IAAI,CAAChB,UAAU,GAAG;IACpB;IAEAiB,UAAU;QACR,2DAA2D;QAC3D,oDAAoD;QACpD,wEAAwE;QACxE,IAAI,CAACV,eAAe,CAACI,GAAG,CAAC;YACvBC,MAAMxB,6NAAAA;YACNW,OAAO;YACPc,UAAU;YACVC,UAAUX,QAAQC,GAAG,CAACC,QAAQ,KAAK,aAAgB,0BAAS;YAC5DU,QAAQZ,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCW,MAAM;YACNE,SAAS,IAAIC,KAAK;QACpB;QAEA,IAAI,CAACnB,UAAU,GAAG;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 755, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/async-storage/request-store.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { RenderOpts } from '../app-render/types'\nimport type { NextRequest } from '../web/spec-extension/request'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\nimport {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  MutableRequestCookiesAdapter,\n  RequestCookiesAdapter,\n  responseCookiesToRequestCookies,\n  createCookiesWithMutableAccessCheck,\n  type ReadonlyRequestCookies,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { ResponseCookies, RequestCookies } from '../web/spec-extension/cookies'\nimport { DraftModeProvider } from './draft-mode-provider'\nimport { splitCookiesString } from '../web/utils'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n\nfunction getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n  const cleaned = HeadersAdapter.from(headers)\n  for (const header of FLIGHT_HEADERS) {\n    cleaned.delete(header)\n  }\n\n  return HeadersAdapter.seal(cleaned)\n}\n\nfunction getMutableCookies(\n  headers: Headers | IncomingHttpHeaders,\n  onUpdateCookies?: (cookies: string[]) => void\n): ResponseCookies {\n  const cookies = new RequestCookies(HeadersAdapter.from(headers))\n  return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies)\n}\n\nexport type WrapperRenderOpts = Partial<Pick<RenderOpts, 'onUpdateCookies'>> & {\n  previewProps?: __ApiPreviewProps\n}\n\ntype RequestContext = RequestResponsePair & {\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL. This is only undefined when generating static paths (ie,\n   * there is no request in progress, nor do we know one).\n   */\n  url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    search?: string\n  }\n  phase: RequestStore['phase']\n  renderOpts?: WrapperRenderOpts\n  isHmrRefresh?: boolean\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  implicitTags: ImplicitTags\n}\n\ntype RequestResponsePair =\n  | { req: BaseNextRequest; res: BaseNextResponse } // for an app page\n  | { req: NextRequest; res: undefined } // in an api route or middleware\n\n/**\n * If middleware set cookies in this request (indicated by `x-middleware-set-cookie`),\n * then merge those into the existing cookie object, so that when `cookies()` is accessed\n * it's able to read the newly set cookies.\n */\nfunction mergeMiddlewareCookies(\n  req: RequestContext['req'],\n  existingCookies: RequestCookies | ResponseCookies\n) {\n  if (\n    'x-middleware-set-cookie' in req.headers &&\n    typeof req.headers['x-middleware-set-cookie'] === 'string'\n  ) {\n    const setCookieValue = req.headers['x-middleware-set-cookie']\n    const responseHeaders = new Headers()\n\n    for (const cookie of splitCookiesString(setCookieValue)) {\n      responseHeaders.append('set-cookie', cookie)\n    }\n\n    const responseCookies = new ResponseCookies(responseHeaders)\n\n    // Transfer cookies from ResponseCookies to RequestCookies\n    for (const cookie of responseCookies.getAll()) {\n      existingCookies.set(cookie)\n    }\n  }\n}\n\nexport function createRequestStoreForRender(\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n  renderResumeDataCache: RenderResumeDataCache | null,\n  devFallbackParams: OpaqueFallbackRouteParams | null\n): RequestStore {\n  return createRequestStoreImpl(\n    // Pages start in render phase by default\n    'render',\n    req,\n    res,\n    url,\n    rootParams,\n    implicitTags,\n    onUpdateCookies,\n    renderResumeDataCache,\n    previewProps,\n    isHmrRefresh,\n    serverComponentsHmrCache,\n    devFallbackParams\n  )\n}\n\nexport function createRequestStoreForAPI(\n  req: RequestContext['req'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps']\n): RequestStore {\n  return createRequestStoreImpl(\n    // API routes start in action phase by default\n    'action',\n    req,\n    undefined,\n    url,\n    {},\n    implicitTags,\n    onUpdateCookies,\n    null,\n    previewProps,\n    false,\n    undefined,\n    null\n  )\n}\n\nfunction createRequestStoreImpl(\n  phase: RequestStore['phase'],\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | null,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n  devFallbackParams: OpaqueFallbackRouteParams | null | undefined\n): RequestStore {\n  function defaultOnUpdateCookies(cookies: string[]) {\n    if (res) {\n      res.setHeader('Set-Cookie', cookies)\n    }\n  }\n\n  const cache: {\n    headers?: ReadonlyHeaders\n    cookies?: ReadonlyRequestCookies\n    mutableCookies?: ResponseCookies\n    userspaceMutableCookies?: ResponseCookies\n    draftMode?: DraftModeProvider\n  } = {}\n\n  return {\n    type: 'request',\n    phase,\n    implicitTags,\n    // Rather than just using the whole `url` here, we pull the parts we want\n    // to ensure we don't use parts of the URL that we shouldn't. This also\n    // lets us avoid requiring an empty string for `search` in the type.\n    url: { pathname: url.pathname, search: url.search ?? '' },\n    rootParams,\n    get headers() {\n      if (!cache.headers) {\n        // Seal the headers object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.headers = getHeaders(req.headers)\n      }\n\n      return cache.headers\n    },\n    get cookies() {\n      if (!cache.cookies) {\n        // if middleware is setting cookie(s), then include those in\n        // the initial cached cookies so they can be read in render\n        const requestCookies = new RequestCookies(\n          HeadersAdapter.from(req.headers)\n        )\n\n        mergeMiddlewareCookies(req, requestCookies)\n\n        // Seal the cookies object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.cookies = RequestCookiesAdapter.seal(requestCookies)\n      }\n\n      return cache.cookies\n    },\n    set cookies(value: ReadonlyRequestCookies) {\n      cache.cookies = value\n    },\n    get mutableCookies() {\n      if (!cache.mutableCookies) {\n        const mutableCookies = getMutableCookies(\n          req.headers,\n          onUpdateCookies || (res ? defaultOnUpdateCookies : undefined)\n        )\n\n        mergeMiddlewareCookies(req, mutableCookies)\n\n        cache.mutableCookies = mutableCookies\n      }\n      return cache.mutableCookies\n    },\n    get userspaceMutableCookies() {\n      if (!cache.userspaceMutableCookies) {\n        const userspaceMutableCookies =\n          createCookiesWithMutableAccessCheck(this)\n        cache.userspaceMutableCookies = userspaceMutableCookies\n      }\n      return cache.userspaceMutableCookies\n    },\n    get draftMode() {\n      if (!cache.draftMode) {\n        cache.draftMode = new DraftModeProvider(\n          previewProps,\n          req,\n          this.cookies,\n          this.mutableCookies\n        )\n      }\n\n      return cache.draftMode\n    },\n    renderResumeDataCache: renderResumeDataCache ?? null,\n    isHmrRefresh,\n    serverComponentsHmrCache:\n      serverComponentsHmrCache ||\n      (globalThis as any).__serverComponentsHmrCache,\n    devFallbackParams,\n  }\n}\n\nexport function synchronizeMutableCookies(store: RequestStore) {\n  // TODO: does this need to update headers as well?\n  store.cookies = RequestCookiesAdapter.seal(\n    responseCookiesToRequestCookies(store.mutableCookies)\n  )\n}\n"],"names":["FLIGHT_HEADERS","HeadersAdapter","MutableRequestCookiesAdapter","RequestCookiesAdapter","responseCookiesToRequestCookies","createCookiesWithMutableAccessCheck","ResponseCookies","RequestCookies","DraftModeProvider","splitCookiesString","getHeaders","headers","cleaned","from","header","delete","seal","getMutableCookies","onUpdateCookies","cookies","wrap","mergeMiddlewareCookies","req","existingCookies","setCookieValue","responseHeaders","Headers","cookie","append","responseCookies","getAll","set","createRequestStoreForRender","res","url","rootParams","implicitTags","previewProps","isHmrRefresh","serverComponentsHmrCache","renderResumeDataCache","devFallbackParams","createRequestStoreImpl","createRequestStoreForAPI","undefined","phase","defaultOnUpdateCookies","setHeader","cache","type","pathname","search","requestCookies","value","mutableCookies","userspaceMutableCookies","draftMode","globalThis","__serverComponentsHmrCache","synchronizeMutableCookies","store"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 888, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/async-storage/work-store.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOpts } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { CacheLife } from '../use-cache/cache-life'\n\nimport { AfterContext } from '../after/after-context'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { createLazyResult, type LazyResult } from '../lib/lazy-result'\nimport { getCacheHandlerEntries } from '../use-cache/handlers'\nimport { createSnapshot } from '../app-render/async-local-storage'\n\nexport type WorkStoreContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  isPrefetchRequest?: boolean\n  nonce?: string\n  renderOpts: {\n    cacheLifeProfiles?: { [profile: string]: CacheLife }\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    cacheComponents: boolean\n    fetchCache?: AppSegmentConfig['fetchCache']\n    isPossibleServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOpts['experimental'],\n      'isRoutePPREnabled' | 'authInterrupts'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: WorkStore\n  } & Pick<\n    // Pull some properties from RenderOpts so that the docs are also\n    // mirrored.\n    RenderOpts,\n    | 'assetPrefix'\n    | 'supportsDynamicResponse'\n    | 'shouldWaitOnAllReady'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n    | 'dev'\n    | 'hasReadableErrorStacks'\n  > &\n    RequestLifecycleOpts &\n    Partial<Pick<RenderOpts, 'reactLoadableManifest'>>\n\n  /**\n   * The build ID of the current build.\n   */\n  buildId: string\n\n  // Tags that were previously revalidated (e.g. by a redirecting server action)\n  // and have already been sent to cache handlers.\n  previouslyRevalidatedTags: string[]\n}\n\nexport function createWorkStore({\n  page,\n  renderOpts,\n  isPrefetchRequest,\n  buildId,\n  previouslyRevalidatedTags,\n  nonce,\n}: WorkStoreContext): WorkStore {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.shouldWaitOnAllReady &&\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isPossibleServerAction\n\n  const isDevelopment = renderOpts.dev ?? false\n\n  const shouldTrackFetchMetrics =\n    isDevelopment ||\n    // The only times we want to track fetch metrics outside of development is\n    // when we are performing a static generation and we either are in debug\n    // mode, or tracking fetch metrics was specifically opted into.\n    (isStaticGeneration &&\n      (!!process.env.NEXT_DEBUG_BUILD ||\n        process.env.NEXT_SSG_FETCH_METRICS === '1'))\n\n  const store: WorkStore = {\n    isStaticGeneration,\n    page,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    cacheLifeProfiles: renderOpts.cacheLifeProfiles,\n    isBuildTimePrerendering: renderOpts.nextExport,\n    hasReadableErrorStacks: renderOpts.hasReadableErrorStacks,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    isPrefetchRequest,\n    buildId,\n    reactLoadableManifest: renderOpts?.reactLoadableManifest || {},\n    assetPrefix: renderOpts?.assetPrefix || '',\n    nonce,\n\n    afterContext: createAfterContext(renderOpts),\n    cacheComponentsEnabled: renderOpts.cacheComponents,\n    dev: isDevelopment,\n    previouslyRevalidatedTags,\n    refreshTagsByCacheKind: createRefreshTagsByCacheKind(),\n    runInCleanSnapshot: createSnapshot(),\n    shouldTrackFetchMetrics,\n    reactServerErrorsByDigest: new Map(),\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return store\n}\n\nfunction createAfterContext(renderOpts: RequestLifecycleOpts): AfterContext {\n  const { waitUntil, onClose, onAfterTaskError } = renderOpts\n  return new AfterContext({\n    waitUntil,\n    onClose,\n    onTaskError: onAfterTaskError,\n  })\n}\n\n/**\n * Creates a map with lazy results that refresh tags for the respective cache\n * kind when they're awaited for the first time.\n */\nfunction createRefreshTagsByCacheKind(): Map<string, LazyResult<void>> {\n  const refreshTagsByCacheKind = new Map<string, LazyResult<void>>()\n  const cacheHandlers = getCacheHandlerEntries()\n\n  if (cacheHandlers) {\n    for (const [kind, cacheHandler] of cacheHandlers) {\n      if ('refreshTags' in cacheHandler) {\n        refreshTagsByCacheKind.set(\n          kind,\n          createLazyResult(async () => cacheHandler.refreshTags())\n        )\n      }\n    }\n  }\n\n  return refreshTagsByCacheKind\n}\n"],"names":["AfterContext","normalizeAppPath","createLazyResult","getCacheHandlerEntries","createSnapshot","createWorkStore","page","renderOpts","isPrefetchRequest","buildId","previouslyRevalidatedTags","nonce","isStaticGeneration","shouldWaitOnAllReady","supportsDynamicResponse","isDraftMode","isPossibleServerAction","isDevelopment","dev","shouldTrackFetchMetrics","process","env","NEXT_DEBUG_BUILD","NEXT_SSG_FETCH_METRICS","store","route","incrementalCache","globalThis","__incrementalCache","cacheLifeProfiles","isBuildTimePrerendering","nextExport","hasReadableErrorStacks","fetchCache","isOnDemandRevalidate","reactLoadableManifest","assetPrefix","afterContext","createAfterContext","cacheComponentsEnabled","cacheComponents","refreshTagsByCacheKind","createRefreshTagsByCacheKind","runInCleanSnapshot","reactServerErrorsByDigest","Map","waitUntil","onClose","onAfterTaskError","onTaskError","cacheHandlers","kind","cacheHandler","set","refreshTags"],"mappings":";;;;AAQA,SAASA,YAAY,QAAQ,yBAAwB;AAErD,SAASC,gBAAgB,QAAQ,0CAAyC;AAC1E,SAASC,gBAAgB,QAAyB,qBAAoB;AACtE,SAASC,sBAAsB,QAAQ,wBAAuB;AAC9D,SAASC,cAAc,QAAQ,oCAAmC;;;;;;AA+D3D,SAASC,gBAAgB,EAC9BC,IAAI,EACJC,UAAU,EACVC,iBAAiB,EACjBC,OAAO,EACPC,yBAAyB,EACzBC,KAAK,EACY;IACjB;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACL,WAAWM,oBAAoB,IAChC,CAACN,WAAWO,uBAAuB,IACnC,CAACP,WAAWQ,WAAW,IACvB,CAACR,WAAWS,sBAAsB;IAEpC,MAAMC,gBAAgBV,WAAWW,GAAG,IAAI;IAExC,MAAMC,0BACJF,iBACA,0EAA0E;IAC1E,wEAAwE;IACxE,+DAA+D;IAC9DL,sBACE,CAAA,CAAC,CAACQ,QAAQC,GAAG,CAACC,gBAAgB,IAC7BF,QAAQC,GAAG,CAACE,sBAAsB,KAAK,GAAE;IAE/C,MAAMC,QAAmB;QACvBZ;QACAN;QACAmB,WAAOxB,kOAAAA,EAAiBK;QACxBoB,kBACE,AACA,mDAAmD,kBADkB;QAErEnB,WAAWmB,gBAAgB,IAAKC,WAAmBC,kBAAkB;QACvEC,mBAAmBtB,WAAWsB,iBAAiB;QAC/CC,yBAAyBvB,WAAWwB,UAAU;QAC9CC,wBAAwBzB,WAAWyB,sBAAsB;QACzDC,YAAY1B,WAAW0B,UAAU;QACjCC,sBAAsB3B,WAAW2B,oBAAoB;QAErDnB,aAAaR,WAAWQ,WAAW;QAEnCP;QACAC;QACA0B,uBAAuB5B,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAY4B,qBAAqB,KAAI,CAAC;QAC7DC,aAAa7B,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAY6B,WAAW,KAAI;QACxCzB;QAEA0B,cAAcC,mBAAmB/B;QACjCgC,wBAAwBhC,WAAWiC,eAAe;QAClDtB,KAAKD;QACLP;QACA+B,wBAAwBC;QACxBC,wBAAoBvC,oOAAAA;QACpBe;QACAyB,2BAA2B,IAAIC;IACjC;IAEA,sFAAsF;IACtFtC,WAAWiB,KAAK,GAAGA;IAEnB,OAAOA;AACT;AAEA,SAASc,mBAAmB/B,UAAgC;IAC1D,MAAM,EAAEuC,SAAS,EAAEC,OAAO,EAAEC,gBAAgB,EAAE,GAAGzC;IACjD,OAAO,IAAIP,iNAAAA,CAAa;QACtB8C;QACAC;QACAE,aAAaD;IACf;AACF;AAEA;;;CAGC,GACD,SAASN;IACP,MAAMD,yBAAyB,IAAII;IACnC,MAAMK,oBAAgB/C,0NAAAA;IAEtB,IAAI+C,eAAe;QACjB,KAAK,MAAM,CAACC,MAAMC,aAAa,IAAIF,cAAe;YAChD,IAAI,iBAAiBE,cAAc;gBACjCX,uBAAuBY,GAAG,CACxBF,UACAjD,iNAAAA,EAAiB,UAAYkD,aAAaE,WAAW;YAEzD;QACF;IACF;IAEA,OAAOb;AACT","ignoreList":[0]}},
    {"offset": {"line": 982, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/use-cache/handlers.ts"],"sourcesContent":["import { createDefaultCacheHandler } from '../lib/cache-handlers/default'\nimport type { CacheHandler } from '../lib/cache-handlers/types'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? (message: string, ...args: any[]) => {\n      console.log(`use-cache: ${message}`, ...args)\n    }\n  : undefined\n\nconst handlersSymbol = Symbol.for('@next/cache-handlers')\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */\nconst reference: typeof globalThis & {\n  [handlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  [handlersMapSymbol]?: Map<string, CacheHandler>\n  [handlersSetSymbol]?: Set<CacheHandler>\n} = globalThis\n\n/**\n * Initialize the cache handlers.\n * @param cacheMaxMemorySize - The maximum memory size of the cache in bytes, if\n *  not provided, the default memory size will be used.\n * @returns `true` if the cache handlers were initialized, `false` if they were already initialized.\n */\nexport function initializeCacheHandlers(cacheMaxMemorySize: number): boolean {\n  // If the cache handlers have already been initialized, don't do it again.\n  if (reference[handlersMapSymbol]) {\n    debug?.('cache handlers already initialized')\n    return false\n  }\n\n  debug?.('initializing cache handlers')\n  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n\n  // Initialize the cache from the symbol contents first.\n  if (reference[handlersSymbol]) {\n    let fallback: CacheHandler\n    if (reference[handlersSymbol].DefaultCache) {\n      debug?.('setting \"default\" cache handler from symbol')\n      fallback = reference[handlersSymbol].DefaultCache\n    } else {\n      debug?.('setting \"default\" cache handler from default')\n      fallback = createDefaultCacheHandler(cacheMaxMemorySize)\n    }\n\n    reference[handlersMapSymbol].set('default', fallback)\n\n    if (reference[handlersSymbol].RemoteCache) {\n      debug?.('setting \"remote\" cache handler from symbol')\n      reference[handlersMapSymbol].set(\n        'remote',\n        reference[handlersSymbol].RemoteCache\n      )\n    } else {\n      debug?.('setting \"remote\" cache handler from default')\n      reference[handlersMapSymbol].set('remote', fallback)\n    }\n  } else {\n    const handler = createDefaultCacheHandler(cacheMaxMemorySize)\n\n    debug?.('setting \"default\" cache handler from default')\n    reference[handlersMapSymbol].set('default', handler)\n    debug?.('setting \"remote\" cache handler from default')\n    reference[handlersMapSymbol].set('remote', handler)\n  }\n\n  // Create a set of the cache handlers.\n  reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())\n\n  return true\n}\n\n/**\n * Get a cache handler by kind.\n * @param kind - The kind of cache handler to get.\n * @returns The cache handler, or `undefined` if it does not exist.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandler(kind: string): CacheHandler | undefined {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  return reference[handlersMapSymbol].get(kind)\n}\n\n/**\n * Get a set iterator over the cache handlers.\n * @returns An iterator over the cache handlers, or `undefined` if they are not\n * initialized.\n */\nexport function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  if (!reference[handlersSetSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersSetSymbol].values()\n}\n\n/**\n * Get a map iterator over the cache handlers (keyed by kind).\n * @returns An iterator over the cache handler entries, or `undefined` if they\n * are not initialized.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandlerEntries():\n  | MapIterator<[string, CacheHandler]>\n  | undefined {\n  if (!reference[handlersMapSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersMapSymbol].entries()\n}\n\n/**\n * Set a cache handler by kind.\n * @param kind - The kind of cache handler to set.\n * @param cacheHandler - The cache handler to set.\n */\nexport function setCacheHandler(\n  kind: string,\n  cacheHandler: CacheHandler\n): void {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  debug?.('setting cache handler for \"%s\"', kind)\n  reference[handlersMapSymbol].set(kind, cacheHandler)\n  reference[handlersSetSymbol].add(cacheHandler)\n}\n"],"names":["createDefaultCacheHandler","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","message","args","console","log","undefined","handlersSymbol","Symbol","for","handlersMapSymbol","handlersSetSymbol","reference","globalThis","initializeCacheHandlers","cacheMaxMemorySize","Map","fallback","DefaultCache","set","RemoteCache","handler","Set","values","getCacheHandler","kind","Error","get","getCacheHandlers","getCacheHandlerEntries","entries","setCacheHandler","cacheHandler","add"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1084, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/use-cache/handlers.ts"],"sourcesContent":["import { createDefaultCacheHandler } from '../lib/cache-handlers/default'\nimport type { CacheHandler } from '../lib/cache-handlers/types'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? (message: string, ...args: any[]) => {\n      console.log(`use-cache: ${message}`, ...args)\n    }\n  : undefined\n\nconst handlersSymbol = Symbol.for('@next/cache-handlers')\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */\nconst reference: typeof globalThis & {\n  [handlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  [handlersMapSymbol]?: Map<string, CacheHandler>\n  [handlersSetSymbol]?: Set<CacheHandler>\n} = globalThis\n\n/**\n * Initialize the cache handlers.\n * @param cacheMaxMemorySize - The maximum memory size of the cache in bytes, if\n *  not provided, the default memory size will be used.\n * @returns `true` if the cache handlers were initialized, `false` if they were already initialized.\n */\nexport function initializeCacheHandlers(cacheMaxMemorySize: number): boolean {\n  // If the cache handlers have already been initialized, don't do it again.\n  if (reference[handlersMapSymbol]) {\n    debug?.('cache handlers already initialized')\n    return false\n  }\n\n  debug?.('initializing cache handlers')\n  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n\n  // Initialize the cache from the symbol contents first.\n  if (reference[handlersSymbol]) {\n    let fallback: CacheHandler\n    if (reference[handlersSymbol].DefaultCache) {\n      debug?.('setting \"default\" cache handler from symbol')\n      fallback = reference[handlersSymbol].DefaultCache\n    } else {\n      debug?.('setting \"default\" cache handler from default')\n      fallback = createDefaultCacheHandler(cacheMaxMemorySize)\n    }\n\n    reference[handlersMapSymbol].set('default', fallback)\n\n    if (reference[handlersSymbol].RemoteCache) {\n      debug?.('setting \"remote\" cache handler from symbol')\n      reference[handlersMapSymbol].set(\n        'remote',\n        reference[handlersSymbol].RemoteCache\n      )\n    } else {\n      debug?.('setting \"remote\" cache handler from default')\n      reference[handlersMapSymbol].set('remote', fallback)\n    }\n  } else {\n    const handler = createDefaultCacheHandler(cacheMaxMemorySize)\n\n    debug?.('setting \"default\" cache handler from default')\n    reference[handlersMapSymbol].set('default', handler)\n    debug?.('setting \"remote\" cache handler from default')\n    reference[handlersMapSymbol].set('remote', handler)\n  }\n\n  // Create a set of the cache handlers.\n  reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())\n\n  return true\n}\n\n/**\n * Get a cache handler by kind.\n * @param kind - The kind of cache handler to get.\n * @returns The cache handler, or `undefined` if it does not exist.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandler(kind: string): CacheHandler | undefined {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  return reference[handlersMapSymbol].get(kind)\n}\n\n/**\n * Get a set iterator over the cache handlers.\n * @returns An iterator over the cache handlers, or `undefined` if they are not\n * initialized.\n */\nexport function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  if (!reference[handlersSetSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersSetSymbol].values()\n}\n\n/**\n * Get a map iterator over the cache handlers (keyed by kind).\n * @returns An iterator over the cache handler entries, or `undefined` if they\n * are not initialized.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandlerEntries():\n  | MapIterator<[string, CacheHandler]>\n  | undefined {\n  if (!reference[handlersMapSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersMapSymbol].entries()\n}\n\n/**\n * Set a cache handler by kind.\n * @param kind - The kind of cache handler to set.\n * @param cacheHandler - The cache handler to set.\n */\nexport function setCacheHandler(\n  kind: string,\n  cacheHandler: CacheHandler\n): void {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  debug?.('setting cache handler for \"%s\"', kind)\n  reference[handlersMapSymbol].set(kind, cacheHandler)\n  reference[handlersSetSymbol].add(cacheHandler)\n}\n"],"names":["createDefaultCacheHandler","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","message","args","console","log","undefined","handlersSymbol","Symbol","for","handlersMapSymbol","handlersSetSymbol","reference","globalThis","initializeCacheHandlers","cacheMaxMemorySize","Map","fallback","DefaultCache","set","RemoteCache","handler","Set","values","getCacheHandler","kind","Error","get","getCacheHandlers","getCacheHandlerEntries","entries","setCacheHandler","cacheHandler","add"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1186, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/use-cache/constants.ts"],"sourcesContent":["export const DYNAMIC_EXPIRE = 300 // 5 minutes\nexport const RUNTIME_PREFETCH_DYNAMIC_STALE = 30 // 30 seconds\n"],"names":["DYNAMIC_EXPIRE","RUNTIME_PREFETCH_DYNAMIC_STALE"],"mappings":";;;;;;AAAO,MAAMA,iBAAiB,IAAI,YAAY;;AACvC,MAAMC,iCAAiC,GAAG,aAAa","ignoreList":[0]}},
    {"offset": {"line": 1200, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/revalidation-utils.ts"],"sourcesContent":["import type { WorkStore } from './app-render/work-async-storage.external'\nimport type { IncrementalCache } from './lib/incremental-cache'\nimport { getCacheHandlers } from './use-cache/handlers'\n\n/** Run a callback, and execute any *new* revalidations added during its runtime. */\nexport async function withExecuteRevalidates<T>(\n  store: WorkStore | undefined,\n  callback: () => Promise<T>\n): Promise<T> {\n  if (!store) {\n    return callback()\n  }\n  // If we executed any revalidates during the request, then we don't want to execute them again.\n  // save the state so we can check if anything changed after we're done running callbacks.\n  const savedRevalidationState = cloneRevalidationState(store)\n  try {\n    return await callback()\n  } finally {\n    // Check if we have any new revalidates, and if so, wait until they are all resolved.\n    const newRevalidates = diffRevalidationState(\n      savedRevalidationState,\n      cloneRevalidationState(store)\n    )\n    await executeRevalidates(store, newRevalidates)\n  }\n}\n\ntype RevalidationState = Required<\n  Pick<\n    WorkStore,\n    'pendingRevalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n  >\n>\n\nfunction cloneRevalidationState(store: WorkStore): RevalidationState {\n  return {\n    pendingRevalidatedTags: store.pendingRevalidatedTags\n      ? [...store.pendingRevalidatedTags]\n      : [],\n    pendingRevalidates: { ...store.pendingRevalidates },\n    pendingRevalidateWrites: store.pendingRevalidateWrites\n      ? [...store.pendingRevalidateWrites]\n      : [],\n  }\n}\n\nfunction diffRevalidationState(\n  prev: RevalidationState,\n  curr: RevalidationState\n): RevalidationState {\n  const prevTagsWithProfile = new Set(\n    prev.pendingRevalidatedTags.map((item) => {\n      const profileKey =\n        typeof item.profile === 'object'\n          ? JSON.stringify(item.profile)\n          : item.profile || ''\n      return `${item.tag}:${profileKey}`\n    })\n  )\n  const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n  return {\n    pendingRevalidatedTags: curr.pendingRevalidatedTags.filter((item) => {\n      const profileKey =\n        typeof item.profile === 'object'\n          ? JSON.stringify(item.profile)\n          : item.profile || ''\n      return !prevTagsWithProfile.has(`${item.tag}:${profileKey}`)\n    }),\n    pendingRevalidates: Object.fromEntries(\n      Object.entries(curr.pendingRevalidates).filter(\n        ([key]) => !(key in prev.pendingRevalidates)\n      )\n    ),\n    pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(\n      (promise) => !prevRevalidateWrites.has(promise)\n    ),\n  }\n}\n\nasync function revalidateTags(\n  tagsWithProfile: Array<{\n    tag: string\n    profile?: string | { expire?: number }\n  }>,\n  incrementalCache: IncrementalCache | undefined,\n  workStore?: WorkStore\n): Promise<void> {\n  if (tagsWithProfile.length === 0) {\n    return\n  }\n\n  const handlers = getCacheHandlers()\n  const promises: Promise<void>[] = []\n\n  // Group tags by profile for batch processing\n  const tagsByProfile = new Map<\n    | string\n    | { stale?: number; revalidate?: number; expire?: number }\n    | undefined,\n    string[]\n  >()\n\n  for (const item of tagsWithProfile) {\n    const profile = item.profile\n    // Find existing profile by comparing values\n    let existingKey = undefined\n    for (const [key] of tagsByProfile) {\n      if (\n        typeof key === 'string' &&\n        typeof profile === 'string' &&\n        key === profile\n      ) {\n        existingKey = key\n        break\n      }\n      if (\n        typeof key === 'object' &&\n        typeof profile === 'object' &&\n        JSON.stringify(key) === JSON.stringify(profile)\n      ) {\n        existingKey = key\n        break\n      }\n      if (key === profile) {\n        existingKey = key\n        break\n      }\n    }\n\n    const profileKey = existingKey || profile\n    if (!tagsByProfile.has(profileKey)) {\n      tagsByProfile.set(profileKey, [])\n    }\n    tagsByProfile.get(profileKey)!.push(item.tag)\n  }\n\n  // Process each profile group\n  for (const [profile, tagsForProfile] of tagsByProfile) {\n    // Look up the cache profile from workStore if available\n    let durations: { expire?: number } | undefined\n\n    if (profile) {\n      let cacheLife:\n        | { stale?: number; revalidate?: number; expire?: number }\n        | undefined\n\n      if (typeof profile === 'object') {\n        // Profile is already a cacheLife configuration object\n        cacheLife = profile\n      } else if (typeof profile === 'string') {\n        // Profile is a string key, look it up in workStore\n        cacheLife = workStore?.cacheLifeProfiles?.[profile]\n\n        if (!cacheLife) {\n          throw new Error(\n            `Invalid profile provided \"${profile}\" must be configured under cacheLife in next.config or be \"max\"`\n          )\n        }\n      }\n\n      if (cacheLife) {\n        durations = {\n          expire: cacheLife.expire,\n        }\n      }\n    }\n    // If profile is not found and not 'max', durations will be undefined\n    // which will trigger immediate expiration in the cache handler\n\n    for (const handler of handlers || []) {\n      if (profile) {\n        promises.push(handler.updateTags?.(tagsForProfile, durations))\n      } else {\n        promises.push(handler.updateTags?.(tagsForProfile))\n      }\n    }\n\n    if (incrementalCache) {\n      promises.push(incrementalCache.revalidateTag(tagsForProfile, durations))\n    }\n  }\n\n  await Promise.all(promises)\n}\n\nexport async function executeRevalidates(\n  workStore: WorkStore,\n  state?: RevalidationState\n) {\n  const pendingRevalidatedTags =\n    state?.pendingRevalidatedTags ?? workStore.pendingRevalidatedTags ?? []\n\n  const pendingRevalidates =\n    state?.pendingRevalidates ?? workStore.pendingRevalidates ?? {}\n\n  const pendingRevalidateWrites =\n    state?.pendingRevalidateWrites ?? workStore.pendingRevalidateWrites ?? []\n\n  return Promise.all([\n    revalidateTags(\n      pendingRevalidatedTags,\n      workStore.incrementalCache,\n      workStore\n    ),\n    ...Object.values(pendingRevalidates),\n    ...pendingRevalidateWrites,\n  ])\n}\n"],"names":["getCacheHandlers","withExecuteRevalidates","store","callback","savedRevalidationState","cloneRevalidationState","newRevalidates","diffRevalidationState","executeRevalidates","pendingRevalidatedTags","pendingRevalidates","pendingRevalidateWrites","prev","curr","prevTagsWithProfile","Set","map","item","profileKey","profile","JSON","stringify","tag","prevRevalidateWrites","filter","has","Object","fromEntries","entries","key","promise","revalidateTags","tagsWithProfile","incrementalCache","workStore","length","handlers","promises","tagsByProfile","Map","existingKey","undefined","set","get","push","tagsForProfile","durations","cacheLife","cacheLifeProfiles","Error","expire","handler","updateTags","revalidateTag","Promise","all","state","values"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1339, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from '../revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose']\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose']\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(\n        task.catch((error) => this.reportTaskError('promise', error))\n      )\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error('`after()`: Argument must be a promise or a function')\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      this.workUnitStores.add(workUnitStore)\n    }\n\n    const afterTaskStore = afterTaskAsyncStorage.getStore()\n\n    // This is used for checking if request APIs can be called inside `after`.\n    // Note that we need to check the phase in which the *topmost* `after` was called (which should be \"action\"),\n    // not the current phase (which might be \"after\" if we're in a nested after).\n    // Otherwise, we might allow `after(() => headers())`, but not `after(() => after(() => headers()))`.\n    const rootTaskSpawnPhase = afterTaskStore\n      ? afterTaskStore.rootTaskSpawnPhase // nested after\n      : workUnitStore?.phase // topmost after\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(\n      // WARNING: Don't make this a named function. It must be anonymous.\n      // See: https://github.com/facebook/react/pull/34911\n      async () => {\n        try {\n          await afterTaskAsyncStorage.run({ rootTaskSpawnPhase }, () =>\n            callback()\n          )\n        } catch (error) {\n          this.reportTaskError('function', error)\n        }\n      }\n    )\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(taskKind: 'promise' | 'function', error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      taskKind === 'promise'\n        ? `A promise passed to \\`after()\\` rejected:`\n        : `An error occurred in a function passed to \\`after()\\`:`,\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","afterTaskAsyncStorage","AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","pause","after","task","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","workUnitStore","getStore","add","afterTaskStore","rootTaskSpawnPhase","phase","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","run","Promise","resolve","runCallbacks","size","workStore","start","onIdle","taskKind","console","handlerError","cause"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1480, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/after/builtin-request-context.ts"],"sourcesContent":["import { createAsyncLocalStorage } from '../app-render/async-local-storage'\n\nexport function getBuiltinRequestContext():\n  | BuiltinRequestContextValue\n  | undefined {\n  const _globalThis = globalThis as GlobalThisWithRequestContext\n  const ctx = _globalThis[NEXT_REQUEST_CONTEXT_SYMBOL]\n  return ctx?.get()\n}\n\nconst NEXT_REQUEST_CONTEXT_SYMBOL = Symbol.for('@next/request-context')\n\ntype GlobalThisWithRequestContext = typeof globalThis & {\n  [NEXT_REQUEST_CONTEXT_SYMBOL]?: BuiltinRequestContext\n}\n\n/** A request context provided by the platform. */\nexport type BuiltinRequestContext = {\n  get(): BuiltinRequestContextValue | undefined\n}\n\nexport type RunnableBuiltinRequestContext = BuiltinRequestContext & {\n  run<T>(value: BuiltinRequestContextValue, callback: () => T): T\n}\n\nexport type BuiltinRequestContextValue = {\n  waitUntil?: WaitUntil\n}\nexport type WaitUntil = (promise: Promise<any>) => void\n\n/** \"@next/request-context\" has a different signature from AsyncLocalStorage,\n * matching [AsyncContext.Variable](https://github.com/tc39/proposal-async-context).\n * We don't need a full AsyncContext adapter here, just having `.get()` is enough\n */\nexport function createLocalRequestContext(): RunnableBuiltinRequestContext {\n  const storage = createAsyncLocalStorage<BuiltinRequestContextValue>()\n  return {\n    get: () => storage.getStore(),\n    run: (value, callback) => storage.run(value, callback),\n  }\n}\n"],"names":["createAsyncLocalStorage","getBuiltinRequestContext","_globalThis","globalThis","ctx","NEXT_REQUEST_CONTEXT_SYMBOL","get","Symbol","for","createLocalRequestContext","storage","getStore","run","value","callback"],"mappings":";;;;;;AAAA,SAASA,uBAAuB,QAAQ,oCAAmC;;AAEpE,SAASC;IAGd,MAAMC,cAAcC;IACpB,MAAMC,MAAMF,WAAW,CAACG,4BAA4B;IACpD,OAAOD,OAAAA,OAAAA,KAAAA,IAAAA,IAAKE,GAAG;AACjB;AAEA,MAAMD,8BAA8BE,OAAOC,GAAG,CAAC;AAwBxC,SAASC;IACd,MAAMC,cAAUV,6OAAAA;IAChB,OAAO;QACLM,KAAK,IAAMI,QAAQC,QAAQ;QAC3BC,KAAK,CAACC,OAAOC,WAAaJ,QAAQE,GAAG,CAACC,OAAOC;IAC/C;AACF","ignoreList":[0]}},
    {"offset": {"line": 1505, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from '../revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose']\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose']\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(\n        task.catch((error) => this.reportTaskError('promise', error))\n      )\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error('`after()`: Argument must be a promise or a function')\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      this.workUnitStores.add(workUnitStore)\n    }\n\n    const afterTaskStore = afterTaskAsyncStorage.getStore()\n\n    // This is used for checking if request APIs can be called inside `after`.\n    // Note that we need to check the phase in which the *topmost* `after` was called (which should be \"action\"),\n    // not the current phase (which might be \"after\" if we're in a nested after).\n    // Otherwise, we might allow `after(() => headers())`, but not `after(() => after(() => headers()))`.\n    const rootTaskSpawnPhase = afterTaskStore\n      ? afterTaskStore.rootTaskSpawnPhase // nested after\n      : workUnitStore?.phase // topmost after\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(\n      // WARNING: Don't make this a named function. It must be anonymous.\n      // See: https://github.com/facebook/react/pull/34911\n      async () => {\n        try {\n          await afterTaskAsyncStorage.run({ rootTaskSpawnPhase }, () =>\n            callback()\n          )\n        } catch (error) {\n          this.reportTaskError('function', error)\n        }\n      }\n    )\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(taskKind: 'promise' | 'function', error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      taskKind === 'promise'\n        ? `A promise passed to \\`after()\\` rejected:`\n        : `An error occurred in a function passed to \\`after()\\`:`,\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","afterTaskAsyncStorage","AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","pause","after","task","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","workUnitStore","getStore","add","afterTaskStore","rootTaskSpawnPhase","phase","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","run","Promise","resolve","runCallbacks","size","workStore","start","onIdle","taskKind","console","handlerError","cause"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1646, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/response-cache/types.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'http'\nimport type RenderResult from '../render-result'\nimport type { CacheControl, Revalidate } from '../lib/cache-control'\nimport type { RouteKind } from '../route-kind'\n\nexport interface ResponseCacheBase {\n  get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      /**\n       * This is a hint to the cache to help it determine what kind of route\n       * this is so it knows where to look up the cache entry from. If not\n       * provided it will test the filesystem to check.\n       */\n      routeKind: RouteKind\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback?: boolean\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null>\n}\n\n// The server components HMR cache might store other data as well in the future,\n// at which point this should be refactored to a discriminated union type.\nexport interface ServerComponentsHmrCache {\n  get(key: string): CachedFetchData | undefined\n  set(key: string, data: CachedFetchData): void\n}\n\nexport type CachedFetchData = {\n  headers: Record<string, string>\n  body: string\n  url: string\n  status?: number\n}\n\nexport const enum CachedRouteKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  REDIRECT = 'REDIRECT',\n  IMAGE = 'IMAGE',\n}\n\nexport interface CachedFetchValue {\n  kind: CachedRouteKind.FETCH\n  data: CachedFetchData\n  // tags are only present with file-system-cache\n  // fetch cache stores tags outside of cache entry\n  tags?: string[]\n  revalidate: number\n}\n\nexport interface CachedRedirectValue {\n  kind: CachedRouteKind.REDIRECT\n  props: Object\n}\n\nexport interface CachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  rscData: Buffer | undefined\n  status: number | undefined\n  postponed: string | undefined\n  headers: OutgoingHttpHeaders | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface CachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  pageData: Object\n  status: number | undefined\n  headers: OutgoingHttpHeaders | undefined\n}\n\nexport interface CachedRouteValue {\n  kind: CachedRouteKind.APP_ROUTE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  body: Buffer\n  status: number\n  headers: OutgoingHttpHeaders\n}\n\nexport interface CachedImageValue {\n  kind: CachedRouteKind.IMAGE\n  etag: string\n  upstreamEtag: string\n  buffer: Buffer\n  extension: string\n  isMiss?: boolean\n  isStale?: boolean\n}\n\nexport interface IncrementalCachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  rscData: Buffer | undefined\n  headers: OutgoingHttpHeaders | undefined\n  postponed: string | undefined\n  status: number | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface IncrementalCachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  pageData: Object\n  headers: OutgoingHttpHeaders | undefined\n  status: number | undefined\n}\n\nexport interface IncrementalResponseCacheEntry {\n  cacheControl?: CacheControl\n  /**\n   * timestamp in milliseconds to revalidate after\n   */\n  revalidateAfter?: Revalidate\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  isMiss?: boolean\n  value: Exclude<IncrementalCacheValue, CachedFetchValue> | null\n}\n\nexport interface IncrementalFetchCacheEntry {\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  value: CachedFetchValue\n}\n\nexport type IncrementalCacheEntry =\n  | IncrementalResponseCacheEntry\n  | IncrementalFetchCacheEntry\n\nexport type IncrementalCacheValue =\n  | CachedRedirectValue\n  | IncrementalCachedPageValue\n  | IncrementalCachedAppPageValue\n  | CachedImageValue\n  | CachedFetchValue\n  | CachedRouteValue\n\nexport type ResponseCacheValue =\n  | CachedRedirectValue\n  | CachedPageValue\n  | CachedAppPageValue\n  | CachedImageValue\n  | CachedRouteValue\n\nexport type ResponseCacheEntry = {\n  cacheControl?: CacheControl\n  value: ResponseCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n}\n\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n  hasResolved: boolean\n  previousCacheEntry?: IncrementalResponseCacheEntry | null\n  isRevalidating?: boolean\n  span?: any\n\n  /**\n   * When true, this indicates that the response generator is being called in a\n   * context where the response must be generated statically.\n   *\n   * CRITICAL: This should only currently be used when revalidating due to a\n   * dynamic RSC request.\n   */\n  forceStaticRender?: boolean\n}) => Promise<ResponseCacheEntry | null>\n\nexport const enum IncrementalCacheKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  IMAGE = 'IMAGE',\n}\n\nexport interface GetIncrementalFetchCacheContext {\n  kind: IncrementalCacheKind.FETCH\n  revalidate?: Revalidate\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  softTags?: string[]\n}\n\nexport interface GetIncrementalResponseCacheContext {\n  kind: Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH>\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback: boolean\n}\n\nexport interface SetIncrementalFetchCacheContext {\n  fetchCache: true\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  isImplicitBuildTimeCache?: boolean\n}\n\nexport interface SetIncrementalResponseCacheContext {\n  fetchCache?: false\n  cacheControl?: CacheControl\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback?: boolean\n}\n\nexport interface IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n}\n\nexport interface IncrementalCache extends IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalFetchCacheContext\n  ): Promise<IncrementalFetchCacheEntry | null>\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: CachedFetchValue | null,\n    ctx: SetIncrementalFetchCacheContext\n  ): Promise<void>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n  revalidateTag(\n    tags: string | string[],\n    durations?: { expire?: number }\n  ): Promise<void>\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind"],"mappings":";;;;;;AA+CO,IAAWA,kBAAAA,WAAAA,GAAAA,SAAAA,eAAAA;;;;;;;WAAAA;MAOjB;AAmJM,IAAWC,uBAAAA,WAAAA,GAAAA,SAAAA,oBAAAA;;;;;;WAAAA;MAMjB","ignoreList":[0]}},
    {"offset": {"line": 1673, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/response-cache/utils.ts"],"sourcesContent":["import {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type IncrementalResponseCacheEntry,\n  type ResponseCacheEntry,\n} from './types'\n\nimport RenderResult from '../render-result'\nimport { RouteKind } from '../route-kind'\nimport { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants'\n\nexport async function fromResponseCacheEntry(\n  cacheEntry: ResponseCacheEntry\n): Promise<IncrementalResponseCacheEntry> {\n  return {\n    ...cacheEntry,\n    value:\n      cacheEntry.value?.kind === CachedRouteKind.PAGES\n        ? {\n            kind: CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n          }\n        : cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n          ? {\n              kind: CachedRouteKind.APP_PAGE,\n              html: await cacheEntry.value.html.toUnchunkedString(true),\n              postponed: cacheEntry.value.postponed,\n              rscData: cacheEntry.value.rscData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status,\n              segmentData: cacheEntry.value.segmentData,\n            }\n          : cacheEntry.value,\n  }\n}\n\nexport async function toResponseCacheEntry(\n  response: IncrementalResponseCacheEntry | null\n): Promise<ResponseCacheEntry | null> {\n  if (!response) return null\n\n  return {\n    isMiss: response.isMiss,\n    isStale: response.isStale,\n    cacheControl: response.cacheControl,\n    value:\n      response.value?.kind === CachedRouteKind.PAGES\n        ? ({\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(\n              response.value.html,\n              HTML_CONTENT_TYPE_HEADER\n            ),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status,\n          } satisfies CachedPageValue)\n        : response.value?.kind === CachedRouteKind.APP_PAGE\n          ? ({\n              kind: CachedRouteKind.APP_PAGE,\n              html: RenderResult.fromStatic(\n                response.value.html,\n                HTML_CONTENT_TYPE_HEADER\n              ),\n              rscData: response.value.rscData,\n              headers: response.value.headers,\n              status: response.value.status,\n              postponed: response.value.postponed,\n              segmentData: response.value.segmentData,\n            } satisfies CachedAppPageValue)\n          : response.value,\n  }\n}\n\nexport function routeKindToIncrementalCacheKind(\n  routeKind: RouteKind\n): Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH> {\n  switch (routeKind) {\n    case RouteKind.PAGES:\n      return IncrementalCacheKind.PAGES\n    case RouteKind.APP_PAGE:\n      return IncrementalCacheKind.APP_PAGE\n    case RouteKind.IMAGE:\n      return IncrementalCacheKind.IMAGE\n    case RouteKind.APP_ROUTE:\n      return IncrementalCacheKind.APP_ROUTE\n    case RouteKind.PAGES_API:\n      // Pages Router API routes are not cached in the incremental cache.\n      throw new Error(`Unexpected route kind ${routeKind}`)\n    default:\n      return routeKind satisfies never\n  }\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind","RenderResult","RouteKind","HTML_CONTENT_TYPE_HEADER","fromResponseCacheEntry","cacheEntry","value","kind","PAGES","html","toUnchunkedString","pageData","headers","status","APP_PAGE","postponed","rscData","segmentData","toResponseCacheEntry","response","isMiss","isStale","cacheControl","fromStatic","routeKindToIncrementalCacheKind","routeKind","IMAGE","APP_ROUTE","PAGES_API","Error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1759, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/response-cache/index.ts"],"sourcesContent":["import type {\n  ResponseCacheEntry,\n  ResponseGenerator,\n  ResponseCacheBase,\n  IncrementalResponseCacheEntry,\n  IncrementalResponseCache,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { LRUCache } from '../lib/lru-cache'\nimport { warnOnce } from '../../build/output/log'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\n/**\n * Parses an environment variable as a positive integer, returning the fallback\n * if the value is missing, not a number, or not positive.\n */\nfunction parsePositiveInt(\n  envValue: string | undefined,\n  fallback: number\n): number {\n  if (!envValue) return fallback\n  const parsed = parseInt(envValue, 10)\n  return Number.isFinite(parsed) && parsed > 0 ? parsed : fallback\n}\n\n/**\n * Default TTL (in milliseconds) for minimal mode response cache entries.\n * Used for cache hit validation as a fallback for providers that don't\n * send the x-invocation-id header yet.\n *\n * 10 seconds chosen because:\n * - Long enough to dedupe rapid successive requests (e.g., page + data)\n * - Short enough to not serve stale data across unrelated requests\n *\n * Can be configured via `NEXT_PRIVATE_RESPONSE_CACHE_TTL` environment variable.\n */\nconst DEFAULT_TTL_MS = parsePositiveInt(\n  process.env.NEXT_PRIVATE_RESPONSE_CACHE_TTL,\n  10_000\n)\n\n/**\n * Default maximum number of entries in the response cache.\n * Can be configured via `NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE` environment variable.\n */\nconst DEFAULT_MAX_SIZE = parsePositiveInt(\n  process.env.NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE,\n  150\n)\n\n/**\n * Separator used in compound cache keys to join pathname and invocationID.\n * Using null byte (\\0) since it cannot appear in valid URL paths or UUIDs.\n */\nconst KEY_SEPARATOR = '\\0'\n\n/**\n * Sentinel value used for TTL-based cache entries (when invocationID is undefined).\n * Chosen to be a clearly reserved marker for internal cache keys.\n */\nconst TTL_SENTINEL = '__ttl_sentinel__'\n\n/**\n * Entry stored in the LRU cache.\n */\ntype CacheEntry = {\n  entry: IncrementalResponseCacheEntry | null\n  /**\n   * TTL expiration timestamp in milliseconds. Used as a fallback for\n   * cache hit validation when providers don't send x-invocation-id.\n   * Memory pressure is managed by LRU eviction rather than timers.\n   */\n  expiresAt: number\n}\n\n/**\n * Creates a compound cache key from pathname and invocationID.\n */\nfunction createCacheKey(\n  pathname: string,\n  invocationID: string | undefined\n): string {\n  return `${pathname}${KEY_SEPARATOR}${invocationID ?? TTL_SENTINEL}`\n}\n\n/**\n * Extracts the invocationID from a compound cache key.\n * Returns undefined if the key used TTL_SENTINEL.\n */\nfunction extractInvocationID(compoundKey: string): string | undefined {\n  const separatorIndex = compoundKey.lastIndexOf(KEY_SEPARATOR)\n  if (separatorIndex === -1) return undefined\n\n  const invocationID = compoundKey.slice(separatorIndex + 1)\n  return invocationID === TTL_SENTINEL ? undefined : invocationID\n}\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly getBatcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalResponseCacheEntry | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private readonly revalidateBatcher = Batcher.create<\n    string,\n    IncrementalResponseCacheEntry | null\n  >({\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  /**\n   * LRU cache for minimal mode using compound keys (pathname + invocationID).\n   * This allows multiple invocations to cache the same pathname without\n   * overwriting each other's entries.\n   */\n  private readonly cache: LRUCache<CacheEntry>\n\n  /**\n   * Set of invocation IDs that have had cache entries evicted.\n   * Used to detect when the cache size may be too small.\n   * Bounded to prevent memory growth.\n   */\n  private readonly evictedInvocationIDs: Set<string> = new Set()\n\n  /**\n   * The configured max size, stored for logging.\n   */\n  private readonly maxSize: number\n\n  /**\n   * The configured TTL for cache entries in milliseconds.\n   */\n  private readonly ttl: number\n\n  // we don't use minimal_mode name here as this.minimal_mode is\n  // statically replace for server runtimes but we need it to\n  // be dynamic here\n  private minimal_mode?: boolean\n\n  constructor(\n    minimal_mode: boolean,\n    maxSize: number = DEFAULT_MAX_SIZE,\n    ttl: number = DEFAULT_TTL_MS\n  ) {\n    this.minimal_mode = minimal_mode\n    this.maxSize = maxSize\n    this.ttl = ttl\n\n    // Create the LRU cache with eviction tracking\n    this.cache = new LRUCache(maxSize, undefined, (compoundKey) => {\n      const invocationID = extractInvocationID(compoundKey)\n      if (invocationID) {\n        // Bound to 100 entries to prevent unbounded memory growth.\n        // FIFO eviction is acceptable here because:\n        // 1. Invocations are short-lived (single request lifecycle), so older\n        //    invocations are unlikely to still be active after 100 newer ones\n        // 2. This warning mechanism is best-effort for developer guidance\n        //    missing occasional eviction warnings doesn't affect correctness\n        // 3. If a long-running invocation is somehow evicted and then has\n        //    another cache entry evicted, it will simply be re-added\n        if (this.evictedInvocationIDs.size >= 100) {\n          const first = this.evictedInvocationIDs.values().next().value\n          if (first) this.evictedInvocationIDs.delete(first)\n        }\n        this.evictedInvocationIDs.add(invocationID)\n      }\n    })\n  }\n\n  /**\n   * Gets the response cache entry for the given key.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @returns The response cache entry.\n   */\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalResponseCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n      waitUntil?: (prom: Promise<any>) => void\n\n      /**\n       * The invocation ID from the infrastructure. Used to scope the\n       * in-memory cache to a single revalidation request in minimal mode.\n       */\n      invocationID?: string\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({\n        hasResolved: false,\n        previousCacheEntry: null,\n      })\n    }\n\n    // Check minimal mode cache before doing any other work.\n    if (this.minimal_mode) {\n      const cacheKey = createCacheKey(key, context.invocationID)\n      const cachedItem = this.cache.get(cacheKey)\n\n      if (cachedItem) {\n        // With invocationID: exact match found - always a hit\n        // With TTL mode: must check expiration\n        if (context.invocationID !== undefined) {\n          return toResponseCacheEntry(cachedItem.entry)\n        }\n\n        // TTL mode: check expiration\n        const now = Date.now()\n        if (cachedItem.expiresAt > now) {\n          return toResponseCacheEntry(cachedItem.entry)\n        }\n\n        // TTL expired - clean up\n        this.cache.remove(cacheKey)\n      }\n\n      // Warn if this invocation had entries evicted - indicates cache may be too small.\n      if (\n        context.invocationID &&\n        this.evictedInvocationIDs.has(context.invocationID)\n      ) {\n        warnOnce(\n          `Response cache entry was evicted for invocation ${context.invocationID}. ` +\n            `Consider increasing NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE (current: ${this.maxSize}).`\n        )\n      }\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n      isPrefetch = false,\n      waitUntil,\n      routeKind,\n      invocationID,\n    } = context\n\n    const response = await this.getBatcher.batch(\n      { key, isOnDemandRevalidate },\n      ({ resolve }) => {\n        const promise = this.handleGet(\n          key,\n          responseGenerator,\n          {\n            incrementalCache,\n            isOnDemandRevalidate,\n            isFallback,\n            isRoutePPREnabled,\n            isPrefetch,\n            routeKind,\n            invocationID,\n          },\n          resolve\n        )\n\n        // We need to ensure background revalidates are passed to waitUntil.\n        if (waitUntil) waitUntil(promise)\n\n        return promise\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n\n  /**\n   * Handles the get request for the response cache.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @param resolve - The resolve function to use to resolve the response cache entry.\n   * @returns The response cache entry.\n   */\n  private async handleGet(\n    key: string,\n    responseGenerator: ResponseGenerator,\n    context: {\n      incrementalCache: IncrementalResponseCache\n      isOnDemandRevalidate: boolean\n      isFallback: boolean\n      isRoutePPREnabled: boolean\n      isPrefetch: boolean\n      routeKind: RouteKind\n      invocationID: string | undefined\n    },\n    resolve: (value: IncrementalResponseCacheEntry | null) => void\n  ): Promise<IncrementalResponseCacheEntry | null> {\n    let previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null =\n      null\n    let resolved = false\n\n    try {\n      // Get the previous cache entry if not in minimal mode\n      previousIncrementalCacheEntry = !this.minimal_mode\n        ? await context.incrementalCache.get(key, {\n            kind: routeKindToIncrementalCacheKind(context.routeKind),\n            isRoutePPREnabled: context.isRoutePPREnabled,\n            isFallback: context.isFallback,\n          })\n        : null\n\n      if (previousIncrementalCacheEntry && !context.isOnDemandRevalidate) {\n        resolve(previousIncrementalCacheEntry)\n        resolved = true\n\n        if (!previousIncrementalCacheEntry.isStale || context.isPrefetch) {\n          // The cached value is still valid, so we don't need to update it yet.\n          return previousIncrementalCacheEntry\n        }\n      }\n\n      // Revalidate the cache entry\n      const incrementalResponseCacheEntry = await this.revalidate(\n        key,\n        context.incrementalCache,\n        context.isRoutePPREnabled,\n        context.isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        previousIncrementalCacheEntry !== null && !context.isOnDemandRevalidate,\n        undefined,\n        context.invocationID\n      )\n\n      // Handle null response\n      if (!incrementalResponseCacheEntry) {\n        // Remove the cache item if it was set so we don't use it again.\n        if (this.minimal_mode) {\n          const cacheKey = createCacheKey(key, context.invocationID)\n          this.cache.remove(cacheKey)\n        }\n        return null\n      }\n\n      // Resolve for on-demand revalidation or if not already resolved\n      if (context.isOnDemandRevalidate && !resolved) {\n        return incrementalResponseCacheEntry\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // If we've already resolved the cache entry, we can't reject as we\n      // already resolved the cache entry so log the error here.\n      if (resolved) {\n        console.error(err)\n        return null\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Revalidates the cache entry for the given key.\n   *\n   * @param key - The key to revalidate the cache entry for.\n   * @param incrementalCache - The incremental cache to use to revalidate the cache entry.\n   * @param isRoutePPREnabled - Whether the route is PPR enabled.\n   * @param isFallback - Whether the route is a fallback.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param previousIncrementalCacheEntry - The previous cache entry to use to revalidate the cache entry.\n   * @param hasResolved - Whether the response has been resolved.\n   * @param waitUntil - Optional function to register background work.\n   * @param invocationID - The invocation ID for cache key scoping.\n   * @returns The revalidated cache entry.\n   */\n  public async revalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean,\n    waitUntil?: (prom: Promise<any>) => void,\n    invocationID?: string\n  ) {\n    return this.revalidateBatcher.batch(key, () => {\n      const promise = this.handleRevalidate(\n        key,\n        incrementalCache,\n        isRoutePPREnabled,\n        isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        hasResolved,\n        invocationID\n      )\n\n      // We need to ensure background revalidates are passed to waitUntil.\n      if (waitUntil) waitUntil(promise)\n\n      return promise\n    })\n  }\n\n  private async handleRevalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean,\n    invocationID: string | undefined\n  ) {\n    try {\n      // Generate the response cache entry using the response generator.\n      const responseCacheEntry = await responseGenerator({\n        hasResolved,\n        previousCacheEntry: previousIncrementalCacheEntry,\n        isRevalidating: true,\n      })\n      if (!responseCacheEntry) {\n        return null\n      }\n\n      // Convert the response cache entry to an incremental response cache entry.\n      const incrementalResponseCacheEntry = await fromResponseCacheEntry({\n        ...responseCacheEntry,\n        isMiss: !previousIncrementalCacheEntry,\n      })\n\n      // We want to persist the result only if it has a cache control value\n      // defined.\n      if (incrementalResponseCacheEntry.cacheControl) {\n        if (this.minimal_mode) {\n          // Set TTL expiration for cache hit validation. Entries are validated\n          // by invocationID when available, with TTL as a fallback for providers\n          // that don't send x-invocation-id. Memory is managed by LRU eviction.\n          const cacheKey = createCacheKey(key, invocationID)\n          this.cache.set(cacheKey, {\n            entry: incrementalResponseCacheEntry,\n            expiresAt: Date.now() + this.ttl,\n          })\n        } else {\n          await incrementalCache.set(key, incrementalResponseCacheEntry.value, {\n            cacheControl: incrementalResponseCacheEntry.cacheControl,\n            isRoutePPREnabled,\n            isFallback,\n          })\n        }\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // When a path is erroring we automatically re-set the existing cache\n      // with new revalidate and expire times to prevent non-stop retrying.\n      if (previousIncrementalCacheEntry?.cacheControl) {\n        const revalidate = Math.min(\n          Math.max(\n            previousIncrementalCacheEntry.cacheControl.revalidate || 3,\n            3\n          ),\n          30\n        )\n        const expire =\n          previousIncrementalCacheEntry.cacheControl.expire === undefined\n            ? undefined\n            : Math.max(\n                revalidate + 3,\n                previousIncrementalCacheEntry.cacheControl.expire\n              )\n\n        await incrementalCache.set(key, previousIncrementalCacheEntry.value, {\n          cacheControl: { revalidate: revalidate, expire: expire },\n          isRoutePPREnabled,\n          isFallback,\n        })\n      }\n\n      // We haven't resolved yet, so let's throw to indicate an error.\n      throw err\n    }\n  }\n}\n"],"names":["Batcher","LRUCache","warnOnce","scheduleOnNextTick","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","parsePositiveInt","envValue","fallback","parsed","parseInt","Number","isFinite","DEFAULT_TTL_MS","process","env","NEXT_PRIVATE_RESPONSE_CACHE_TTL","DEFAULT_MAX_SIZE","NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE","KEY_SEPARATOR","TTL_SENTINEL","createCacheKey","pathname","invocationID","extractInvocationID","compoundKey","separatorIndex","lastIndexOf","undefined","slice","ResponseCache","constructor","minimal_mode","maxSize","ttl","getBatcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","revalidateBatcher","evictedInvocationIDs","Set","cache","size","first","values","next","value","delete","add","get","responseGenerator","context","hasResolved","previousCacheEntry","cacheKey","cachedItem","entry","now","Date","expiresAt","remove","has","incrementalCache","isFallback","isRoutePPREnabled","isPrefetch","waitUntil","routeKind","response","batch","resolve","promise","handleGet","previousIncrementalCacheEntry","resolved","kind","isStale","incrementalResponseCacheEntry","revalidate","err","console","error","handleRevalidate","responseCacheEntry","isRevalidating","isMiss","cacheControl","set","Math","min","max","expire"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2058, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/response-cache/types.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'http'\nimport type RenderResult from '../render-result'\nimport type { CacheControl, Revalidate } from '../lib/cache-control'\nimport type { RouteKind } from '../route-kind'\n\nexport interface ResponseCacheBase {\n  get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      /**\n       * This is a hint to the cache to help it determine what kind of route\n       * this is so it knows where to look up the cache entry from. If not\n       * provided it will test the filesystem to check.\n       */\n      routeKind: RouteKind\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback?: boolean\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null>\n}\n\n// The server components HMR cache might store other data as well in the future,\n// at which point this should be refactored to a discriminated union type.\nexport interface ServerComponentsHmrCache {\n  get(key: string): CachedFetchData | undefined\n  set(key: string, data: CachedFetchData): void\n}\n\nexport type CachedFetchData = {\n  headers: Record<string, string>\n  body: string\n  url: string\n  status?: number\n}\n\nexport const enum CachedRouteKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  REDIRECT = 'REDIRECT',\n  IMAGE = 'IMAGE',\n}\n\nexport interface CachedFetchValue {\n  kind: CachedRouteKind.FETCH\n  data: CachedFetchData\n  // tags are only present with file-system-cache\n  // fetch cache stores tags outside of cache entry\n  tags?: string[]\n  revalidate: number\n}\n\nexport interface CachedRedirectValue {\n  kind: CachedRouteKind.REDIRECT\n  props: Object\n}\n\nexport interface CachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  rscData: Buffer | undefined\n  status: number | undefined\n  postponed: string | undefined\n  headers: OutgoingHttpHeaders | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface CachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  pageData: Object\n  status: number | undefined\n  headers: OutgoingHttpHeaders | undefined\n}\n\nexport interface CachedRouteValue {\n  kind: CachedRouteKind.APP_ROUTE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  body: Buffer\n  status: number\n  headers: OutgoingHttpHeaders\n}\n\nexport interface CachedImageValue {\n  kind: CachedRouteKind.IMAGE\n  etag: string\n  upstreamEtag: string\n  buffer: Buffer\n  extension: string\n  isMiss?: boolean\n  isStale?: boolean\n}\n\nexport interface IncrementalCachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  rscData: Buffer | undefined\n  headers: OutgoingHttpHeaders | undefined\n  postponed: string | undefined\n  status: number | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface IncrementalCachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  pageData: Object\n  headers: OutgoingHttpHeaders | undefined\n  status: number | undefined\n}\n\nexport interface IncrementalResponseCacheEntry {\n  cacheControl?: CacheControl\n  /**\n   * timestamp in milliseconds to revalidate after\n   */\n  revalidateAfter?: Revalidate\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  isMiss?: boolean\n  value: Exclude<IncrementalCacheValue, CachedFetchValue> | null\n}\n\nexport interface IncrementalFetchCacheEntry {\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  value: CachedFetchValue\n}\n\nexport type IncrementalCacheEntry =\n  | IncrementalResponseCacheEntry\n  | IncrementalFetchCacheEntry\n\nexport type IncrementalCacheValue =\n  | CachedRedirectValue\n  | IncrementalCachedPageValue\n  | IncrementalCachedAppPageValue\n  | CachedImageValue\n  | CachedFetchValue\n  | CachedRouteValue\n\nexport type ResponseCacheValue =\n  | CachedRedirectValue\n  | CachedPageValue\n  | CachedAppPageValue\n  | CachedImageValue\n  | CachedRouteValue\n\nexport type ResponseCacheEntry = {\n  cacheControl?: CacheControl\n  value: ResponseCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n}\n\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n  hasResolved: boolean\n  previousCacheEntry?: IncrementalResponseCacheEntry | null\n  isRevalidating?: boolean\n  span?: any\n\n  /**\n   * When true, this indicates that the response generator is being called in a\n   * context where the response must be generated statically.\n   *\n   * CRITICAL: This should only currently be used when revalidating due to a\n   * dynamic RSC request.\n   */\n  forceStaticRender?: boolean\n}) => Promise<ResponseCacheEntry | null>\n\nexport const enum IncrementalCacheKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  IMAGE = 'IMAGE',\n}\n\nexport interface GetIncrementalFetchCacheContext {\n  kind: IncrementalCacheKind.FETCH\n  revalidate?: Revalidate\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  softTags?: string[]\n}\n\nexport interface GetIncrementalResponseCacheContext {\n  kind: Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH>\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback: boolean\n}\n\nexport interface SetIncrementalFetchCacheContext {\n  fetchCache: true\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  isImplicitBuildTimeCache?: boolean\n}\n\nexport interface SetIncrementalResponseCacheContext {\n  fetchCache?: false\n  cacheControl?: CacheControl\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback?: boolean\n}\n\nexport interface IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n}\n\nexport interface IncrementalCache extends IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalFetchCacheContext\n  ): Promise<IncrementalFetchCacheEntry | null>\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: CachedFetchValue | null,\n    ctx: SetIncrementalFetchCacheContext\n  ): Promise<void>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n  revalidateTag(\n    tags: string | string[],\n    durations?: { expire?: number }\n  ): Promise<void>\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind"],"mappings":";;;;;;AA+CO,IAAWA,kBAAAA,WAAAA,GAAAA,SAAAA,eAAAA;;;;;;;WAAAA;MAOjB;AAmJM,IAAWC,uBAAAA,WAAAA,GAAAA,SAAAA,oBAAAA;;;;;;WAAAA;MAMjB","ignoreList":[0]}},
    {"offset": {"line": 2085, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/response-cache/utils.ts"],"sourcesContent":["import {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type IncrementalResponseCacheEntry,\n  type ResponseCacheEntry,\n} from './types'\n\nimport RenderResult from '../render-result'\nimport { RouteKind } from '../route-kind'\nimport { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants'\n\nexport async function fromResponseCacheEntry(\n  cacheEntry: ResponseCacheEntry\n): Promise<IncrementalResponseCacheEntry> {\n  return {\n    ...cacheEntry,\n    value:\n      cacheEntry.value?.kind === CachedRouteKind.PAGES\n        ? {\n            kind: CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n          }\n        : cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n          ? {\n              kind: CachedRouteKind.APP_PAGE,\n              html: await cacheEntry.value.html.toUnchunkedString(true),\n              postponed: cacheEntry.value.postponed,\n              rscData: cacheEntry.value.rscData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status,\n              segmentData: cacheEntry.value.segmentData,\n            }\n          : cacheEntry.value,\n  }\n}\n\nexport async function toResponseCacheEntry(\n  response: IncrementalResponseCacheEntry | null\n): Promise<ResponseCacheEntry | null> {\n  if (!response) return null\n\n  return {\n    isMiss: response.isMiss,\n    isStale: response.isStale,\n    cacheControl: response.cacheControl,\n    value:\n      response.value?.kind === CachedRouteKind.PAGES\n        ? ({\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(\n              response.value.html,\n              HTML_CONTENT_TYPE_HEADER\n            ),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status,\n          } satisfies CachedPageValue)\n        : response.value?.kind === CachedRouteKind.APP_PAGE\n          ? ({\n              kind: CachedRouteKind.APP_PAGE,\n              html: RenderResult.fromStatic(\n                response.value.html,\n                HTML_CONTENT_TYPE_HEADER\n              ),\n              rscData: response.value.rscData,\n              headers: response.value.headers,\n              status: response.value.status,\n              postponed: response.value.postponed,\n              segmentData: response.value.segmentData,\n            } satisfies CachedAppPageValue)\n          : response.value,\n  }\n}\n\nexport function routeKindToIncrementalCacheKind(\n  routeKind: RouteKind\n): Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH> {\n  switch (routeKind) {\n    case RouteKind.PAGES:\n      return IncrementalCacheKind.PAGES\n    case RouteKind.APP_PAGE:\n      return IncrementalCacheKind.APP_PAGE\n    case RouteKind.IMAGE:\n      return IncrementalCacheKind.IMAGE\n    case RouteKind.APP_ROUTE:\n      return IncrementalCacheKind.APP_ROUTE\n    case RouteKind.PAGES_API:\n      // Pages Router API routes are not cached in the incremental cache.\n      throw new Error(`Unexpected route kind ${routeKind}`)\n    default:\n      return routeKind satisfies never\n  }\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind","RenderResult","RouteKind","HTML_CONTENT_TYPE_HEADER","fromResponseCacheEntry","cacheEntry","value","kind","PAGES","html","toUnchunkedString","pageData","headers","status","APP_PAGE","postponed","rscData","segmentData","toResponseCacheEntry","response","isMiss","isStale","cacheControl","fromStatic","routeKindToIncrementalCacheKind","routeKind","IMAGE","APP_ROUTE","PAGES_API","Error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2171, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/response-cache/index.ts"],"sourcesContent":["import type {\n  ResponseCacheEntry,\n  ResponseGenerator,\n  ResponseCacheBase,\n  IncrementalResponseCacheEntry,\n  IncrementalResponseCache,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { LRUCache } from '../lib/lru-cache'\nimport { warnOnce } from '../../build/output/log'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\n/**\n * Parses an environment variable as a positive integer, returning the fallback\n * if the value is missing, not a number, or not positive.\n */\nfunction parsePositiveInt(\n  envValue: string | undefined,\n  fallback: number\n): number {\n  if (!envValue) return fallback\n  const parsed = parseInt(envValue, 10)\n  return Number.isFinite(parsed) && parsed > 0 ? parsed : fallback\n}\n\n/**\n * Default TTL (in milliseconds) for minimal mode response cache entries.\n * Used for cache hit validation as a fallback for providers that don't\n * send the x-invocation-id header yet.\n *\n * 10 seconds chosen because:\n * - Long enough to dedupe rapid successive requests (e.g., page + data)\n * - Short enough to not serve stale data across unrelated requests\n *\n * Can be configured via `NEXT_PRIVATE_RESPONSE_CACHE_TTL` environment variable.\n */\nconst DEFAULT_TTL_MS = parsePositiveInt(\n  process.env.NEXT_PRIVATE_RESPONSE_CACHE_TTL,\n  10_000\n)\n\n/**\n * Default maximum number of entries in the response cache.\n * Can be configured via `NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE` environment variable.\n */\nconst DEFAULT_MAX_SIZE = parsePositiveInt(\n  process.env.NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE,\n  150\n)\n\n/**\n * Separator used in compound cache keys to join pathname and invocationID.\n * Using null byte (\\0) since it cannot appear in valid URL paths or UUIDs.\n */\nconst KEY_SEPARATOR = '\\0'\n\n/**\n * Sentinel value used for TTL-based cache entries (when invocationID is undefined).\n * Chosen to be a clearly reserved marker for internal cache keys.\n */\nconst TTL_SENTINEL = '__ttl_sentinel__'\n\n/**\n * Entry stored in the LRU cache.\n */\ntype CacheEntry = {\n  entry: IncrementalResponseCacheEntry | null\n  /**\n   * TTL expiration timestamp in milliseconds. Used as a fallback for\n   * cache hit validation when providers don't send x-invocation-id.\n   * Memory pressure is managed by LRU eviction rather than timers.\n   */\n  expiresAt: number\n}\n\n/**\n * Creates a compound cache key from pathname and invocationID.\n */\nfunction createCacheKey(\n  pathname: string,\n  invocationID: string | undefined\n): string {\n  return `${pathname}${KEY_SEPARATOR}${invocationID ?? TTL_SENTINEL}`\n}\n\n/**\n * Extracts the invocationID from a compound cache key.\n * Returns undefined if the key used TTL_SENTINEL.\n */\nfunction extractInvocationID(compoundKey: string): string | undefined {\n  const separatorIndex = compoundKey.lastIndexOf(KEY_SEPARATOR)\n  if (separatorIndex === -1) return undefined\n\n  const invocationID = compoundKey.slice(separatorIndex + 1)\n  return invocationID === TTL_SENTINEL ? undefined : invocationID\n}\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly getBatcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalResponseCacheEntry | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private readonly revalidateBatcher = Batcher.create<\n    string,\n    IncrementalResponseCacheEntry | null\n  >({\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  /**\n   * LRU cache for minimal mode using compound keys (pathname + invocationID).\n   * This allows multiple invocations to cache the same pathname without\n   * overwriting each other's entries.\n   */\n  private readonly cache: LRUCache<CacheEntry>\n\n  /**\n   * Set of invocation IDs that have had cache entries evicted.\n   * Used to detect when the cache size may be too small.\n   * Bounded to prevent memory growth.\n   */\n  private readonly evictedInvocationIDs: Set<string> = new Set()\n\n  /**\n   * The configured max size, stored for logging.\n   */\n  private readonly maxSize: number\n\n  /**\n   * The configured TTL for cache entries in milliseconds.\n   */\n  private readonly ttl: number\n\n  // we don't use minimal_mode name here as this.minimal_mode is\n  // statically replace for server runtimes but we need it to\n  // be dynamic here\n  private minimal_mode?: boolean\n\n  constructor(\n    minimal_mode: boolean,\n    maxSize: number = DEFAULT_MAX_SIZE,\n    ttl: number = DEFAULT_TTL_MS\n  ) {\n    this.minimal_mode = minimal_mode\n    this.maxSize = maxSize\n    this.ttl = ttl\n\n    // Create the LRU cache with eviction tracking\n    this.cache = new LRUCache(maxSize, undefined, (compoundKey) => {\n      const invocationID = extractInvocationID(compoundKey)\n      if (invocationID) {\n        // Bound to 100 entries to prevent unbounded memory growth.\n        // FIFO eviction is acceptable here because:\n        // 1. Invocations are short-lived (single request lifecycle), so older\n        //    invocations are unlikely to still be active after 100 newer ones\n        // 2. This warning mechanism is best-effort for developer guidance\n        //    missing occasional eviction warnings doesn't affect correctness\n        // 3. If a long-running invocation is somehow evicted and then has\n        //    another cache entry evicted, it will simply be re-added\n        if (this.evictedInvocationIDs.size >= 100) {\n          const first = this.evictedInvocationIDs.values().next().value\n          if (first) this.evictedInvocationIDs.delete(first)\n        }\n        this.evictedInvocationIDs.add(invocationID)\n      }\n    })\n  }\n\n  /**\n   * Gets the response cache entry for the given key.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @returns The response cache entry.\n   */\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalResponseCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n      waitUntil?: (prom: Promise<any>) => void\n\n      /**\n       * The invocation ID from the infrastructure. Used to scope the\n       * in-memory cache to a single revalidation request in minimal mode.\n       */\n      invocationID?: string\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({\n        hasResolved: false,\n        previousCacheEntry: null,\n      })\n    }\n\n    // Check minimal mode cache before doing any other work.\n    if (this.minimal_mode) {\n      const cacheKey = createCacheKey(key, context.invocationID)\n      const cachedItem = this.cache.get(cacheKey)\n\n      if (cachedItem) {\n        // With invocationID: exact match found - always a hit\n        // With TTL mode: must check expiration\n        if (context.invocationID !== undefined) {\n          return toResponseCacheEntry(cachedItem.entry)\n        }\n\n        // TTL mode: check expiration\n        const now = Date.now()\n        if (cachedItem.expiresAt > now) {\n          return toResponseCacheEntry(cachedItem.entry)\n        }\n\n        // TTL expired - clean up\n        this.cache.remove(cacheKey)\n      }\n\n      // Warn if this invocation had entries evicted - indicates cache may be too small.\n      if (\n        context.invocationID &&\n        this.evictedInvocationIDs.has(context.invocationID)\n      ) {\n        warnOnce(\n          `Response cache entry was evicted for invocation ${context.invocationID}. ` +\n            `Consider increasing NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE (current: ${this.maxSize}).`\n        )\n      }\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n      isPrefetch = false,\n      waitUntil,\n      routeKind,\n      invocationID,\n    } = context\n\n    const response = await this.getBatcher.batch(\n      { key, isOnDemandRevalidate },\n      ({ resolve }) => {\n        const promise = this.handleGet(\n          key,\n          responseGenerator,\n          {\n            incrementalCache,\n            isOnDemandRevalidate,\n            isFallback,\n            isRoutePPREnabled,\n            isPrefetch,\n            routeKind,\n            invocationID,\n          },\n          resolve\n        )\n\n        // We need to ensure background revalidates are passed to waitUntil.\n        if (waitUntil) waitUntil(promise)\n\n        return promise\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n\n  /**\n   * Handles the get request for the response cache.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @param resolve - The resolve function to use to resolve the response cache entry.\n   * @returns The response cache entry.\n   */\n  private async handleGet(\n    key: string,\n    responseGenerator: ResponseGenerator,\n    context: {\n      incrementalCache: IncrementalResponseCache\n      isOnDemandRevalidate: boolean\n      isFallback: boolean\n      isRoutePPREnabled: boolean\n      isPrefetch: boolean\n      routeKind: RouteKind\n      invocationID: string | undefined\n    },\n    resolve: (value: IncrementalResponseCacheEntry | null) => void\n  ): Promise<IncrementalResponseCacheEntry | null> {\n    let previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null =\n      null\n    let resolved = false\n\n    try {\n      // Get the previous cache entry if not in minimal mode\n      previousIncrementalCacheEntry = !this.minimal_mode\n        ? await context.incrementalCache.get(key, {\n            kind: routeKindToIncrementalCacheKind(context.routeKind),\n            isRoutePPREnabled: context.isRoutePPREnabled,\n            isFallback: context.isFallback,\n          })\n        : null\n\n      if (previousIncrementalCacheEntry && !context.isOnDemandRevalidate) {\n        resolve(previousIncrementalCacheEntry)\n        resolved = true\n\n        if (!previousIncrementalCacheEntry.isStale || context.isPrefetch) {\n          // The cached value is still valid, so we don't need to update it yet.\n          return previousIncrementalCacheEntry\n        }\n      }\n\n      // Revalidate the cache entry\n      const incrementalResponseCacheEntry = await this.revalidate(\n        key,\n        context.incrementalCache,\n        context.isRoutePPREnabled,\n        context.isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        previousIncrementalCacheEntry !== null && !context.isOnDemandRevalidate,\n        undefined,\n        context.invocationID\n      )\n\n      // Handle null response\n      if (!incrementalResponseCacheEntry) {\n        // Remove the cache item if it was set so we don't use it again.\n        if (this.minimal_mode) {\n          const cacheKey = createCacheKey(key, context.invocationID)\n          this.cache.remove(cacheKey)\n        }\n        return null\n      }\n\n      // Resolve for on-demand revalidation or if not already resolved\n      if (context.isOnDemandRevalidate && !resolved) {\n        return incrementalResponseCacheEntry\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // If we've already resolved the cache entry, we can't reject as we\n      // already resolved the cache entry so log the error here.\n      if (resolved) {\n        console.error(err)\n        return null\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Revalidates the cache entry for the given key.\n   *\n   * @param key - The key to revalidate the cache entry for.\n   * @param incrementalCache - The incremental cache to use to revalidate the cache entry.\n   * @param isRoutePPREnabled - Whether the route is PPR enabled.\n   * @param isFallback - Whether the route is a fallback.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param previousIncrementalCacheEntry - The previous cache entry to use to revalidate the cache entry.\n   * @param hasResolved - Whether the response has been resolved.\n   * @param waitUntil - Optional function to register background work.\n   * @param invocationID - The invocation ID for cache key scoping.\n   * @returns The revalidated cache entry.\n   */\n  public async revalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean,\n    waitUntil?: (prom: Promise<any>) => void,\n    invocationID?: string\n  ) {\n    return this.revalidateBatcher.batch(key, () => {\n      const promise = this.handleRevalidate(\n        key,\n        incrementalCache,\n        isRoutePPREnabled,\n        isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        hasResolved,\n        invocationID\n      )\n\n      // We need to ensure background revalidates are passed to waitUntil.\n      if (waitUntil) waitUntil(promise)\n\n      return promise\n    })\n  }\n\n  private async handleRevalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean,\n    invocationID: string | undefined\n  ) {\n    try {\n      // Generate the response cache entry using the response generator.\n      const responseCacheEntry = await responseGenerator({\n        hasResolved,\n        previousCacheEntry: previousIncrementalCacheEntry,\n        isRevalidating: true,\n      })\n      if (!responseCacheEntry) {\n        return null\n      }\n\n      // Convert the response cache entry to an incremental response cache entry.\n      const incrementalResponseCacheEntry = await fromResponseCacheEntry({\n        ...responseCacheEntry,\n        isMiss: !previousIncrementalCacheEntry,\n      })\n\n      // We want to persist the result only if it has a cache control value\n      // defined.\n      if (incrementalResponseCacheEntry.cacheControl) {\n        if (this.minimal_mode) {\n          // Set TTL expiration for cache hit validation. Entries are validated\n          // by invocationID when available, with TTL as a fallback for providers\n          // that don't send x-invocation-id. Memory is managed by LRU eviction.\n          const cacheKey = createCacheKey(key, invocationID)\n          this.cache.set(cacheKey, {\n            entry: incrementalResponseCacheEntry,\n            expiresAt: Date.now() + this.ttl,\n          })\n        } else {\n          await incrementalCache.set(key, incrementalResponseCacheEntry.value, {\n            cacheControl: incrementalResponseCacheEntry.cacheControl,\n            isRoutePPREnabled,\n            isFallback,\n          })\n        }\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // When a path is erroring we automatically re-set the existing cache\n      // with new revalidate and expire times to prevent non-stop retrying.\n      if (previousIncrementalCacheEntry?.cacheControl) {\n        const revalidate = Math.min(\n          Math.max(\n            previousIncrementalCacheEntry.cacheControl.revalidate || 3,\n            3\n          ),\n          30\n        )\n        const expire =\n          previousIncrementalCacheEntry.cacheControl.expire === undefined\n            ? undefined\n            : Math.max(\n                revalidate + 3,\n                previousIncrementalCacheEntry.cacheControl.expire\n              )\n\n        await incrementalCache.set(key, previousIncrementalCacheEntry.value, {\n          cacheControl: { revalidate: revalidate, expire: expire },\n          isRoutePPREnabled,\n          isFallback,\n        })\n      }\n\n      // We haven't resolved yet, so let's throw to indicate an error.\n      throw err\n    }\n  }\n}\n"],"names":["Batcher","LRUCache","warnOnce","scheduleOnNextTick","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","parsePositiveInt","envValue","fallback","parsed","parseInt","Number","isFinite","DEFAULT_TTL_MS","process","env","NEXT_PRIVATE_RESPONSE_CACHE_TTL","DEFAULT_MAX_SIZE","NEXT_PRIVATE_RESPONSE_CACHE_MAX_SIZE","KEY_SEPARATOR","TTL_SENTINEL","createCacheKey","pathname","invocationID","extractInvocationID","compoundKey","separatorIndex","lastIndexOf","undefined","slice","ResponseCache","constructor","minimal_mode","maxSize","ttl","getBatcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","revalidateBatcher","evictedInvocationIDs","Set","cache","size","first","values","next","value","delete","add","get","responseGenerator","context","hasResolved","previousCacheEntry","cacheKey","cachedItem","entry","now","Date","expiresAt","remove","has","incrementalCache","isFallback","isRoutePPREnabled","isPrefetch","waitUntil","routeKind","response","batch","resolve","promise","handleGet","previousIncrementalCacheEntry","resolved","kind","isStale","incrementalResponseCacheEntry","revalidate","err","console","error","handleRevalidate","responseCacheEntry","isRevalidating","isMiss","cacheControl","set","Math","min","max","expire"],"mappings":";;;;AAQA,SAASA,OAAO,QAAQ,oBAAmB;AAC3C,SAASC,QAAQ,QAAQ,mBAAkB;AAC3C,SAASC,QAAQ,QAAQ,yBAAwB;AACjD,SAASC,kBAAkB,QAAQ,sBAAqB;AACxD,SACEC,sBAAsB,EACtBC,+BAA+B,EAC/BC,oBAAoB,QACf,UAAS;AAwFhB,cAAc,UAAS;;;;;;AArFvB;;;CAGC,GACD,SAASC,iBACPC,QAA4B,EAC5BC,QAAgB;IAEhB,IAAI,CAACD,UAAU,OAAOC;IACtB,MAAMC,SAASC,SAASH,UAAU;IAClC,OAAOI,OAAOC,QAAQ,CAACH,WAAWA,SAAS,IAAIA,SAASD;AAC1D;AAEA;;;;;;;;;;CAUC,GACD,MAAMK,iBAAiBP,iBACrBQ,QAAQC,GAAG,CAACC,+BAA+B,EAC3C;AAGF;;;CAGC,GACD,MAAMC,mBAAmBX,iBACvBQ,QAAQC,GAAG,CAACG,oCAAoC,EAChD;AAGF;;;CAGC,GACD,MAAMC,gBAAgB;AAEtB;;;CAGC,GACD,MAAMC,eAAe;AAerB;;CAEC,GACD,SAASC,eACPC,QAAgB,EAChBC,YAAgC;IAEhC,OAAO,GAAGD,WAAWH,gBAAgBI,gBAAgBH,cAAc;AACrE;AAEA;;;CAGC,GACD,SAASI,oBAAoBC,WAAmB;IAC9C,MAAMC,iBAAiBD,YAAYE,WAAW,CAACR;IAC/C,IAAIO,mBAAmB,CAAC,GAAG,OAAOE;IAElC,MAAML,eAAeE,YAAYI,KAAK,CAACH,iBAAiB;IACxD,OAAOH,iBAAiBH,eAAeQ,YAAYL;AACrD;;AAIe,MAAMO;IAuDnBC,YACEC,YAAqB,EACrBC,UAAkBhB,gBAAgB,EAClCiB,MAAcrB,cAAc,CAC5B;aA1DesB,UAAAA,GAAapC,uLAAAA,CAAQqC,MAAM,CAI1C;YACA,0EAA0E;YAC1E,4EAA4E;YAC5EC,YAAY,CAAC,EAAEC,GAAG,EAAEC,oBAAoB,EAAE,GACxC,GAAGD,IAAI,CAAC,EAAEC,uBAAuB,MAAM,KAAK;YAC9C,sEAAsE;YACtE,uEAAuE;YACvE,oDAAoD;YACpDC,aAAatC,oMAAAA;QACf;aAEiBuC,iBAAAA,GAAoB1C,uLAAAA,CAAQqC,MAAM,CAGjD;YACA,sEAAsE;YACtE,uEAAuE;YACvE,oDAAoD;YACpDI,aAAatC,oMAAAA;QACf;QASA;;;;GAIC,GAAA,IAAA,CACgBwC,oBAAAA,GAAoC,IAAIC;QAsBvD,IAAI,CAACX,YAAY,GAAGA;QACpB,IAAI,CAACC,OAAO,GAAGA;QACf,IAAI,CAACC,GAAG,GAAGA;QAEX,8CAA8C;QAC9C,IAAI,CAACU,KAAK,GAAG,IAAI5C,uMAAAA,CAASiC,SAASL,WAAW,CAACH;YAC7C,MAAMF,eAAeC,oBAAoBC;YACzC,IAAIF,cAAc;gBAChB,2DAA2D;gBAC3D,4CAA4C;gBAC5C,sEAAsE;gBACtE,sEAAsE;gBACtE,mEAAmE;gBACnE,qEAAqE;gBACrE,kEAAkE;gBAClE,6DAA6D;gBAC7D,IAAI,IAAI,CAACmB,oBAAoB,CAACG,IAAI,IAAI,KAAK;oBACzC,MAAMC,QAAQ,IAAI,CAACJ,oBAAoB,CAACK,MAAM,GAAGC,IAAI,GAAGC,KAAK;oBAC7D,IAAIH,OAAO,IAAI,CAACJ,oBAAoB,CAACQ,MAAM,CAACJ;gBAC9C;gBACA,IAAI,CAACJ,oBAAoB,CAACS,GAAG,CAAC5B;YAChC;QACF;IACF;IAEA;;;;;;;GAOC,GACD,MAAa6B,IACXd,GAAkB,EAClBe,iBAAoC,EACpCC,OAcC,EACmC;QACpC,0EAA0E;QAC1E,6DAA6D;QAC7D,IAAI,CAAChB,KAAK;YACR,OAAOe,kBAAkB;gBACvBE,aAAa;gBACbC,oBAAoB;YACtB;QACF;QAEA,wDAAwD;QACxD,IAAI,IAAI,CAACxB,YAAY,EAAE;YACrB,MAAMyB,WAAWpC,eAAeiB,KAAKgB,QAAQ/B,YAAY;YACzD,MAAMmC,aAAa,IAAI,CAACd,KAAK,CAACQ,GAAG,CAACK;YAElC,IAAIC,YAAY;gBACd,sDAAsD;gBACtD,uCAAuC;gBACvC,IAAIJ,QAAQ/B,YAAY,KAAKK,WAAW;oBACtC,WAAOvB,0NAAAA,EAAqBqD,WAAWC,KAAK;gBAC9C;gBAEA,6BAA6B;gBAC7B,MAAMC,MAAMC,KAAKD,GAAG;gBACpB,IAAIF,WAAWI,SAAS,GAAGF,KAAK;oBAC9B,OAAOvD,8NAAAA,EAAqBqD,WAAWC,KAAK;gBAC9C;gBAEA,yBAAyB;gBACzB,IAAI,CAACf,KAAK,CAACmB,MAAM,CAACN;YACpB;YAEA,kFAAkF;YAClF,IACEH,QAAQ/B,YAAY,IACpB,IAAI,CAACmB,oBAAoB,CAACsB,GAAG,CAACV,QAAQ/B,YAAY,GAClD;oBACAtB,gMAAAA,EACE,CAAC,gDAAgD,EAAEqD,QAAQ/B,YAAY,CAAC,EAAE,CAAC,GACzE,CAAC,mEAAmE,EAAE,IAAI,CAACU,OAAO,CAAC,EAAE,CAAC;YAE5F;QACF;QAEA,MAAM,EACJgC,gBAAgB,EAChB1B,uBAAuB,KAAK,EAC5B2B,aAAa,KAAK,EAClBC,oBAAoB,KAAK,EACzBC,aAAa,KAAK,EAClBC,SAAS,EACTC,SAAS,EACT/C,YAAY,EACb,GAAG+B;QAEJ,MAAMiB,WAAW,MAAM,IAAI,CAACpC,UAAU,CAACqC,KAAK,CAC1C;YAAElC;YAAKC;QAAqB,GAC5B,CAAC,EAAEkC,OAAO,EAAE;YACV,MAAMC,UAAU,IAAI,CAACC,SAAS,CAC5BrC,KACAe,mBACA;gBACEY;gBACA1B;gBACA2B;gBACAC;gBACAC;gBACAE;gBACA/C;YACF,GACAkD;YAGF,oEAAoE;YACpE,IAAIJ,WAAWA,UAAUK;YAEzB,OAAOA;QACT;QAGF,WAAOrE,0NAAAA,EAAqBkE;IAC9B;IAEA;;;;;;;;GAQC,GACD,MAAcI,UACZrC,GAAW,EACXe,iBAAoC,EACpCC,OAQC,EACDmB,OAA8D,EACf;QAC/C,IAAIG,gCACF;QACF,IAAIC,WAAW;QAEf,IAAI;YACF,sDAAsD;YACtDD,gCAAgC,CAAC,IAAI,CAAC5C,YAAY,GAC9C,MAAMsB,QAAQW,gBAAgB,CAACb,GAAG,CAACd,KAAK;gBACtCwC,UAAM1E,qOAAAA,EAAgCkD,QAAQgB,SAAS;gBACvDH,mBAAmBb,QAAQa,iBAAiB;gBAC5CD,YAAYZ,QAAQY,UAAU;YAChC,KACA;YAEJ,IAAIU,iCAAiC,CAACtB,QAAQf,oBAAoB,EAAE;gBAClEkC,QAAQG;gBACRC,WAAW;gBAEX,IAAI,CAACD,8BAA8BG,OAAO,IAAIzB,QAAQc,UAAU,EAAE;oBAChE,sEAAsE;oBACtE,OAAOQ;gBACT;YACF;YAEA,6BAA6B;YAC7B,MAAMI,gCAAgC,MAAM,IAAI,CAACC,UAAU,CACzD3C,KACAgB,QAAQW,gBAAgB,EACxBX,QAAQa,iBAAiB,EACzBb,QAAQY,UAAU,EAClBb,mBACAuB,+BACAA,kCAAkC,QAAQ,CAACtB,QAAQf,oBAAoB,EACvEX,WACA0B,QAAQ/B,YAAY;YAGtB,uBAAuB;YACvB,IAAI,CAACyD,+BAA+B;gBAClC,gEAAgE;gBAChE,IAAI,IAAI,CAAChD,YAAY,EAAE;oBACrB,MAAMyB,WAAWpC,eAAeiB,KAAKgB,QAAQ/B,YAAY;oBACzD,IAAI,CAACqB,KAAK,CAACmB,MAAM,CAACN;gBACpB;gBACA,OAAO;YACT;YAEA,gEAAgE;YAChE,IAAIH,QAAQf,oBAAoB,IAAI,CAACsC,UAAU;gBAC7C,OAAOG;YACT;YAEA,OAAOA;QACT,EAAE,OAAOE,KAAK;YACZ,mEAAmE;YACnE,0DAA0D;YAC1D,IAAIL,UAAU;gBACZM,QAAQC,KAAK,CAACF;gBACd,OAAO;YACT;YAEA,MAAMA;QACR;IACF;IAEA;;;;;;;;;;;;;GAaC,GACD,MAAaD,WACX3C,GAAW,EACX2B,gBAA0C,EAC1CE,iBAA0B,EAC1BD,UAAmB,EACnBb,iBAAoC,EACpCuB,6BAAmE,EACnErB,WAAoB,EACpBc,SAAwC,EACxC9C,YAAqB,EACrB;QACA,OAAO,IAAI,CAACkB,iBAAiB,CAAC+B,KAAK,CAAClC,KAAK;YACvC,MAAMoC,UAAU,IAAI,CAACW,gBAAgB,CACnC/C,KACA2B,kBACAE,mBACAD,YACAb,mBACAuB,+BACArB,aACAhC;YAGF,oEAAoE;YACpE,IAAI8C,WAAWA,UAAUK;YAEzB,OAAOA;QACT;IACF;IAEA,MAAcW,iBACZ/C,GAAW,EACX2B,gBAA0C,EAC1CE,iBAA0B,EAC1BD,UAAmB,EACnBb,iBAAoC,EACpCuB,6BAAmE,EACnErB,WAAoB,EACpBhC,YAAgC,EAChC;QACA,IAAI;YACF,kEAAkE;YAClE,MAAM+D,qBAAqB,MAAMjC,kBAAkB;gBACjDE;gBACAC,oBAAoBoB;gBACpBW,gBAAgB;YAClB;YACA,IAAI,CAACD,oBAAoB;gBACvB,OAAO;YACT;YAEA,2EAA2E;YAC3E,MAAMN,gCAAgC,MAAM7E,gOAAAA,EAAuB;gBACjE,GAAGmF,kBAAkB;gBACrBE,QAAQ,CAACZ;YACX;YAEA,qEAAqE;YACrE,WAAW;YACX,IAAII,8BAA8BS,YAAY,EAAE;gBAC9C,IAAI,IAAI,CAACzD,YAAY,EAAE;oBACrB,qEAAqE;oBACrE,uEAAuE;oBACvE,sEAAsE;oBACtE,MAAMyB,WAAWpC,eAAeiB,KAAKf;oBACrC,IAAI,CAACqB,KAAK,CAAC8C,GAAG,CAACjC,UAAU;wBACvBE,OAAOqB;wBACPlB,WAAWD,KAAKD,GAAG,KAAK,IAAI,CAAC1B,GAAG;oBAClC;gBACF,OAAO;oBACL,MAAM+B,iBAAiByB,GAAG,CAACpD,KAAK0C,8BAA8B/B,KAAK,EAAE;wBACnEwC,cAAcT,8BAA8BS,YAAY;wBACxDtB;wBACAD;oBACF;gBACF;YACF;YAEA,OAAOc;QACT,EAAE,OAAOE,KAAK;YACZ,qEAAqE;YACrE,qEAAqE;YACrE,IAAIN,iCAAAA,OAAAA,KAAAA,IAAAA,8BAA+Ba,YAAY,EAAE;gBAC/C,MAAMR,aAAaU,KAAKC,GAAG,CACzBD,KAAKE,GAAG,CACNjB,8BAA8Ba,YAAY,CAACR,UAAU,IAAI,GACzD,IAEF;gBAEF,MAAMa,SACJlB,8BAA8Ba,YAAY,CAACK,MAAM,KAAKlE,YAClDA,YACA+D,KAAKE,GAAG,CACNZ,aAAa,GACbL,8BAA8Ba,YAAY,CAACK,MAAM;gBAGzD,MAAM7B,iBAAiByB,GAAG,CAACpD,KAAKsC,8BAA8B3B,KAAK,EAAE;oBACnEwC,cAAc;wBAAER,YAAYA;wBAAYa,QAAQA;oBAAO;oBACvD3B;oBACAD;gBACF;YACF;YAEA,gEAAgE;YAChE,MAAMgB;QACR;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2470, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/stream-utils/encoded-tags.ts"],"sourcesContent":["export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n  META: {\n    // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\n    // <meta name=\"nxt-icon\"\n    // This is a special mark that will be replaced by the icon insertion script tag.\n    ICON_MARK: new Uint8Array([\n      60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,\n      116, 45, 105, 99, 111, 110, 194, 187, 34,\n    ]),\n  },\n} as const\n"],"names":["ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML","META","ICON_MARK"],"mappings":";;;;AAAO,MAAMA,eAAe;IAC1B,iHAAiH;IACjHC,SAAS;QACP,QAAQ;QACRC,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAK;YAAK;YAAK;SAAI;QAC7C,QAAQ;QACRC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;SAAI;IAC9C;IACAE,QAAQ;QACN,UAAU;QACVC,MAAM,IAAIH,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAI;YAAK;SAAG;QACpD,UAAU;QACVC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;SAAG;QACpD,UAAU;QACVD,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAAG;QACrD,iBAAiB;QACjBI,eAAe,IAAIJ,WAAW;YAC5B;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAC5D;IACH;IACAK,MAAM;QACJ,4GAA4G;QAC5G,0BAA0B;QAC1B,iFAAiF;QACjFC,WAAW,IAAIN,WAAW;YACxB;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAK;YAAI;YAAK;YAAK;YAAI;YAAI;YAAK;YAAK;YAAK;YACrE;YAAK;YAAI;YAAK;YAAI;YAAK;YAAK;YAAK;YAAK;SACvC;IACH;AACF,EAAU","ignoreList":[0]}},
    {"offset": {"line": 2580, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/stream-utils/uint8array-helpers.ts"],"sourcesContent":["/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n"],"names":["indexOfUint8Array","a","b","length","i","completeMatch","j","isEquivalentUint8Arrays","removeFromUint8Array","tagIndex","subarray","removed","Uint8Array","set","slice"],"mappings":"AAAA;;CAEC,GACD;;;;;;;;AAAO,SAASA,kBAAkBC,CAAa,EAAEC,CAAa;IAC5D,IAAIA,EAAEC,MAAM,KAAK,GAAG,OAAO;IAC3B,IAAIF,EAAEE,MAAM,KAAK,KAAKD,EAAEC,MAAM,GAAGF,EAAEE,MAAM,EAAE,OAAO,CAAC;IAEnD,8BAA8B;IAC9B,IAAK,IAAIC,IAAI,GAAGA,KAAKH,EAAEE,MAAM,GAAGD,EAAEC,MAAM,EAAEC,IAAK;QAC7C,IAAIC,gBAAgB;QACpB,6DAA6D;QAC7D,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,EAAEC,MAAM,EAAEG,IAAK;YACjC,2HAA2H;YAC3H,IAAIL,CAAC,CAACG,IAAIE,EAAE,KAAKJ,CAAC,CAACI,EAAE,EAAE;gBACrBD,gBAAgB;gBAChB;YACF;QACF;QAEA,IAAIA,eAAe;YACjB,OAAOD;QACT;IACF;IAEA,OAAO,CAAC;AACV;AAKO,SAASG,wBAAwBN,CAAa,EAAEC,CAAa;IAClE,IAAID,EAAEE,MAAM,KAAKD,EAAEC,MAAM,EAAE,OAAO;IAElC,IAAK,IAAIC,IAAI,GAAGA,IAAIH,EAAEE,MAAM,EAAEC,IAAK;QACjC,IAAIH,CAAC,CAACG,EAAE,KAAKF,CAAC,CAACE,EAAE,EAAE,OAAO;IAC5B;IAEA,OAAO;AACT;AASO,SAASI,qBAAqBP,CAAa,EAAEC,CAAa;IAC/D,MAAMO,WAAWT,kBAAkBC,GAAGC;IACtC,IAAIO,aAAa,GAAG,OAAOR,EAAES,QAAQ,CAACR,EAAEC,MAAM;IAC9C,IAAIM,WAAW,CAAC,GAAG;QACjB,MAAME,UAAU,IAAIC,WAAWX,EAAEE,MAAM,GAAGD,EAAEC,MAAM;QAClDQ,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAAC,GAAGL;QACvBE,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAACL,WAAWP,EAAEC,MAAM,GAAGM;QAC1C,OAAOE;IACT,OAAO;QACL,OAAOV;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2633, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/stream-utils/node-web-streams-helper.ts"],"sourcesContent":["import type { ReactDOMServerReadableStream } from 'react-dom/server'\nimport { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport {\n  scheduleImmediate,\n  atLeastOneTask,\n  waitAtLeastOneReactRenderTask,\n} from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encoded-tags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from '../../client/components/app-router-headers'\nimport { computeCacheBustingSearchParam } from '../../shared/lib/router/utils/cache-busting-search-param'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // If we have no streams, return an empty stream. This behavior is\n  // intentional as we're now providing the `RenderResult.EMPTY` value.\n  if (streams.length === 0) {\n    return new ReadableStream<T>({\n      start(controller) {\n        controller.close()\n      },\n    })\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nasync function streamToChunks(\n  stream: ReadableStream<Uint8Array>\n): Promise<Array<Uint8Array>> {\n  const reader = stream.getReader()\n  const chunks: Array<Uint8Array> = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return chunks\n}\n\nfunction concatUint8Arrays(chunks: Array<Uint8Array>): Uint8Array {\n  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0)\n  const result = new Uint8Array(totalLength)\n  let offset = 0\n  for (const chunk of chunks) {\n    result.set(chunk, offset)\n    offset += chunk.length\n  }\n  return result\n}\n\nexport async function streamToUint8Array(\n  stream: ReadableStream<Uint8Array>\n): Promise<Uint8Array> {\n  return concatUint8Arrays(await streamToChunks(stream))\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  return Buffer.concat(await streamToChunks(stream))\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport type BufferedTransformOptions = {\n  /**\n   * Flush synchronously once the buffer reaches this many bytes.\n   */\n  readonly maxBufferByteLength?: number\n}\n\nexport function createBufferedTransformStream(\n  options: BufferedTransformOptions = {}\n): TransformStream<Uint8Array, Uint8Array> {\n  const { maxBufferByteLength = Infinity } = options\n\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    try {\n      if (bufferedChunks.length === 0) {\n        return\n      }\n\n      const chunk = new Uint8Array(bufferByteLength)\n      let copiedBytes = 0\n\n      for (let i = 0; i < bufferedChunks.length; i++) {\n        const bufferedChunk = bufferedChunks[i]\n        chunk.set(bufferedChunk, copiedBytes)\n        copiedBytes += bufferedChunk.byteLength\n      }\n      // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n      // and our bufferByteLength to prepare for the next round of buffered chunks\n      bufferedChunks.length = 0\n      bufferByteLength = 0\n      controller.enqueue(chunk)\n    } catch {\n      // If an error occurs while enqueuing, it can't be due to this\n      // transformer. It's most likely caused by the controller having been\n      // errored (for example, if the stream was cancelled).\n    }\n  }\n\n  const scheduleFlush = (controller: TransformStreamDefaultController) => {\n    if (pending) {\n      return\n    }\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        flush(controller)\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      if (bufferByteLength >= maxBufferByteLength) {\n        flush(controller)\n      } else {\n        scheduleFlush(controller)\n      }\n    },\n    flush() {\n      return pending?.promise\n    },\n  })\n}\n\nfunction createPrefetchCommentStream(\n  isBuildTimePrerendering: boolean,\n  buildId: string\n): TransformStream<Uint8Array, Uint8Array> {\n  // Insert an extra comment at the beginning of the HTML document. This must\n  // come after the DOCTYPE, which is inserted by React.\n  //\n  // The first chunk sent by React will contain the doctype. After that, we can\n  // pass through the rest of the chunks as-is.\n  let didTransformFirstChunk = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (isBuildTimePrerendering && !didTransformFirstChunk) {\n        didTransformFirstChunk = true\n        const decoder = new TextDecoder('utf-8', { fatal: true })\n        const chunkStr = decoder.decode(chunk, {\n          stream: true,\n        })\n        const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)\n        controller.enqueue(encoder.encode(updatedChunkStr))\n        return\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: {\n    renderToReadableStream: typeof import('react-dom/server').renderToReadableStream\n  }\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactDOMServerReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createMetadataTransformStream(\n  insert: () => Promise<string> | string\n): TransformStream<Uint8Array, Uint8Array> {\n  let chunkIndex = -1\n  let isMarkRemoved = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      let iconMarkIndex = -1\n      let closedHeadIndex = -1\n      chunkIndex++\n\n      if (isMarkRemoved) {\n        controller.enqueue(chunk)\n        return\n      }\n      let iconMarkLength = 0\n      // Only search for the closed head tag once\n      if (iconMarkIndex === -1) {\n        iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)\n        if (iconMarkIndex === -1) {\n          controller.enqueue(chunk)\n          return\n        } else {\n          // When we found the `<meta name=\"nxt-icon\"` tag prefix, we will remove it from the chunk.\n          // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\n          iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length\n          // Check if next char is /, this is for xml mode.\n          if (chunk[iconMarkIndex + iconMarkLength] === 47) {\n            iconMarkLength += 2\n          } else {\n            // The last char is `>`\n            iconMarkLength++\n          }\n        }\n      }\n\n      // Check if icon mark is inside <head> tag in the first chunk.\n      if (chunkIndex === 0) {\n        closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (iconMarkIndex !== -1) {\n          // The mark icon is located in the 1st chunk before the head tag.\n          // We do not need to insert the script tag in this case because it's in the head.\n          // Just remove the icon mark from the chunk.\n          if (iconMarkIndex < closedHeadIndex) {\n            const replaced = new Uint8Array(chunk.length - iconMarkLength)\n\n            // Remove the icon mark from the chunk.\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex\n            )\n            chunk = replaced\n          } else {\n            // The icon mark is after the head tag, replace and insert the script tag at that position.\n            const insertion = await insert()\n            const encodedInsertion = encoder.encode(insertion)\n            const insertionLength = encodedInsertion.length\n            const replaced = new Uint8Array(\n              chunk.length - iconMarkLength + insertionLength\n            )\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(encodedInsertion, iconMarkIndex)\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex + insertionLength\n            )\n            chunk = replaced\n          }\n          isMarkRemoved = true\n        }\n        // If there's no icon mark located, it will be handled later when if present in the following chunks.\n      } else {\n        // When it's appeared in the following chunks, we'll need to\n        // remove the mark and then insert the script tag at that position.\n        const insertion = await insert()\n        const encodedInsertion = encoder.encode(insertion)\n        const insertionLength = encodedInsertion.length\n        // Replace the icon mark with the hoist script or empty string.\n        const replaced = new Uint8Array(\n          chunk.length - iconMarkLength + insertionLength\n        )\n        // Set the first part of the chunk, before the icon mark.\n        replaced.set(chunk.subarray(0, iconMarkIndex))\n        // Set the insertion after the icon mark.\n        replaced.set(encodedInsertion, iconMarkIndex)\n\n        // Set the rest of the chunk after the icon mark.\n        replaced.set(\n          chunk.subarray(iconMarkIndex + iconMarkLength),\n          iconMarkIndex + insertionLength\n        )\n        chunk = replaced\n        isMarkRemoved = true\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\nfunction createClientResumeScriptInsertionTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  const segmentPath = '/_full'\n  const cacheBustingHeader = computeCacheBustingSearchParam(\n    '1', //            headers[NEXT_ROUTER_PREFETCH_HEADER]\n    '/_full', //       headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]\n    undefined, //      headers[NEXT_ROUTER_STATE_TREE_HEADER]\n    undefined //       headers[NEXT_URL]\n  )\n  const searchStr = `${NEXT_RSC_UNION_QUERY}=${cacheBustingHeader}`\n  const NEXT_CLIENT_RESUME_SCRIPT = `<script>__NEXT_CLIENT_RESUME=fetch(location.pathname+'?${searchStr}',{credentials:'same-origin',headers:{'${RSC_HEADER}': '1','${NEXT_ROUTER_PREFETCH_HEADER}': '1','${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}': '${segmentPath}'}})</script>`\n\n  let didAlreadyInsert = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (didAlreadyInsert) {\n        // Already inserted the script into the head. Pass through.\n        controller.enqueue(chunk)\n        return\n      }\n      // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n      const headClosingTagIndex = indexOfUint8Array(\n        chunk,\n        ENCODED_TAGS.CLOSED.HEAD\n      )\n\n      if (headClosingTagIndex === -1) {\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        controller.enqueue(chunk)\n        return\n      }\n\n      const encodedInsertion = encoder.encode(NEXT_CLIENT_RESUME_SCRIPT)\n      // Get the total count of the bytes in the chunk and the insertion\n      // e.g.\n      // chunk = <head><meta charset=\"utf-8\"></head>\n      // insertion = <script>...</script>\n      // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n      const insertedHeadContent = new Uint8Array(\n        chunk.length + encodedInsertion.length\n      )\n      // Append the first part of the chunk, before the head tag\n      insertedHeadContent.set(chunk.slice(0, headClosingTagIndex))\n      // Append the server inserted content\n      insertedHeadContent.set(encodedInsertion, headClosingTagIndex)\n      // Append the rest of the chunk\n      insertedHeadContent.set(\n        chunk.slice(headClosingTagIndex),\n        headClosingTagIndex + encodedInsertion.length\n      )\n\n      controller.enqueue(insertedHeadContent)\n      didAlreadyInsert = true\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\nfunction createFlightDataInjectionTransformStream(\n  stream: ReadableStream<Uint8Array>,\n  delayDataUntilFirstHtmlChunk: boolean\n): TransformStream<Uint8Array, Uint8Array> {\n  let htmlStreamFinished = false\n\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  function startOrContinuePulling(\n    controller: TransformStreamDefaultController\n  ) {\n    if (!pull) {\n      pull = startPulling(controller)\n    }\n    return pull\n  }\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    const reader = stream.getReader()\n\n    if (delayDataUntilFirstHtmlChunk) {\n      // NOTE: streaming flush\n      // We are buffering here for the inlined data stream because the\n      // \"shell\" stream might be chunkenized again by the underlying stream\n      // implementation, e.g. with a specific high-water mark. To ensure it's\n      // the safe timing to pipe the data stream, this extra tick is\n      // necessary.\n\n      // We don't start reading until we've left the current Task to ensure\n      // that it's inserted after flushing the shell. Note that this implementation\n      // might get stale if impl details of Fizz change in the future.\n      await atLeastOneTask()\n    }\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        // We want to prioritize HTML over RSC data.\n        // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n        // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n        if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n          await atLeastOneTask()\n        }\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    start(controller) {\n      if (!delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    flush(controller) {\n      htmlStreamFinished = true\n      if (donePulling) {\n        return\n      }\n      return startOrContinuePulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: ('html' | 'body')[] = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<html id=\"__next_error__\">\n            <template\n              data-next-error-message=\"Missing ${missingTags\n                .map((c) => `<${c}>`)\n                .join(\n                  missingTags.length > 1 ? ' and ' : ''\n                )} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\n              data-next-error-stack=\"\"\n            ></template>\n          `\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  isBuildTimePrerendering: boolean\n  buildId: string\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactDOMServerReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    isBuildTimePrerendering,\n    buildId,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  if (isStaticGeneration) {\n    // If we're generating static HTML we need to wait for it to resolve before continuing.\n    await renderStream.allReady\n  } else {\n    // Otherwise, we want to make sure Fizz is done with all microtasky work\n    // before we start pulling the stream and cause a flush.\n    await waitAtLeastOneReactRenderTask()\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Add build id comment to start of the HTML document (in export mode)\n    createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n\n    // Transform metadata\n    createMetadataTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream\n      ? createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  isBuildTimePrerendering: boolean\n  buildId: string\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport async function continueStaticFallbackPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  // Same as `continueStaticPrerender`, but also inserts an additional script\n  // to instruct the client to start fetching the hydration data as early\n  // as possible.\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the client resume script into the head\n      .pipeThrough(createClientResumeScriptInsertionTransformStream())\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  delayDataUntilFirstHtmlChunk: boolean\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    delayDataUntilFirstHtmlChunk,\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(\n          inlinedDataStream,\n          delayDataUntilFirstHtmlChunk\n        )\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n"],"names":["getTracer","AppRenderSpan","DetachedPromise","scheduleImmediate","atLeastOneTask","waitAtLeastOneReactRenderTask","ENCODED_TAGS","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","MISSING_ROOT_TAGS_ERROR","insertBuildIdComment","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_RSC_UNION_QUERY","computeCacheBustingSearchParam","voidCatch","encoder","TextEncoder","chainStreams","streams","length","ReadableStream","start","controller","close","readable","writable","TransformStream","promise","pipeTo","preventClose","i","nextStream","then","lastStream","catch","streamFromString","str","enqueue","encode","streamFromBuffer","chunk","streamToChunks","stream","reader","getReader","chunks","done","value","read","push","concatUint8Arrays","totalLength","reduce","sum","result","Uint8Array","offset","set","streamToUint8Array","streamToBuffer","Buffer","concat","streamToString","signal","decoder","TextDecoder","fatal","string","aborted","decode","createBufferedTransformStream","options","maxBufferByteLength","Infinity","bufferedChunks","bufferByteLength","pending","flush","copiedBytes","bufferedChunk","byteLength","scheduleFlush","detached","undefined","resolve","transform","createPrefetchCommentStream","isBuildTimePrerendering","buildId","didTransformFirstChunk","chunkStr","updatedChunkStr","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","trace","renderToReadableStream","createMetadataTransformStream","insert","chunkIndex","isMarkRemoved","iconMarkIndex","closedHeadIndex","iconMarkLength","META","ICON_MARK","CLOSED","HEAD","replaced","subarray","insertion","encodedInsertion","insertionLength","createHeadInsertionTransformStream","inserted","hasBytes","index","insertedHeadContent","slice","createClientResumeScriptInsertionTransformStream","segmentPath","cacheBustingHeader","searchStr","NEXT_CLIENT_RESUME_SCRIPT","didAlreadyInsert","headClosingTagIndex","createDeferredSuffixStream","suffix","flushed","createFlightDataInjectionTransformStream","delayDataUntilFirstHtmlChunk","htmlStreamFinished","pull","donePulling","startOrContinuePulling","startPulling","err","error","CLOSE_TAG","createMoveSuffixStream","foundSuffix","BODY_AND_HTML","before","after","createStripDocumentClosingTagsTransform","BODY","HTML","createRootLayoutValidatorStream","foundHtml","foundBody","OPENING","missingTags","map","c","join","chainTransformers","transformers","transformer","pipeThrough","continueFizzStream","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","split","allReady","continueDynamicPrerender","prerenderStream","continueStaticPrerender","continueStaticFallbackPrerender","continueDynamicHTMLResume","createDocumentClosingStream"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3341, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/stream-utils/encoded-tags.ts"],"sourcesContent":["export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n  META: {\n    // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\n    // <meta name=\"nxt-icon\"\n    // This is a special mark that will be replaced by the icon insertion script tag.\n    ICON_MARK: new Uint8Array([\n      60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,\n      116, 45, 105, 99, 111, 110, 194, 187, 34,\n    ]),\n  },\n} as const\n"],"names":["ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML","META","ICON_MARK"],"mappings":";;;;AAAO,MAAMA,eAAe;IAC1B,iHAAiH;IACjHC,SAAS;QACP,QAAQ;QACRC,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAK;YAAK;YAAK;SAAI;QAC7C,QAAQ;QACRC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;SAAI;IAC9C;IACAE,QAAQ;QACN,UAAU;QACVC,MAAM,IAAIH,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAI;YAAK;SAAG;QACpD,UAAU;QACVC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;SAAG;QACpD,UAAU;QACVD,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAAG;QACrD,iBAAiB;QACjBI,eAAe,IAAIJ,WAAW;YAC5B;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAC5D;IACH;IACAK,MAAM;QACJ,4GAA4G;QAC5G,0BAA0B;QAC1B,iFAAiF;QACjFC,WAAW,IAAIN,WAAW;YACxB;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAK;YAAI;YAAK;YAAK;YAAI;YAAI;YAAK;YAAK;YAAK;YACrE;YAAK;YAAI;YAAK;YAAI;YAAK;YAAK;YAAK;YAAK;SACvC;IACH;AACF,EAAU","ignoreList":[0]}},
    {"offset": {"line": 3451, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/stream-utils/uint8array-helpers.ts"],"sourcesContent":["/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n"],"names":["indexOfUint8Array","a","b","length","i","completeMatch","j","isEquivalentUint8Arrays","removeFromUint8Array","tagIndex","subarray","removed","Uint8Array","set","slice"],"mappings":"AAAA;;CAEC,GACD;;;;;;;;AAAO,SAASA,kBAAkBC,CAAa,EAAEC,CAAa;IAC5D,IAAIA,EAAEC,MAAM,KAAK,GAAG,OAAO;IAC3B,IAAIF,EAAEE,MAAM,KAAK,KAAKD,EAAEC,MAAM,GAAGF,EAAEE,MAAM,EAAE,OAAO,CAAC;IAEnD,8BAA8B;IAC9B,IAAK,IAAIC,IAAI,GAAGA,KAAKH,EAAEE,MAAM,GAAGD,EAAEC,MAAM,EAAEC,IAAK;QAC7C,IAAIC,gBAAgB;QACpB,6DAA6D;QAC7D,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,EAAEC,MAAM,EAAEG,IAAK;YACjC,2HAA2H;YAC3H,IAAIL,CAAC,CAACG,IAAIE,EAAE,KAAKJ,CAAC,CAACI,EAAE,EAAE;gBACrBD,gBAAgB;gBAChB;YACF;QACF;QAEA,IAAIA,eAAe;YACjB,OAAOD;QACT;IACF;IAEA,OAAO,CAAC;AACV;AAKO,SAASG,wBAAwBN,CAAa,EAAEC,CAAa;IAClE,IAAID,EAAEE,MAAM,KAAKD,EAAEC,MAAM,EAAE,OAAO;IAElC,IAAK,IAAIC,IAAI,GAAGA,IAAIH,EAAEE,MAAM,EAAEC,IAAK;QACjC,IAAIH,CAAC,CAACG,EAAE,KAAKF,CAAC,CAACE,EAAE,EAAE,OAAO;IAC5B;IAEA,OAAO;AACT;AASO,SAASI,qBAAqBP,CAAa,EAAEC,CAAa;IAC/D,MAAMO,WAAWT,kBAAkBC,GAAGC;IACtC,IAAIO,aAAa,GAAG,OAAOR,EAAES,QAAQ,CAACR,EAAEC,MAAM;IAC9C,IAAIM,WAAW,CAAC,GAAG;QACjB,MAAME,UAAU,IAAIC,WAAWX,EAAEE,MAAM,GAAGD,EAAEC,MAAM;QAClDQ,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAAC,GAAGL;QACvBE,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAACL,WAAWP,EAAEC,MAAM,GAAGM;QAC1C,OAAOE;IACT,OAAO;QACL,OAAOV;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 3504, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/stream-utils/node-web-streams-helper.ts"],"sourcesContent":["import type { ReactDOMServerReadableStream } from 'react-dom/server'\nimport { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport {\n  scheduleImmediate,\n  atLeastOneTask,\n  waitAtLeastOneReactRenderTask,\n} from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encoded-tags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from '../../client/components/app-router-headers'\nimport { computeCacheBustingSearchParam } from '../../shared/lib/router/utils/cache-busting-search-param'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // If we have no streams, return an empty stream. This behavior is\n  // intentional as we're now providing the `RenderResult.EMPTY` value.\n  if (streams.length === 0) {\n    return new ReadableStream<T>({\n      start(controller) {\n        controller.close()\n      },\n    })\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nasync function streamToChunks(\n  stream: ReadableStream<Uint8Array>\n): Promise<Array<Uint8Array>> {\n  const reader = stream.getReader()\n  const chunks: Array<Uint8Array> = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return chunks\n}\n\nfunction concatUint8Arrays(chunks: Array<Uint8Array>): Uint8Array {\n  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0)\n  const result = new Uint8Array(totalLength)\n  let offset = 0\n  for (const chunk of chunks) {\n    result.set(chunk, offset)\n    offset += chunk.length\n  }\n  return result\n}\n\nexport async function streamToUint8Array(\n  stream: ReadableStream<Uint8Array>\n): Promise<Uint8Array> {\n  return concatUint8Arrays(await streamToChunks(stream))\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  return Buffer.concat(await streamToChunks(stream))\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport type BufferedTransformOptions = {\n  /**\n   * Flush synchronously once the buffer reaches this many bytes.\n   */\n  readonly maxBufferByteLength?: number\n}\n\nexport function createBufferedTransformStream(\n  options: BufferedTransformOptions = {}\n): TransformStream<Uint8Array, Uint8Array> {\n  const { maxBufferByteLength = Infinity } = options\n\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    try {\n      if (bufferedChunks.length === 0) {\n        return\n      }\n\n      const chunk = new Uint8Array(bufferByteLength)\n      let copiedBytes = 0\n\n      for (let i = 0; i < bufferedChunks.length; i++) {\n        const bufferedChunk = bufferedChunks[i]\n        chunk.set(bufferedChunk, copiedBytes)\n        copiedBytes += bufferedChunk.byteLength\n      }\n      // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n      // and our bufferByteLength to prepare for the next round of buffered chunks\n      bufferedChunks.length = 0\n      bufferByteLength = 0\n      controller.enqueue(chunk)\n    } catch {\n      // If an error occurs while enqueuing, it can't be due to this\n      // transformer. It's most likely caused by the controller having been\n      // errored (for example, if the stream was cancelled).\n    }\n  }\n\n  const scheduleFlush = (controller: TransformStreamDefaultController) => {\n    if (pending) {\n      return\n    }\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        flush(controller)\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      if (bufferByteLength >= maxBufferByteLength) {\n        flush(controller)\n      } else {\n        scheduleFlush(controller)\n      }\n    },\n    flush() {\n      return pending?.promise\n    },\n  })\n}\n\nfunction createPrefetchCommentStream(\n  isBuildTimePrerendering: boolean,\n  buildId: string\n): TransformStream<Uint8Array, Uint8Array> {\n  // Insert an extra comment at the beginning of the HTML document. This must\n  // come after the DOCTYPE, which is inserted by React.\n  //\n  // The first chunk sent by React will contain the doctype. After that, we can\n  // pass through the rest of the chunks as-is.\n  let didTransformFirstChunk = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (isBuildTimePrerendering && !didTransformFirstChunk) {\n        didTransformFirstChunk = true\n        const decoder = new TextDecoder('utf-8', { fatal: true })\n        const chunkStr = decoder.decode(chunk, {\n          stream: true,\n        })\n        const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)\n        controller.enqueue(encoder.encode(updatedChunkStr))\n        return\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: {\n    renderToReadableStream: typeof import('react-dom/server').renderToReadableStream\n  }\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactDOMServerReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createMetadataTransformStream(\n  insert: () => Promise<string> | string\n): TransformStream<Uint8Array, Uint8Array> {\n  let chunkIndex = -1\n  let isMarkRemoved = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      let iconMarkIndex = -1\n      let closedHeadIndex = -1\n      chunkIndex++\n\n      if (isMarkRemoved) {\n        controller.enqueue(chunk)\n        return\n      }\n      let iconMarkLength = 0\n      // Only search for the closed head tag once\n      if (iconMarkIndex === -1) {\n        iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)\n        if (iconMarkIndex === -1) {\n          controller.enqueue(chunk)\n          return\n        } else {\n          // When we found the `<meta name=\"nxt-icon\"` tag prefix, we will remove it from the chunk.\n          // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\n          iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length\n          // Check if next char is /, this is for xml mode.\n          if (chunk[iconMarkIndex + iconMarkLength] === 47) {\n            iconMarkLength += 2\n          } else {\n            // The last char is `>`\n            iconMarkLength++\n          }\n        }\n      }\n\n      // Check if icon mark is inside <head> tag in the first chunk.\n      if (chunkIndex === 0) {\n        closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (iconMarkIndex !== -1) {\n          // The mark icon is located in the 1st chunk before the head tag.\n          // We do not need to insert the script tag in this case because it's in the head.\n          // Just remove the icon mark from the chunk.\n          if (iconMarkIndex < closedHeadIndex) {\n            const replaced = new Uint8Array(chunk.length - iconMarkLength)\n\n            // Remove the icon mark from the chunk.\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex\n            )\n            chunk = replaced\n          } else {\n            // The icon mark is after the head tag, replace and insert the script tag at that position.\n            const insertion = await insert()\n            const encodedInsertion = encoder.encode(insertion)\n            const insertionLength = encodedInsertion.length\n            const replaced = new Uint8Array(\n              chunk.length - iconMarkLength + insertionLength\n            )\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(encodedInsertion, iconMarkIndex)\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex + insertionLength\n            )\n            chunk = replaced\n          }\n          isMarkRemoved = true\n        }\n        // If there's no icon mark located, it will be handled later when if present in the following chunks.\n      } else {\n        // When it's appeared in the following chunks, we'll need to\n        // remove the mark and then insert the script tag at that position.\n        const insertion = await insert()\n        const encodedInsertion = encoder.encode(insertion)\n        const insertionLength = encodedInsertion.length\n        // Replace the icon mark with the hoist script or empty string.\n        const replaced = new Uint8Array(\n          chunk.length - iconMarkLength + insertionLength\n        )\n        // Set the first part of the chunk, before the icon mark.\n        replaced.set(chunk.subarray(0, iconMarkIndex))\n        // Set the insertion after the icon mark.\n        replaced.set(encodedInsertion, iconMarkIndex)\n\n        // Set the rest of the chunk after the icon mark.\n        replaced.set(\n          chunk.subarray(iconMarkIndex + iconMarkLength),\n          iconMarkIndex + insertionLength\n        )\n        chunk = replaced\n        isMarkRemoved = true\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\nfunction createClientResumeScriptInsertionTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  const segmentPath = '/_full'\n  const cacheBustingHeader = computeCacheBustingSearchParam(\n    '1', //            headers[NEXT_ROUTER_PREFETCH_HEADER]\n    '/_full', //       headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]\n    undefined, //      headers[NEXT_ROUTER_STATE_TREE_HEADER]\n    undefined //       headers[NEXT_URL]\n  )\n  const searchStr = `${NEXT_RSC_UNION_QUERY}=${cacheBustingHeader}`\n  const NEXT_CLIENT_RESUME_SCRIPT = `<script>__NEXT_CLIENT_RESUME=fetch(location.pathname+'?${searchStr}',{credentials:'same-origin',headers:{'${RSC_HEADER}': '1','${NEXT_ROUTER_PREFETCH_HEADER}': '1','${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}': '${segmentPath}'}})</script>`\n\n  let didAlreadyInsert = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (didAlreadyInsert) {\n        // Already inserted the script into the head. Pass through.\n        controller.enqueue(chunk)\n        return\n      }\n      // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n      const headClosingTagIndex = indexOfUint8Array(\n        chunk,\n        ENCODED_TAGS.CLOSED.HEAD\n      )\n\n      if (headClosingTagIndex === -1) {\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        controller.enqueue(chunk)\n        return\n      }\n\n      const encodedInsertion = encoder.encode(NEXT_CLIENT_RESUME_SCRIPT)\n      // Get the total count of the bytes in the chunk and the insertion\n      // e.g.\n      // chunk = <head><meta charset=\"utf-8\"></head>\n      // insertion = <script>...</script>\n      // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n      const insertedHeadContent = new Uint8Array(\n        chunk.length + encodedInsertion.length\n      )\n      // Append the first part of the chunk, before the head tag\n      insertedHeadContent.set(chunk.slice(0, headClosingTagIndex))\n      // Append the server inserted content\n      insertedHeadContent.set(encodedInsertion, headClosingTagIndex)\n      // Append the rest of the chunk\n      insertedHeadContent.set(\n        chunk.slice(headClosingTagIndex),\n        headClosingTagIndex + encodedInsertion.length\n      )\n\n      controller.enqueue(insertedHeadContent)\n      didAlreadyInsert = true\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\nfunction createFlightDataInjectionTransformStream(\n  stream: ReadableStream<Uint8Array>,\n  delayDataUntilFirstHtmlChunk: boolean\n): TransformStream<Uint8Array, Uint8Array> {\n  let htmlStreamFinished = false\n\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  function startOrContinuePulling(\n    controller: TransformStreamDefaultController\n  ) {\n    if (!pull) {\n      pull = startPulling(controller)\n    }\n    return pull\n  }\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    const reader = stream.getReader()\n\n    if (delayDataUntilFirstHtmlChunk) {\n      // NOTE: streaming flush\n      // We are buffering here for the inlined data stream because the\n      // \"shell\" stream might be chunkenized again by the underlying stream\n      // implementation, e.g. with a specific high-water mark. To ensure it's\n      // the safe timing to pipe the data stream, this extra tick is\n      // necessary.\n\n      // We don't start reading until we've left the current Task to ensure\n      // that it's inserted after flushing the shell. Note that this implementation\n      // might get stale if impl details of Fizz change in the future.\n      await atLeastOneTask()\n    }\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        // We want to prioritize HTML over RSC data.\n        // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n        // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n        if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n          await atLeastOneTask()\n        }\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    start(controller) {\n      if (!delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    flush(controller) {\n      htmlStreamFinished = true\n      if (donePulling) {\n        return\n      }\n      return startOrContinuePulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: ('html' | 'body')[] = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<html id=\"__next_error__\">\n            <template\n              data-next-error-message=\"Missing ${missingTags\n                .map((c) => `<${c}>`)\n                .join(\n                  missingTags.length > 1 ? ' and ' : ''\n                )} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\n              data-next-error-stack=\"\"\n            ></template>\n          `\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  isBuildTimePrerendering: boolean\n  buildId: string\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactDOMServerReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    isBuildTimePrerendering,\n    buildId,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  if (isStaticGeneration) {\n    // If we're generating static HTML we need to wait for it to resolve before continuing.\n    await renderStream.allReady\n  } else {\n    // Otherwise, we want to make sure Fizz is done with all microtasky work\n    // before we start pulling the stream and cause a flush.\n    await waitAtLeastOneReactRenderTask()\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Add build id comment to start of the HTML document (in export mode)\n    createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n\n    // Transform metadata\n    createMetadataTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream\n      ? createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  isBuildTimePrerendering: boolean\n  buildId: string\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport async function continueStaticFallbackPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  // Same as `continueStaticPrerender`, but also inserts an additional script\n  // to instruct the client to start fetching the hydration data as early\n  // as possible.\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the client resume script into the head\n      .pipeThrough(createClientResumeScriptInsertionTransformStream())\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  delayDataUntilFirstHtmlChunk: boolean\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    delayDataUntilFirstHtmlChunk,\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(\n          inlinedDataStream,\n          delayDataUntilFirstHtmlChunk\n        )\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n"],"names":["getTracer","AppRenderSpan","DetachedPromise","scheduleImmediate","atLeastOneTask","waitAtLeastOneReactRenderTask","ENCODED_TAGS","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","MISSING_ROOT_TAGS_ERROR","insertBuildIdComment","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_RSC_UNION_QUERY","computeCacheBustingSearchParam","voidCatch","encoder","TextEncoder","chainStreams","streams","length","ReadableStream","start","controller","close","readable","writable","TransformStream","promise","pipeTo","preventClose","i","nextStream","then","lastStream","catch","streamFromString","str","enqueue","encode","streamFromBuffer","chunk","streamToChunks","stream","reader","getReader","chunks","done","value","read","push","concatUint8Arrays","totalLength","reduce","sum","result","Uint8Array","offset","set","streamToUint8Array","streamToBuffer","Buffer","concat","streamToString","signal","decoder","TextDecoder","fatal","string","aborted","decode","createBufferedTransformStream","options","maxBufferByteLength","Infinity","bufferedChunks","bufferByteLength","pending","flush","copiedBytes","bufferedChunk","byteLength","scheduleFlush","detached","undefined","resolve","transform","createPrefetchCommentStream","isBuildTimePrerendering","buildId","didTransformFirstChunk","chunkStr","updatedChunkStr","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","trace","renderToReadableStream","createMetadataTransformStream","insert","chunkIndex","isMarkRemoved","iconMarkIndex","closedHeadIndex","iconMarkLength","META","ICON_MARK","CLOSED","HEAD","replaced","subarray","insertion","encodedInsertion","insertionLength","createHeadInsertionTransformStream","inserted","hasBytes","index","insertedHeadContent","slice","createClientResumeScriptInsertionTransformStream","segmentPath","cacheBustingHeader","searchStr","NEXT_CLIENT_RESUME_SCRIPT","didAlreadyInsert","headClosingTagIndex","createDeferredSuffixStream","suffix","flushed","createFlightDataInjectionTransformStream","delayDataUntilFirstHtmlChunk","htmlStreamFinished","pull","donePulling","startOrContinuePulling","startPulling","err","error","CLOSE_TAG","createMoveSuffixStream","foundSuffix","BODY_AND_HTML","before","after","createStripDocumentClosingTagsTransform","BODY","HTML","createRootLayoutValidatorStream","foundHtml","foundBody","OPENING","missingTags","map","c","join","chainTransformers","transformers","transformer","pipeThrough","continueFizzStream","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","split","allReady","continueDynamicPrerender","prerenderStream","continueStaticPrerender","continueStaticFallbackPrerender","continueDynamicHTMLResume","createDocumentClosingStream"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4212, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/request-meta.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { BaseNextRequest } from './base-http'\nimport type { CloneableBody } from './body-streams'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport type {\n  ResponseCacheEntry,\n  ServerComponentsHmrCache,\n} from './response-cache'\nimport type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'\nimport type { OpaqueFallbackRouteParams } from './request/fallback-params'\nimport type { IncrementalCache } from './lib/incremental-cache'\n\n// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n  [NEXT_REQUEST_META]?: RequestMeta\n}\n\n/**\n * The callback function to call when a response cache entry was generated or\n * looked up in the cache. When it returns true, the server assumes that the\n * handler has already responded to the request and will not do so itself.\n */\nexport type OnCacheEntryHandler = (\n  /**\n   * The response cache entry that was generated or looked up in the cache.\n   */\n  cacheEntry: ResponseCacheEntry,\n\n  /**\n   * The request metadata.\n   */\n  requestMeta: {\n    /**\n     * The URL that was used to make the request.\n     */\n    url: string | undefined\n  }\n) => Promise<boolean | void> | boolean | void\n\nexport interface RequestMeta {\n  /**\n   * The query that was used to make the request.\n   */\n  initQuery?: ParsedUrlQuery\n\n  /**\n   * The URL that was used to make the request.\n   */\n  initURL?: string\n\n  /**\n   * The protocol that was used to make the request.\n   */\n  initProtocol?: string\n\n  /**\n   * The body that was read from the request. This is used to allow the body to\n   * be read multiple times.\n   */\n  clonableBody?: CloneableBody\n\n  /**\n   * True when the request matched a locale domain that was configured in the\n   * next.config.js file.\n   */\n  isLocaleDomain?: boolean\n\n  /**\n   * True when the request had locale information stripped from the pathname\n   * part of the URL.\n   */\n  didStripLocale?: boolean\n\n  /**\n   * If the request had it's URL rewritten, this is the URL it was rewritten to.\n   */\n  rewroteURL?: string\n\n  /**\n   * The cookies that were added by middleware and were added to the response.\n   */\n  middlewareCookie?: string[]\n\n  /**\n   * The match on the request for a given route.\n   */\n  match?: RouteMatch\n\n  /**\n   * The incremental cache to use for the request.\n   */\n  incrementalCache?: IncrementalCache\n\n  /**\n   * The server components HMR cache, only for dev.\n   */\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  /**\n   * Equals the segment path that was used for the prefetch RSC request.\n   */\n  segmentPrefetchRSCRequest?: string\n\n  /**\n   * True when the request is for the prefetch flight data.\n   */\n  isPrefetchRSCRequest?: true\n\n  /**\n   * True when the request is for the flight data.\n   */\n  isRSCRequest?: true\n\n  /**\n   * A search param set by the Next.js client when performing RSC requests.\n   * Because some CDNs do not vary their cache entries on our custom headers,\n   * this search param represents a hash of the header values. For any cached\n   * RSC request, we should verify that the hash matches before responding.\n   * Otherwise this can lead to cache poisoning.\n   * TODO: Consider not using custom request headers at all, and instead encode\n   * everything into the search param.\n   */\n  cacheBustingSearchParam?: string\n\n  /**\n   * True when the request is for the `/_next/data` route using the pages\n   * router.\n   */\n  isNextDataReq?: true\n\n  /**\n   * Postponed state to use for resumption. If present it's assumed that the\n   * request is for a page that has postponed (there are no guarantees that the\n   * page actually has postponed though as it would incur an additional cache\n   * lookup).\n   */\n  postponed?: string\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   *\n   * @deprecated Use `onCacheEntryV2` instead.\n   */\n  onCacheEntry?: OnCacheEntryHandler\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   */\n  onCacheEntryV2?: OnCacheEntryHandler\n\n  /**\n   * The previous revalidate before rendering 404 page for notFound: true\n   */\n  notFoundRevalidate?: number | false\n\n  /**\n   * In development, the original source page that returned a 404.\n   */\n  developmentNotFoundSourcePage?: string\n\n  /**\n   * The path we routed to and should be invoked\n   */\n  invokePath?: string\n\n  /**\n   * The specific page output we should be matching\n   */\n  invokeOutput?: string\n\n  /**\n   * The status we are invoking the request with from routing\n   */\n  invokeStatus?: number\n\n  /**\n   * The routing error we are invoking with\n   */\n  invokeError?: Error\n\n  /**\n   * The query parsed for the invocation\n   */\n  invokeQuery?: Record<string, undefined | string | string[]>\n\n  /**\n   * Whether the request is a middleware invocation\n   */\n  middlewareInvoke?: boolean\n\n  /**\n   * Whether the request should render the fallback shell or not.\n   */\n  renderFallbackShell?: boolean\n\n  /**\n   * Whether the request is for the custom error page.\n   */\n  customErrorRender?: true\n\n  /**\n   * Whether to bubble up the NoFallbackError to the caller when a 404 is\n   * returned.\n   */\n  bubbleNoFallback?: true\n\n  /**\n   * True when the request had locale information inferred from the default\n   * locale.\n   */\n  localeInferredFromDefault?: true\n\n  /**\n   * The locale that was inferred or explicitly set for the request.\n   */\n  locale?: string\n\n  /**\n   * The default locale that was inferred or explicitly set for the request.\n   */\n  defaultLocale?: string\n\n  /**\n   * The relative project dir the server is running in from project root\n   */\n  relativeProjectDir?: string\n\n  /**\n   * The dist directory the server is currently using\n   */\n  distDir?: string\n\n  /**\n   * The query after resolving routes\n   */\n  query?: ParsedUrlQuery\n\n  /**\n   * The params after resolving routes\n   */\n  params?: ParsedUrlQuery\n\n  /**\n   * ErrorOverlay component to use in development for pages router\n   */\n  PagesErrorDebug?: PagesDevOverlayBridgeType\n\n  /**\n   * Whether server is in minimal mode (this will be replaced with more\n   * specific flags in future)\n   */\n  minimalMode?: boolean\n\n  /**\n   * DEV only: The fallback params that should be used when validating prerenders during dev\n   */\n  devFallbackParams?: OpaqueFallbackRouteParams\n\n  /**\n   * DEV only: Request timings in process.hrtime.bigint()\n   */\n  devRequestTimingStart?: bigint\n  devRequestTimingMiddlewareStart?: bigint\n  devRequestTimingMiddlewareEnd?: bigint\n  devRequestTimingInternalsEnd?: bigint\n\n  /**\n   * DEV only: The duration of getStaticPaths/generateStaticParams in process.hrtime.bigint()\n   */\n  devGenerateStaticParamsDuration?: bigint\n}\n\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport function getRequestMeta(\n  req: NextIncomingMessage,\n  key?: undefined\n): RequestMeta\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key: K\n): RequestMeta[K]\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key?: K\n): RequestMeta | RequestMeta[K] {\n  const meta = req[NEXT_REQUEST_META] || {}\n  return typeof key === 'string' ? meta[key] : meta\n}\n\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {\n  req[NEXT_REQUEST_META] = meta\n  return meta\n}\n\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport function addRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K,\n  value: RequestMeta[K]\n) {\n  const meta = getRequestMeta(request)\n  meta[key] = value\n  return setRequestMeta(request, meta)\n}\n\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport function removeRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K\n) {\n  const meta = getRequestMeta(request)\n  delete meta[key]\n  return setRequestMeta(request, meta)\n}\n\ntype NextQueryMetadata = {\n  /**\n   * The `_rsc` query parameter used for cache busting to ensure that the RSC\n   * requests do not get cached by the browser explicitly.\n   */\n  [NEXT_RSC_UNION_QUERY]?: string\n}\n\nexport type NextParsedUrlQuery = ParsedUrlQuery & NextQueryMetadata\n\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n  query: NextParsedUrlQuery\n}\n"],"names":["NEXT_REQUEST_META","Symbol","for","getRequestMeta","req","key","meta","setRequestMeta","addRequestMeta","request","value","removeRequestMeta"],"mappings":"AAeA,kGAAkG;;;;;;;;;;;;;AAC3F,MAAMA,oBAAoBC,OAAOC,GAAG,CAAC,2BAA0B;AAuR/D,SAASC,eACdC,GAAwB,EACxBC,GAAO;IAEP,MAAMC,OAAOF,GAAG,CAACJ,kBAAkB,IAAI,CAAC;IACxC,OAAO,OAAOK,QAAQ,WAAWC,IAAI,CAACD,IAAI,GAAGC;AAC/C;AASO,SAASC,eAAeH,GAAwB,EAAEE,IAAiB;IACxEF,GAAG,CAACJ,kBAAkB,GAAGM;IACzB,OAAOA;AACT;AAUO,SAASE,eACdC,OAA4B,EAC5BJ,GAAM,EACNK,KAAqB;IAErB,MAAMJ,OAAOH,eAAeM;IAC5BH,IAAI,CAACD,IAAI,GAAGK;IACZ,OAAOH,eAAeE,SAASH;AACjC;AASO,SAASK,kBACdF,OAA4B,EAC5BJ,GAAM;IAEN,MAAMC,OAAOH,eAAeM;IAC5B,OAAOH,IAAI,CAACD,IAAI;IAChB,OAAOE,eAAeE,SAASH;AACjC","ignoreList":[0]}},
    {"offset": {"line": 4248, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/base-http/helpers.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './'\nimport type { NodeNextRequest, NodeNextResponse } from './node'\nimport type { WebNextRequest, WebNextResponse } from './web'\n\n/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */\n\n/**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */\nexport const isWebNextRequest = (req: BaseNextRequest): req is WebNextRequest =>\n  process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */\nexport const isWebNextResponse = (\n  res: BaseNextResponse\n): res is WebNextResponse => process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */\nexport const isNodeNextRequest = (\n  req: BaseNextRequest\n): req is NodeNextRequest => process.env.NEXT_RUNTIME !== 'edge'\n\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */\nexport const isNodeNextResponse = (\n  res: BaseNextResponse\n): res is NodeNextResponse => process.env.NEXT_RUNTIME !== 'edge'\n"],"names":["isWebNextRequest","req","process","env","NEXT_RUNTIME","isWebNextResponse","res","isNodeNextRequest","isNodeNextResponse"],"mappings":"AAIA;;;;;CAKC,GAED;;;;;CAKC,GACD;;;;;;;;;;AAAO,MAAMA,mBAAmB,CAACC,MAC/BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQ9B,MAAMC,oBAAoB,CAC/BC,MAC2BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMG,oBAAoB,CAC/BN,MAC2BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMI,qBAAqB,CAChCF,MAC4BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM","ignoreList":[0]}},
    {"offset": {"line": 4276, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/base-http/helpers.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './'\nimport type { NodeNextRequest, NodeNextResponse } from './node'\nimport type { WebNextRequest, WebNextResponse } from './web'\n\n/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */\n\n/**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */\nexport const isWebNextRequest = (req: BaseNextRequest): req is WebNextRequest =>\n  process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */\nexport const isWebNextResponse = (\n  res: BaseNextResponse\n): res is WebNextResponse => process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */\nexport const isNodeNextRequest = (\n  req: BaseNextRequest\n): req is NodeNextRequest => process.env.NEXT_RUNTIME !== 'edge'\n\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */\nexport const isNodeNextResponse = (\n  res: BaseNextResponse\n): res is NodeNextResponse => process.env.NEXT_RUNTIME !== 'edge'\n"],"names":["isWebNextRequest","req","process","env","NEXT_RUNTIME","isWebNextResponse","res","isNodeNextRequest","isNodeNextResponse"],"mappings":"AAIA;;;;;CAKC,GAED;;;;;CAKC,GACD;;;;;;;;;;AAAO,MAAMA,mBAAmB,CAACC,MAC/BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQ9B,MAAMC,oBAAoB,CAC/BC,MAC2BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMG,oBAAoB,CAC/BN,MAC2BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMI,qBAAqB,CAChCF,MAC4BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM","ignoreList":[0]}},
    {"offset": {"line": 4304, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/base-http/index.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { I18NConfig } from '../config-shared'\n\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport type { NextApiRequestCookies } from '../api-utils'\nimport { getCookieParser } from '../api-utils/get-cookie-parser'\n\nexport interface BaseNextRequestConfig {\n  basePath: string | undefined\n  i18n?: I18NConfig\n  trailingSlash?: boolean | undefined\n}\n\nexport type FetchMetric = {\n  url: string\n  idx: number\n  end: number\n  start: number\n  method: string\n  status: number\n  cacheReason: string\n  cacheStatus: 'hit' | 'miss' | 'skip' | 'hmr'\n  cacheWarning?: string\n}\n\nexport type FetchMetrics = Array<FetchMetric>\n\nexport abstract class BaseNextRequest<Body = any> {\n  protected _cookies: NextApiRequestCookies | undefined\n  public abstract headers: IncomingHttpHeaders\n  public abstract fetchMetrics: FetchMetric[] | undefined\n\n  constructor(\n    public method: string,\n    public url: string,\n    public body: Body\n  ) {}\n\n  // Utils implemented using the abstract methods above\n\n  public get cookies() {\n    if (this._cookies) return this._cookies\n    return (this._cookies = getCookieParser(this.headers)())\n  }\n}\n\nexport abstract class BaseNextResponse<Destination = any> {\n  abstract statusCode: number | undefined\n  abstract statusMessage: string | undefined\n  abstract get sent(): boolean\n\n  constructor(public destination: Destination) {}\n\n  /**\n   * Sets a value for the header overwriting existing values\n   */\n  abstract setHeader(name: string, value: string | string[]): this\n\n  /**\n   * Removes a header\n   */\n  abstract removeHeader(name: string): this\n\n  /**\n   * Appends value for the given header name\n   */\n  abstract appendHeader(name: string, value: string): this\n\n  /**\n   * Get all values for a header as an array or undefined if no value is present\n   */\n  abstract getHeaderValues(name: string): string[] | undefined\n\n  abstract hasHeader(name: string): boolean\n\n  /**\n   * Get values for a header concatenated using `,` or undefined if no value is present\n   */\n  abstract getHeader(name: string): string | undefined\n\n  abstract getHeaders(): OutgoingHttpHeaders\n\n  abstract body(value: string): this\n\n  abstract send(): void\n\n  abstract onClose(callback: () => void): void\n\n  // Utils implemented using the abstract methods above\n\n  public redirect(destination: string, statusCode: number) {\n    this.setHeader('Location', destination)\n    this.statusCode = statusCode\n\n    // Since IE11 doesn't support the 308 header add backwards\n    // compatibility using refresh header\n    if (statusCode === RedirectStatusCode.PermanentRedirect) {\n      this.setHeader('Refresh', `0;url=${destination}`)\n    }\n\n    return this\n  }\n}\n"],"names":["RedirectStatusCode","getCookieParser","BaseNextRequest","constructor","method","url","body","cookies","_cookies","headers","BaseNextResponse","destination","redirect","statusCode","setHeader","PermanentRedirect"],"mappings":";;;;;;AAGA,SAASA,kBAAkB,QAAQ,+CAA8C;AAEjF,SAASC,eAAe,QAAQ,iCAAgC;;;AAsBzD,MAAeC;IAKpBC,YACSC,MAAc,EACdC,GAAW,EACXC,IAAU,CACjB;aAHOF,MAAAA,GAAAA;aACAC,GAAAA,GAAAA;aACAC,IAAAA,GAAAA;IACN;IAEH,qDAAqD;IAErD,IAAWC,UAAU;QACnB,IAAI,IAAI,CAACC,QAAQ,EAAE,OAAO,IAAI,CAACA,QAAQ;QACvC,OAAQ,IAAI,CAACA,QAAQ,OAAGP,kOAAAA,EAAgB,IAAI,CAACQ,OAAO;IACtD;AACF;AAEO,MAAeC;IAKpBP,YAAmBQ,WAAwB,CAAE;aAA1BA,WAAAA,GAAAA;IAA2B;IAqC9C,qDAAqD;IAE9CC,SAASD,WAAmB,EAAEE,UAAkB,EAAE;QACvD,IAAI,CAACC,SAAS,CAAC,YAAYH;QAC3B,IAAI,CAACE,UAAU,GAAGA;QAElB,0DAA0D;QAC1D,qCAAqC;QACrC,IAAIA,eAAeb,sOAAAA,CAAmBe,iBAAiB,EAAE;YACvD,IAAI,CAACD,SAAS,CAAC,WAAW,CAAC,MAAM,EAAEH,aAAa;QAClD;QAEA,OAAO,IAAI;IACb;AACF","ignoreList":[0]}},
    {"offset": {"line": 4346, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/base-http/node.ts"],"sourcesContent":["import type { ServerResponse, IncomingMessage } from 'http'\nimport type { Writable, Readable } from 'stream'\n\nimport { SYMBOL_CLEARED_COOKIES } from '../api-utils'\nimport type { NextApiRequestCookies } from '../api-utils'\n\nimport { NEXT_REQUEST_META } from '../request-meta'\nimport type { RequestMeta } from '../request-meta'\n\nimport { BaseNextRequest, BaseNextResponse, type FetchMetric } from './index'\nimport type { OutgoingHttpHeaders } from 'node:http'\n\ntype Req = IncomingMessage & {\n  [NEXT_REQUEST_META]?: RequestMeta\n  cookies?: NextApiRequestCookies\n  fetchMetrics?: FetchMetric[]\n}\n\nexport class NodeNextRequest extends BaseNextRequest<Readable> {\n  public headers = this._req.headers\n  public fetchMetrics: FetchMetric[] | undefined = this._req?.fetchMetrics;\n\n  [NEXT_REQUEST_META]: RequestMeta = this._req[NEXT_REQUEST_META] || {}\n\n  constructor(private _req: Req) {\n    super(_req.method!.toUpperCase(), _req.url!, _req)\n  }\n\n  get originalRequest() {\n    // Need to mimic these changes to the original req object for places where we use it:\n    // render.tsx, api/ssg requests\n    this._req[NEXT_REQUEST_META] = this[NEXT_REQUEST_META]\n    this._req.url = this.url\n    this._req.cookies = this.cookies\n    return this._req\n  }\n\n  set originalRequest(value: Req) {\n    this._req = value\n  }\n\n  private streaming = false\n\n  /**\n   * Returns the request body as a Web Readable Stream. The body here can only\n   * be read once as the body will start flowing as soon as the data handler\n   * is attached.\n   *\n   * @internal\n   */\n  public stream() {\n    if (this.streaming) {\n      throw new Error(\n        'Invariant: NodeNextRequest.stream() can only be called once'\n      )\n    }\n    this.streaming = true\n\n    return new ReadableStream({\n      start: (controller) => {\n        this._req.on('data', (chunk) => {\n          controller.enqueue(new Uint8Array(chunk))\n        })\n        this._req.on('end', () => {\n          controller.close()\n        })\n        this._req.on('error', (err) => {\n          controller.error(err)\n        })\n      },\n    })\n  }\n}\n\nexport class NodeNextResponse extends BaseNextResponse<Writable> {\n  private textBody: string | undefined = undefined\n\n  public [SYMBOL_CLEARED_COOKIES]?: boolean\n\n  get originalResponse() {\n    if (SYMBOL_CLEARED_COOKIES in this) {\n      this._res[SYMBOL_CLEARED_COOKIES] = this[SYMBOL_CLEARED_COOKIES]\n    }\n\n    return this._res\n  }\n\n  constructor(\n    private _res: ServerResponse & { [SYMBOL_CLEARED_COOKIES]?: boolean }\n  ) {\n    super(_res)\n  }\n\n  get sent() {\n    return this._res.finished || this._res.headersSent\n  }\n\n  get statusCode() {\n    return this._res.statusCode\n  }\n\n  set statusCode(value: number) {\n    this._res.statusCode = value\n  }\n\n  get statusMessage() {\n    return this._res.statusMessage\n  }\n\n  set statusMessage(value: string) {\n    this._res.statusMessage = value\n  }\n\n  setHeader(name: string, value: string | string[]): this {\n    this._res.setHeader(name, value)\n    return this\n  }\n\n  removeHeader(name: string): this {\n    this._res.removeHeader(name)\n    return this\n  }\n\n  getHeaderValues(name: string): string[] | undefined {\n    const values = this._res.getHeader(name)\n\n    if (values === undefined) return undefined\n\n    return (Array.isArray(values) ? values : [values]).map((value) =>\n      value.toString()\n    )\n  }\n\n  hasHeader(name: string): boolean {\n    return this._res.hasHeader(name)\n  }\n\n  getHeader(name: string): string | undefined {\n    const values = this.getHeaderValues(name)\n    return Array.isArray(values) ? values.join(',') : undefined\n  }\n\n  getHeaders(): OutgoingHttpHeaders {\n    return this._res.getHeaders()\n  }\n\n  appendHeader(name: string, value: string): this {\n    const currentValues = this.getHeaderValues(name) ?? []\n\n    if (!currentValues.includes(value)) {\n      this._res.setHeader(name, [...currentValues, value])\n    }\n\n    return this\n  }\n\n  body(value: string) {\n    this.textBody = value\n    return this\n  }\n\n  send() {\n    this._res.end(this.textBody)\n  }\n\n  public onClose(callback: () => void) {\n    this.originalResponse.on('close', callback)\n  }\n}\n"],"names":["SYMBOL_CLEARED_COOKIES","NEXT_REQUEST_META","BaseNextRequest","BaseNextResponse","NodeNextRequest","constructor","_req","method","toUpperCase","url","headers","fetchMetrics","streaming","originalRequest","cookies","value","stream","Error","ReadableStream","start","controller","on","chunk","enqueue","Uint8Array","close","err","error","NodeNextResponse","originalResponse","_res","textBody","undefined","sent","finished","headersSent","statusCode","statusMessage","setHeader","name","removeHeader","getHeaderValues","values","getHeader","Array","isArray","map","toString","hasHeader","join","getHeaders","appendHeader","currentValues","includes","body","send","end","onClose","callback"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4482, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/base-http/web.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { FetchMetrics } from './index'\n\nimport { toNodeOutgoingHttpHeaders } from '../web/utils'\nimport { BaseNextRequest, BaseNextResponse } from './index'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport type { NextRequestHint } from '../web/adapter'\nimport { CloseController, trackBodyConsumed } from '../web/web-on-close'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport class WebNextRequest extends BaseNextRequest<ReadableStream | null> {\n  public request: Request\n  public headers: IncomingHttpHeaders\n  public fetchMetrics: FetchMetrics | undefined\n\n  constructor(request: NextRequestHint) {\n    const url = new URL(request.url)\n\n    super(\n      request.method,\n      url.href.slice(url.origin.length),\n      request.clone().body\n    )\n    this.request = request\n    this.fetchMetrics = request.fetchMetrics\n\n    this.headers = {}\n    for (const [name, value] of request.headers.entries()) {\n      this.headers[name] = value\n    }\n  }\n\n  async parseBody(_limit: string | number): Promise<any> {\n    throw new Error('parseBody is not implemented in the web runtime')\n  }\n}\n\nexport class WebNextResponse extends BaseNextResponse<WritableStream> {\n  private headers = new Headers()\n  private textBody: string | undefined = undefined\n\n  private closeController = new CloseController()\n\n  public statusCode: number | undefined\n  public statusMessage: string | undefined\n\n  constructor(public transformStream = new TransformStream()) {\n    super(transformStream.writable)\n  }\n\n  setHeader(name: string, value: string | string[]): this {\n    this.headers.delete(name)\n    for (const val of Array.isArray(value) ? value : [value]) {\n      this.headers.append(name, val)\n    }\n    return this\n  }\n\n  removeHeader(name: string): this {\n    this.headers.delete(name)\n    return this\n  }\n\n  getHeaderValues(name: string): string[] | undefined {\n    // https://developer.mozilla.org/docs/Web/API/Headers/get#example\n    return this.getHeader(name)\n      ?.split(',')\n      .map((v) => v.trimStart())\n  }\n\n  getHeader(name: string): string | undefined {\n    return this.headers.get(name) ?? undefined\n  }\n\n  getHeaders(): OutgoingHttpHeaders {\n    return toNodeOutgoingHttpHeaders(this.headers)\n  }\n\n  hasHeader(name: string): boolean {\n    return this.headers.has(name)\n  }\n\n  appendHeader(name: string, value: string): this {\n    this.headers.append(name, value)\n    return this\n  }\n\n  body(value: string) {\n    this.textBody = value\n    return this\n  }\n\n  private readonly sendPromise = new DetachedPromise<void>()\n\n  private _sent = false\n  public send() {\n    this.sendPromise.resolve()\n    this._sent = true\n  }\n\n  get sent() {\n    return this._sent\n  }\n\n  public async toResponse() {\n    // If we haven't called `send` yet, wait for it to be called.\n    if (!this.sent) await this.sendPromise.promise\n\n    const body = this.textBody ?? this.transformStream.readable\n\n    let bodyInit: BodyInit = body\n\n    // if the response is streaming, onClose() can still be called after this point.\n    const canAddListenersLater = typeof bodyInit !== 'string'\n    const shouldTrackBody = canAddListenersLater\n      ? true\n      : this.closeController.listeners > 0\n\n    if (shouldTrackBody) {\n      bodyInit = trackBodyConsumed(body, () => {\n        this.closeController.dispatchClose()\n      })\n    }\n\n    return new Response(bodyInit, {\n      headers: this.headers,\n      status: this.statusCode,\n      statusText: this.statusMessage,\n    })\n  }\n\n  public onClose(callback: () => void) {\n    if (this.closeController.isClosed) {\n      throw new InvariantError(\n        'Cannot call onClose on a WebNextResponse that is already closed'\n      )\n    }\n    return this.closeController.onClose(callback)\n  }\n}\n"],"names":["toNodeOutgoingHttpHeaders","BaseNextRequest","BaseNextResponse","DetachedPromise","CloseController","trackBodyConsumed","InvariantError","WebNextRequest","constructor","request","url","URL","method","href","slice","origin","length","clone","body","fetchMetrics","headers","name","value","entries","parseBody","_limit","Error","WebNextResponse","transformStream","TransformStream","writable","Headers","textBody","undefined","closeController","sendPromise","_sent","setHeader","delete","val","Array","isArray","append","removeHeader","getHeaderValues","getHeader","split","map","v","trimStart","get","getHeaders","hasHeader","has","appendHeader","send","resolve","sent","toResponse","promise","readable","bodyInit","canAddListenersLater","shouldTrackBody","listeners","dispatchClose","Response","status","statusCode","statusText","statusMessage","onClose","callback","isClosed"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4597, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/client-component-renderer-logger.ts"],"sourcesContent":["import type { AppPageModule } from './route-modules/app-page/module'\n\n// Combined load times for loading client components\nlet clientComponentLoadStart = 0\nlet clientComponentLoadTimes = 0\nlet clientComponentLoadCount = 0\n\nexport function wrapClientComponentLoader(\n  ComponentMod: AppPageModule\n): AppPageModule['__next_app__'] {\n  if (!('performance' in globalThis)) {\n    return ComponentMod.__next_app__\n  }\n\n  return {\n    require: (...args) => {\n      const startTime = performance.now()\n\n      if (clientComponentLoadStart === 0) {\n        clientComponentLoadStart = startTime\n      }\n\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.require(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n    loadChunk: (...args) => {\n      const startTime = performance.now()\n      const result = ComponentMod.__next_app__.loadChunk(...args)\n      // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\n      // We only need to know when it's settled.\n      result.finally(() => {\n        clientComponentLoadTimes += performance.now() - startTime\n      })\n      return result\n    },\n  }\n}\n\nexport function getClientComponentLoaderMetrics(\n  options: { reset?: boolean } = {}\n) {\n  const metrics =\n    clientComponentLoadStart === 0\n      ? undefined\n      : {\n          clientComponentLoadStart,\n          clientComponentLoadTimes,\n          clientComponentLoadCount,\n        }\n\n  if (options.reset) {\n    clientComponentLoadStart = 0\n    clientComponentLoadTimes = 0\n    clientComponentLoadCount = 0\n  }\n\n  return metrics\n}\n"],"names":["clientComponentLoadStart","clientComponentLoadTimes","clientComponentLoadCount","wrapClientComponentLoader","ComponentMod","globalThis","__next_app__","require","args","startTime","performance","now","loadChunk","result","finally","getClientComponentLoaderMetrics","options","metrics","undefined","reset"],"mappings":";;;;;;AAEA,oDAAoD;AACpD,IAAIA,2BAA2B;AAC/B,IAAIC,2BAA2B;AAC/B,IAAIC,2BAA2B;AAExB,SAASC,0BACdC,YAA2B;IAE3B,IAAI,CAAE,CAAA,iBAAiBC,UAAS,GAAI;QAClC,OAAOD,aAAaE,YAAY;IAClC;IAEA,OAAO;QACLC,SAAS,CAAC,GAAGC;YACX,MAAMC,YAAYC,YAAYC,GAAG;YAEjC,IAAIX,6BAA6B,GAAG;gBAClCA,2BAA2BS;YAC7B;YAEA,IAAI;gBACFP,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACC,OAAO,IAAIC;YAC9C,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;QACAG,WAAW,CAAC,GAAGJ;YACb,MAAMC,YAAYC,YAAYC,GAAG;YACjC,MAAME,SAAST,aAAaE,YAAY,CAACM,SAAS,IAAIJ;YACtD,gHAAgH;YAChH,0CAA0C;YAC1CK,OAAOC,OAAO,CAAC;gBACbb,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;YACA,OAAOI;QACT;IACF;AACF;AAEO,SAASE,gCACdC,UAA+B,CAAC,CAAC;IAEjC,MAAMC,UACJjB,6BAA6B,IACzBkB,YACA;QACElB;QACAC;QACAC;IACF;IAEN,IAAIc,QAAQG,KAAK,EAAE;QACjBnB,2BAA2B;QAC3BC,2BAA2B;QAC3BC,2BAA2B;IAC7B;IAEA,OAAOe;AACT","ignoreList":[0]}},
    {"offset": {"line": 4653, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/pipe-readable.ts"],"sourcesContent":["import type { ServerResponse } from 'node:http'\n\nimport {\n  ResponseAbortedName,\n  createAbortController,\n} from './web/spec-extension/adapters/next-request'\nimport { DetachedPromise } from '../lib/detached-promise'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger'\n\nexport function isAbortError(e: any): e is Error & { name: 'AbortError' } {\n  return e?.name === 'AbortError' || e?.name === ResponseAbortedName\n}\n\nfunction createWriterFromResponse(\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n): WritableStream<Uint8Array> {\n  let started = false\n\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new DetachedPromise<void>()\n  function onDrain() {\n    drained.resolve()\n  }\n  res.on('drain', onDrain)\n\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once('close', () => {\n    res.off('drain', onDrain)\n    drained.resolve()\n  })\n\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new DetachedPromise<void>()\n  res.once('finish', () => {\n    finished.resolve()\n  })\n\n  // Create a writable stream that will write to the response.\n  return new WritableStream<Uint8Array>({\n    write: async (chunk) => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true\n\n        if (\n          'performance' in globalThis &&\n          process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n        ) {\n          const metrics = getClientComponentLoaderMetrics()\n          if (metrics) {\n            performance.measure(\n              `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,\n              {\n                start: metrics.clientComponentLoadStart,\n                end:\n                  metrics.clientComponentLoadStart +\n                  metrics.clientComponentLoadTimes,\n              }\n            )\n          }\n        }\n\n        res.flushHeaders()\n        getTracer().trace(\n          NextNodeServerSpan.startResponse,\n          {\n            spanName: 'start response',\n          },\n          () => undefined\n        )\n      }\n\n      try {\n        const ok = res.write(chunk)\n\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if ('flush' in res && typeof res.flush === 'function') {\n          res.flush()\n        }\n\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise\n\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new DetachedPromise<void>()\n        }\n      } catch (err) {\n        res.end()\n        throw new Error('failed to write chunk to response', { cause: err })\n      }\n    },\n    abort: (err) => {\n      if (res.writableFinished) return\n\n      res.destroy(err)\n    },\n    close: async () => {\n      // if a waitUntil promise was passed, wait for it to resolve before\n      // ending the response.\n      if (waitUntilForEnd) {\n        await waitUntilForEnd\n      }\n\n      if (res.writableFinished) return\n\n      res.end()\n      return finished.promise\n    },\n  })\n}\n\nexport async function pipeToNodeResponse(\n  readable: ReadableStream<Uint8Array>,\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n) {\n  try {\n    // If the response has already errored, then just return now.\n    const { errored, destroyed } = res\n    if (errored || destroyed) return\n\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = createAbortController(res)\n\n    const writer = createWriterFromResponse(res, waitUntilForEnd)\n\n    await readable.pipeTo(writer, { signal: controller.signal })\n  } catch (err: any) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return\n\n    throw new Error('failed to pipe response', { cause: err })\n  }\n}\n"],"names":["ResponseAbortedName","createAbortController","DetachedPromise","getTracer","NextNodeServerSpan","getClientComponentLoaderMetrics","isAbortError","e","name","createWriterFromResponse","res","waitUntilForEnd","started","drained","onDrain","resolve","on","once","off","finished","WritableStream","write","chunk","globalThis","process","env","NEXT_OTEL_PERFORMANCE_PREFIX","metrics","performance","measure","start","clientComponentLoadStart","end","clientComponentLoadTimes","flushHeaders","trace","startResponse","spanName","undefined","ok","flush","promise","err","Error","cause","abort","writableFinished","destroy","close","pipeToNodeResponse","readable","errored","destroyed","controller","writer","pipeTo","signal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4784, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/render-result.ts"],"sourcesContent":["import type { OutgoingHttpHeaders, ServerResponse } from 'http'\nimport type { CacheControl } from './lib/cache-control'\nimport type { FetchMetrics } from './base-http'\n\nimport {\n  chainStreams,\n  streamFromBuffer,\n  streamFromString,\n  streamToString,\n} from './stream-utils/node-web-streams-helper'\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable'\nimport type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport type {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  TEXT_PLAIN_CONTENT_TYPE_HEADER,\n} from '../lib/constants'\nimport type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'\n\ntype ContentTypeOption =\n  | typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses\n  | typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses\n  | typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests\n  | typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors\n\nexport type AppPageRenderResultMetadata = {\n  flightData?: Buffer\n  cacheControl?: CacheControl\n  staticBailoutInfo?: {\n    stack?: string\n    description?: string\n  }\n\n  /**\n   * The postponed state if the render had postponed and needs to be resumed.\n   */\n  postponed?: string\n\n  /**\n   * The headers to set on the response that were added by the render.\n   */\n  headers?: OutgoingHttpHeaders\n  statusCode?: number\n  fetchTags?: string\n  fetchMetrics?: FetchMetrics\n\n  segmentData?: Map<string, Buffer>\n\n  /**\n   * In development, the resume data cache is warmed up before the render. This\n   * is attached to the metadata so that it can be used during the render. When\n   * prerendering, the filled resume data cache is also attached to the metadata\n   * so that it can be used when prerendering matching fallback shells.\n   */\n  renderResumeDataCache?: RenderResumeDataCache\n}\n\nexport type PagesRenderResultMetadata = {\n  pageData?: any\n  cacheControl?: CacheControl\n  assetQueryString?: string\n  isNotFound?: boolean\n  isRedirect?: boolean\n}\n\nexport type StaticRenderResultMetadata = {}\n\nexport type RenderResultMetadata = AppPageRenderResultMetadata &\n  PagesRenderResultMetadata &\n  StaticRenderResultMetadata\n\nexport type RenderResultResponse =\n  | ReadableStream<Uint8Array>[]\n  | ReadableStream<Uint8Array>\n  | string\n  | Buffer\n  | null\n\nexport type RenderResultOptions<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> = {\n  contentType: ContentTypeOption | null\n  waitUntil?: Promise<unknown>\n  metadata: Metadata\n}\n\nexport default class RenderResult<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> {\n  /**\n   * The detected content type for the response. This is used to set the\n   * `Content-Type` header.\n   */\n  public readonly contentType: ContentTypeOption | null\n\n  /**\n   * The metadata for the response. This is used to set the revalidation times\n   * and other metadata.\n   */\n  public readonly metadata: Readonly<Metadata>\n\n  /**\n   * The response itself. This can be a string, a stream, or null. If it's a\n   * string, then it's a static response. If it's a stream, then it's a\n   * dynamic response. If it's null, then the response was not found or was\n   * already sent.\n   */\n  private response: RenderResultResponse\n\n  /**\n   * A render result that represents an empty response. This is used to\n   * represent a response that was not found or was already sent.\n   */\n  public static readonly EMPTY = new RenderResult<StaticRenderResultMetadata>(\n    null,\n    { metadata: {}, contentType: null }\n  )\n\n  /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @param contentType the content type of the response\n   * @returns a new RenderResult instance\n   */\n  public static fromStatic(\n    value: string | Buffer,\n    contentType: ContentTypeOption\n  ) {\n    return new RenderResult<StaticRenderResultMetadata>(value, {\n      metadata: {},\n      contentType,\n    })\n  }\n\n  private readonly waitUntil?: Promise<unknown>\n\n  constructor(\n    response: RenderResultResponse,\n    { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>\n  ) {\n    this.response = response\n    this.contentType = contentType\n    this.metadata = metadata\n    this.waitUntil = waitUntil\n  }\n\n  public assignMetadata(metadata: Metadata) {\n    Object.assign(this.metadata, metadata)\n  }\n\n  /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */\n  public get isNull(): boolean {\n    return this.response === null\n  }\n\n  /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */\n  public get isDynamic(): boolean {\n    return typeof this.response !== 'string'\n  }\n\n  /**\n   * Returns the response if it is a string. If the page was dynamic, this will\n   * return a promise if the `stream` option is true, or it will throw an error.\n   *\n   * @param stream Whether or not to return a promise if the response is dynamic\n   * @returns The response as a string\n   */\n  public toUnchunkedString(stream?: false): string\n  public toUnchunkedString(stream: true): Promise<string>\n  public toUnchunkedString(stream = false): Promise<string> | string {\n    if (this.response === null) {\n      // If the response is null, return an empty string. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return ''\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new InvariantError(\n          'dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToString(this.readable)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Returns a readable stream of the response.\n   */\n  private get readable(): ReadableStream<Uint8Array> {\n    if (this.response === null) {\n      // If the response is null, return an empty stream. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return new ReadableStream<Uint8Array>({\n        start(controller) {\n          controller.close()\n        },\n      })\n    }\n\n    if (typeof this.response === 'string') {\n      return streamFromString(this.response)\n    }\n\n    if (Buffer.isBuffer(this.response)) {\n      return streamFromBuffer(this.response)\n    }\n\n    // If the response is an array of streams, then chain them together.\n    if (Array.isArray(this.response)) {\n      return chainStreams(...this.response)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Coerces the response to an array of streams. This will convert the response\n   * to an array of streams if it is not already one.\n   *\n   * @returns An array of streams\n   */\n  private coerce(): ReadableStream<Uint8Array>[] {\n    if (this.response === null) {\n      // If the response is null, return an empty stream. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return []\n    }\n\n    if (typeof this.response === 'string') {\n      return [streamFromString(this.response)]\n    } else if (Array.isArray(this.response)) {\n      return this.response\n    } else if (Buffer.isBuffer(this.response)) {\n      return [streamFromBuffer(this.response)]\n    } else {\n      return [this.response]\n    }\n  }\n\n  /**\n   * Unshifts a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the start of the array. When this response is piped, all of the streams\n   * will be piped one after the other.\n   *\n   * @param readable The new stream to unshift\n   */\n  public unshift(readable: ReadableStream<Uint8Array>): void {\n    // Coerce the response to an array of streams.\n    this.response = this.coerce()\n\n    // Add the new stream to the start of the array.\n    this.response.unshift(readable)\n  }\n\n  /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */\n  public push(readable: ReadableStream<Uint8Array>): void {\n    // Coerce the response to an array of streams.\n    this.response = this.coerce()\n\n    // Add the new stream to the end of the array.\n    this.response.push(readable)\n  }\n\n  /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */\n  public async pipeTo(writable: WritableStream<Uint8Array>): Promise<void> {\n    try {\n      await this.readable.pipeTo(writable, {\n        // We want to close the writable stream ourselves so that we can wait\n        // for the waitUntil promise to resolve before closing it. If an error\n        // is encountered, we'll abort the writable stream if we swallowed the\n        // error.\n        preventClose: true,\n      })\n\n      // If there is a waitUntil promise, wait for it to resolve before\n      // closing the writable stream.\n      if (this.waitUntil) await this.waitUntil\n\n      // Close the writable stream.\n      await writable.close()\n    } catch (err) {\n      // If this is an abort error, we should abort the writable stream (as we\n      // took ownership of it when we started piping). We don't need to re-throw\n      // because we handled the error.\n      if (isAbortError(err)) {\n        // Abort the writable stream if an error is encountered.\n        await writable.abort(err)\n\n        return\n      }\n\n      // We're not aborting the writer here as when this method throws it's not\n      // clear as to how so the caller should assume it's their responsibility\n      // to clean up the writer.\n      throw err\n    }\n  }\n\n  /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */\n  public async pipeToNodeResponse(res: ServerResponse) {\n    await pipeToNodeResponse(this.readable, res, this.waitUntil)\n  }\n}\n"],"names":["chainStreams","streamFromBuffer","streamFromString","streamToString","isAbortError","pipeToNodeResponse","InvariantError","RenderResult","EMPTY","metadata","contentType","fromStatic","value","constructor","response","waitUntil","assignMetadata","Object","assign","isNull","isDynamic","toUnchunkedString","stream","readable","ReadableStream","start","controller","close","Buffer","isBuffer","Array","isArray","coerce","unshift","push","pipeTo","writable","preventClose","err","abort","res"],"mappings":";;;;AAuNQ4B;AAnNR,SACE5B,YAAY,EACZC,gBAAgB,EAChBC,gBAAgB,EAChBC,cAAc,QACT,yCAAwC;AAC/C,SAASC,YAAY,EAAEC,kBAAkB,QAAQ,kBAAiB;AAElE,SAASC,cAAc,QAAQ,gCAA+B;;;;AA2E/C,MAAMC;gBAuBnB;;;GAGC,GAAA,IAAA,CACsBC,KAAAA,GAAQ,IAAID,aACjC,MACA;QAAEE,UAAU,CAAC;QAAGC,aAAa;IAAK,GAAA;IAGpC;;;;;;GAMC,GACD,OAAcC,WACZC,KAAsB,EACtBF,WAA8B,EAC9B;QACA,OAAO,IAAIH,aAAyCK,OAAO;YACzDH,UAAU,CAAC;YACXC;QACF;IACF;IAIAG,YACEC,QAA8B,EAC9B,EAAEJ,WAAW,EAAEK,SAAS,EAAEN,QAAQ,EAAiC,CACnE;QACA,IAAI,CAACK,QAAQ,GAAGA;QAChB,IAAI,CAACJ,WAAW,GAAGA;QACnB,IAAI,CAACD,QAAQ,GAAGA;QAChB,IAAI,CAACM,SAAS,GAAGA;IACnB;IAEOC,eAAeP,QAAkB,EAAE;QACxCQ,OAAOC,MAAM,CAAC,IAAI,CAACT,QAAQ,EAAEA;IAC/B;IAEA;;;GAGC,GACD,IAAWU,SAAkB;QAC3B,OAAO,IAAI,CAACL,QAAQ,KAAK;IAC3B;IAEA;;;GAGC,GACD,IAAWM,YAAqB;QAC9B,OAAO,OAAO,IAAI,CAACN,QAAQ,KAAK;IAClC;IAWOO,kBAAkBC,SAAS,KAAK,EAA4B;QACjE,IAAI,IAAI,CAACR,QAAQ,KAAK,MAAM;YAC1B,oEAAoE;YACpE,qEAAqE;YACrE,OAAO;QACT;QAEA,IAAI,OAAO,IAAI,CAACA,QAAQ,KAAK,UAAU;YACrC,IAAI,CAACQ,QAAQ;gBACX,MAAM,OAAA,cAEL,CAFK,IAAIhB,mNAAAA,CACR,oEADI,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YAEA,WAAOH,6OAAAA,EAAe,IAAI,CAACoB,QAAQ;QACrC;QAEA,OAAO,IAAI,CAACT,QAAQ;IACtB;IAEA;;GAEC,GACD,IAAYS,WAAuC;QACjD,IAAI,IAAI,CAACT,QAAQ,KAAK,MAAM;YAC1B,oEAAoE;YACpE,qEAAqE;YACrE,OAAO,IAAIU,eAA2B;gBACpCC,OAAMC,UAAU;oBACdA,WAAWC,KAAK;gBAClB;YACF;QACF;QAEA,IAAI,OAAO,IAAI,CAACb,QAAQ,KAAK,UAAU;YACrC,WAAOZ,+OAAAA,EAAiB,IAAI,CAACY,QAAQ;QACvC;QAEA,mIAAIc,CAAOC,QAAQ,CAAC,IAAI,CAACf,QAAQ,GAAG;YAClC,WAAOb,+OAAAA,EAAiB,IAAI,CAACa,QAAQ;QACvC;QAEA,oEAAoE;QACpE,IAAIgB,MAAMC,OAAO,CAAC,IAAI,CAACjB,QAAQ,GAAG;YAChC,WAAOd,2OAAAA,KAAgB,IAAI,CAACc,QAAQ;QACtC;QAEA,OAAO,IAAI,CAACA,QAAQ;IACtB;IAEA;;;;;GAKC,GACOkB,SAAuC;QAC7C,IAAI,IAAI,CAAClB,QAAQ,KAAK,MAAM;YAC1B,oEAAoE;YACpE,qEAAqE;YACrE,OAAO,EAAE;QACX;QAEA,IAAI,OAAO,IAAI,CAACA,QAAQ,KAAK,UAAU;YACrC,OAAO;oBAACZ,+OAAAA,EAAiB,IAAI,CAACY,QAAQ;aAAE;QAC1C,OAAO,IAAIgB,MAAMC,OAAO,CAAC,IAAI,CAACjB,QAAQ,GAAG;YACvC,OAAO,IAAI,CAACA,QAAQ;QACtB,OAAO,IAAIc,+HAAAA,CAAOC,QAAQ,CAAC,IAAI,CAACf,QAAQ,GAAG;YACzC,OAAO;oBAACb,+OAAAA,EAAiB,IAAI,CAACa,QAAQ;aAAE;QAC1C,OAAO;YACL,OAAO;gBAAC,IAAI,CAACA,QAAQ;aAAC;QACxB;IACF;IAEA;;;;;;;GAOC,GACMmB,QAAQV,QAAoC,EAAQ;QACzD,8CAA8C;QAC9C,IAAI,CAACT,QAAQ,GAAG,IAAI,CAACkB,MAAM;QAE3B,gDAAgD;QAChD,IAAI,CAAClB,QAAQ,CAACmB,OAAO,CAACV;IACxB;IAEA;;;;;;;GAOC,GACMW,KAAKX,QAAoC,EAAQ;QACtD,8CAA8C;QAC9C,IAAI,CAACT,QAAQ,GAAG,IAAI,CAACkB,MAAM;QAE3B,8CAA8C;QAC9C,IAAI,CAAClB,QAAQ,CAACoB,IAAI,CAACX;IACrB;IAEA;;;;;;GAMC,GACD,MAAaY,OAAOC,QAAoC,EAAiB;QACvE,IAAI;YACF,MAAM,IAAI,CAACb,QAAQ,CAACY,MAAM,CAACC,UAAU;gBACnC,qEAAqE;gBACrE,sEAAsE;gBACtE,sEAAsE;gBACtE,SAAS;gBACTC,cAAc;YAChB;YAEA,iEAAiE;YACjE,+BAA+B;YAC/B,IAAI,IAAI,CAACtB,SAAS,EAAE,MAAM,IAAI,CAACA,SAAS;YAExC,6BAA6B;YAC7B,MAAMqB,SAAST,KAAK;QACtB,EAAE,OAAOW,KAAK;YACZ,wEAAwE;YACxE,0EAA0E;YAC1E,gCAAgC;YAChC,IAAIlC,4MAAAA,EAAakC,MAAM;gBACrB,wDAAwD;gBACxD,MAAMF,SAASG,KAAK,CAACD;gBAErB;YACF;YAEA,yEAAyE;YACzE,wEAAwE;YACxE,0BAA0B;YAC1B,MAAMA;QACR;IACF;IAEA;;;;;GAKC,GACD,MAAajC,mBAAmBmC,GAAmB,EAAE;QACnD,UAAMnC,8MAAAA,EAAmB,IAAI,CAACkB,QAAQ,EAAEiB,KAAK,IAAI,CAACzB,SAAS;IAC7D;AACF","ignoreList":[0]}},
    {"offset": {"line": 4979, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;;AAAO,IAAWA,YAAAA,WAAAA,GAAAA,SAAAA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;WAtBeA;MAwBjB","ignoreList":[0]}},
    {"offset": {"line": 5007, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/server-utils.ts"],"sourcesContent":["import type { Rewrite } from '../lib/load-custom-routes'\nimport type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'\nimport type { NextConfig } from './config'\nimport type { BaseNextRequest } from './base-http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\n\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport { getPathMatch } from '../shared/lib/router/utils/path-match'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\nimport {\n  matchHas,\n  prepareDestination,\n} from '../shared/lib/router/utils/prepare-destination'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { normalizeRscURL } from '../shared/lib/router/utils/app-paths'\nimport {\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_INTERCEPTION_MARKER_PREFIX,\n  NEXT_QUERY_PARAM_PREFIX,\n} from '../lib/constants'\nimport { normalizeNextQueryParam } from './web/utils'\nimport type { IncomingHttpHeaders, IncomingMessage } from 'http'\nimport { decodeQueryPathParameter } from './lib/decode-query-path-parameter'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { parseReqUrl } from '../lib/url'\nimport { formatUrl } from '../shared/lib/router/utils/format-url'\n\nfunction filterInternalQuery(\n  query: Record<string, undefined | string | string[]>,\n  paramKeys: string[]\n) {\n  // this is used to pass query information in rewrites\n  // but should not be exposed in final query\n  delete query['nextInternalLocale']\n\n  for (const key in query) {\n    const isNextQueryPrefix =\n      key !== NEXT_QUERY_PARAM_PREFIX && key.startsWith(NEXT_QUERY_PARAM_PREFIX)\n\n    const isNextInterceptionMarkerPrefix =\n      key !== NEXT_INTERCEPTION_MARKER_PREFIX &&\n      key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)\n\n    if (\n      isNextQueryPrefix ||\n      isNextInterceptionMarkerPrefix ||\n      paramKeys.includes(key)\n    ) {\n      delete query[key]\n    }\n  }\n}\n\nexport function normalizeCdnUrl(\n  req: BaseNextRequest | IncomingMessage,\n  paramKeys: string[]\n) {\n  // make sure to normalize req.url from CDNs to strip dynamic and rewrite\n  // params from the query which are added during routing\n  const _parsedUrl = parseReqUrl(req.url!)\n\n  // we can't normalize if we can't parse\n  if (!_parsedUrl) {\n    return req.url\n  }\n  delete (_parsedUrl as any).search\n  filterInternalQuery(_parsedUrl.query, paramKeys)\n\n  req.url = formatUrl(_parsedUrl)\n}\n\nexport function interpolateDynamicPath(\n  pathname: string,\n  params: ParsedUrlQuery,\n  defaultRouteRegex?: ReturnType<typeof getNamedRouteRegex> | undefined\n) {\n  if (!defaultRouteRegex) return pathname\n\n  for (const param of Object.keys(defaultRouteRegex.groups)) {\n    const { optional, repeat } = defaultRouteRegex.groups[param]\n    let builtParam = `[${repeat ? '...' : ''}${param}]`\n\n    if (optional) {\n      builtParam = `[${builtParam}]`\n    }\n\n    let paramValue: string\n    const value = params[param]\n\n    if (Array.isArray(value)) {\n      paramValue = value.map((v) => v && encodeURIComponent(v)).join('/')\n    } else if (value) {\n      paramValue = encodeURIComponent(value)\n    } else {\n      paramValue = ''\n    }\n\n    if (paramValue || optional) {\n      pathname = pathname.replaceAll(builtParam, paramValue)\n    }\n  }\n\n  return pathname\n}\n\nexport function normalizeDynamicRouteParams(\n  query: ParsedUrlQuery,\n  defaultRouteRegex: ReturnType<typeof getNamedRouteRegex>,\n  defaultRouteMatches: ParsedUrlQuery,\n  ignoreMissingOptional: boolean\n) {\n  let hasValidParams = true\n  let params: ParsedUrlQuery = {}\n\n  for (const key of Object.keys(defaultRouteRegex.groups)) {\n    let value: string | string[] | undefined = query[key]\n\n    if (typeof value === 'string') {\n      value = normalizeRscURL(value)\n    } else if (Array.isArray(value)) {\n      value = value.map(normalizeRscURL)\n    }\n\n    // if the value matches the default value we can't rely\n    // on the parsed params, this is used to signal if we need\n    // to parse x-now-route-matches or not\n    const defaultValue = defaultRouteMatches![key]\n    const isOptional = defaultRouteRegex!.groups[key].optional\n\n    const isDefaultValue = Array.isArray(defaultValue)\n      ? defaultValue.some((defaultVal) => {\n          return Array.isArray(value)\n            ? value.some((val) => val.includes(defaultVal))\n            : value?.includes(defaultVal)\n        })\n      : value?.includes(defaultValue as string)\n\n    if (\n      isDefaultValue ||\n      (typeof value === 'undefined' && !(isOptional && ignoreMissingOptional))\n    ) {\n      return { params: {}, hasValidParams: false }\n    }\n\n    // non-provided optional values should be undefined so normalize\n    // them to undefined\n    if (\n      isOptional &&\n      (!value ||\n        (Array.isArray(value) &&\n          value.length === 1 &&\n          // fallback optional catch-all SSG pages have\n          // [[...paramName]] for the root path on Vercel\n          (value[0] === 'index' || value[0] === `[[...${key}]]`)) ||\n        value === 'index' ||\n        value === `[[...${key}]]`)\n    ) {\n      value = undefined\n      delete query[key]\n    }\n\n    // query values from the proxy aren't already split into arrays\n    // so make sure to normalize catch-all values\n    if (\n      value &&\n      typeof value === 'string' &&\n      defaultRouteRegex!.groups[key].repeat\n    ) {\n      value = value.split('/')\n    }\n\n    if (value) {\n      params[key] = value\n    }\n  }\n\n  return {\n    params,\n    hasValidParams,\n  }\n}\n\nexport function getServerUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic,\n  trailingSlash,\n  caseSensitive,\n}: {\n  page: string\n  i18n?: NextConfig['i18n']\n  basePath: string\n  rewrites: DeepReadonly<{\n    fallback?: ReadonlyArray<Rewrite>\n    afterFiles?: ReadonlyArray<Rewrite>\n    beforeFiles?: ReadonlyArray<Rewrite>\n  }>\n  pageIsDynamic: boolean\n  trailingSlash?: boolean\n  caseSensitive: boolean\n}) {\n  let defaultRouteRegex: ReturnType<typeof getNamedRouteRegex> | undefined\n  let dynamicRouteMatcher: RouteMatchFn | undefined\n  let defaultRouteMatches: ParsedUrlQuery | undefined\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = getNamedRouteRegex(page, {\n      prefixRouteKeys: false,\n    })\n    dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)\n    defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery\n  }\n\n  function handleRewrites(\n    req: BaseNextRequest | IncomingMessage,\n    parsedUrl: DeepReadonly<UrlWithParsedQuery>\n  ) {\n    // Here we deep clone the parsedUrl to avoid mutating the original. We also\n    // cast this to a mutable type so we can mutate it within this scope.\n    const rewrittenParsedUrl = structuredClone(parsedUrl) as UrlWithParsedQuery\n    const rewriteParams: Record<string, string> = {}\n    let fsPathname = rewrittenParsedUrl.pathname\n\n    const matchesPage = () => {\n      const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')\n      return (\n        fsPathnameNoSlash === removeTrailingSlash(page) ||\n        dynamicRouteMatcher?.(fsPathnameNoSlash)\n      )\n    }\n\n    const checkRewrite = (rewrite: DeepReadonly<Rewrite>): boolean => {\n      const matcher = getPathMatch(\n        rewrite.source + (trailingSlash ? '(/)?' : ''),\n        {\n          removeUnnamedParams: true,\n          strict: true,\n          sensitive: !!caseSensitive,\n        }\n      )\n\n      if (!rewrittenParsedUrl.pathname) return false\n\n      let params = matcher(rewrittenParsedUrl.pathname)\n\n      if ((rewrite.has || rewrite.missing) && params) {\n        const hasParams = matchHas(\n          req,\n          rewrittenParsedUrl.query,\n          rewrite.has as Rewrite['has'],\n          rewrite.missing as Rewrite['missing']\n        )\n\n        if (hasParams) {\n          Object.assign(params, hasParams)\n        } else {\n          params = false\n        }\n      }\n\n      if (params) {\n        const { parsedDestination, destQuery } = prepareDestination({\n          appendParamsToQuery: true,\n          destination: rewrite.destination,\n          params: params,\n          query: rewrittenParsedUrl.query,\n        })\n\n        // if the rewrite destination is external break rewrite chain\n        if (parsedDestination.protocol) {\n          return true\n        }\n\n        Object.assign(rewriteParams, destQuery, params)\n        Object.assign(rewrittenParsedUrl.query, parsedDestination.query)\n        delete (parsedDestination as any).query\n\n        Object.assign(rewrittenParsedUrl, parsedDestination)\n\n        fsPathname = rewrittenParsedUrl.pathname\n        if (!fsPathname) return false\n\n        if (basePath) {\n          fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'\n        }\n\n        if (i18n) {\n          const result = normalizeLocalePath(fsPathname, i18n.locales)\n          fsPathname = result.pathname\n          rewrittenParsedUrl.query.nextInternalLocale =\n            result.detectedLocale || params.nextInternalLocale\n        }\n\n        if (fsPathname === page) {\n          return true\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname)\n          if (dynamicParams) {\n            rewrittenParsedUrl.query = {\n              ...rewrittenParsedUrl.query,\n              ...dynamicParams,\n            }\n            return true\n          }\n        }\n      }\n\n      return false\n    }\n\n    for (const rewrite of rewrites.beforeFiles || []) {\n      checkRewrite(rewrite)\n    }\n\n    if (fsPathname !== page) {\n      let finished = false\n\n      for (const rewrite of rewrites.afterFiles || []) {\n        finished = checkRewrite(rewrite)\n        if (finished) break\n      }\n\n      if (!finished && !matchesPage()) {\n        for (const rewrite of rewrites.fallback || []) {\n          finished = checkRewrite(rewrite)\n          if (finished) break\n        }\n      }\n    }\n\n    return { rewriteParams, rewrittenParsedUrl }\n  }\n\n  function getParamsFromRouteMatches(routeMatchesHeader: string) {\n    // If we don't have a default route regex, we can't get params from route\n    // matches\n    if (!defaultRouteRegex) return null\n\n    const { groups, routeKeys } = defaultRouteRegex\n\n    const matcher = getRouteMatcher({\n      re: {\n        // Simulate a RegExp match from the \\`req.url\\` input\n        exec: (str: string) => {\n          // Normalize all the prefixed query params.\n          const obj: Record<string, string> = Object.fromEntries(\n            new URLSearchParams(str)\n          )\n          for (const [key, value] of Object.entries(obj)) {\n            const normalizedKey = normalizeNextQueryParam(key)\n            if (!normalizedKey) continue\n\n            obj[normalizedKey] = value\n            delete obj[key]\n          }\n\n          // Use all the named route keys.\n          const result = {} as RegExpExecArray\n          for (const keyName of Object.keys(routeKeys)) {\n            const paramName = routeKeys[keyName]\n\n            // If this param name is not a valid parameter name, then skip it.\n            if (!paramName) continue\n\n            const group = groups[paramName]\n            const value = obj[keyName]\n\n            // When we're missing a required param, we can't match the route.\n            if (!group.optional && !value) return null\n\n            result[group.pos] = value\n          }\n\n          return result\n        },\n      },\n      groups,\n    })\n\n    const routeMatches = matcher(routeMatchesHeader)\n    if (!routeMatches) return null\n\n    return routeMatches\n  }\n\n  function normalizeQueryParams(\n    query: Record<string, string | string[] | undefined>,\n    routeParamKeys: Set<string>\n  ) {\n    // this is used to pass query information in rewrites\n    // but should not be exposed in final query\n    delete query['nextInternalLocale']\n\n    for (const [key, value] of Object.entries(query)) {\n      const normalizedKey = normalizeNextQueryParam(key)\n      if (!normalizedKey) continue\n\n      // Remove the prefixed key from the query params because we want\n      // to consume it for the dynamic route matcher.\n      delete query[key]\n      routeParamKeys.add(normalizedKey)\n\n      if (typeof value === 'undefined') continue\n\n      query[normalizedKey] = Array.isArray(value)\n        ? value.map((v) => decodeQueryPathParameter(v))\n        : decodeQueryPathParameter(value)\n    }\n  }\n\n  return {\n    handleRewrites,\n    defaultRouteRegex,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    normalizeQueryParams,\n    getParamsFromRouteMatches,\n    /**\n     * Normalize dynamic route params.\n     *\n     * @param query - The query params to normalize.\n     * @param ignoreMissingOptional - Whether to ignore missing optional params.\n     * @returns The normalized params and whether they are valid.\n     */\n    normalizeDynamicRouteParams: (\n      query: ParsedUrlQuery,\n      ignoreMissingOptional: boolean\n    ) => {\n      if (!defaultRouteRegex || !defaultRouteMatches) {\n        return { params: {}, hasValidParams: false }\n      }\n\n      return normalizeDynamicRouteParams(\n        query,\n        defaultRouteRegex,\n        defaultRouteMatches,\n        ignoreMissingOptional\n      )\n    },\n\n    normalizeCdnUrl: (\n      req: BaseNextRequest | IncomingMessage,\n      paramKeys: string[]\n    ) => normalizeCdnUrl(req, paramKeys),\n\n    interpolateDynamicPath: (\n      pathname: string,\n      params: Record<string, undefined | string | string[]>\n    ) => interpolateDynamicPath(pathname, params, defaultRouteRegex),\n\n    filterInternalQuery: (query: ParsedUrlQuery, paramKeys: string[]) =>\n      filterInternalQuery(query, paramKeys),\n  }\n}\n\nexport function getPreviouslyRevalidatedTags(\n  headers: IncomingHttpHeaders,\n  previewModeId: string | undefined\n): string[] {\n  return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &&\n    headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId\n    ? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')\n    : []\n}\n"],"names":["normalizeLocalePath","getPathMatch","getNamedRouteRegex","getRouteMatcher","matchHas","prepareDestination","removeTrailingSlash","normalizeRscURL","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_INTERCEPTION_MARKER_PREFIX","NEXT_QUERY_PARAM_PREFIX","normalizeNextQueryParam","decodeQueryPathParameter","parseReqUrl","formatUrl","filterInternalQuery","query","paramKeys","key","isNextQueryPrefix","startsWith","isNextInterceptionMarkerPrefix","includes","normalizeCdnUrl","req","_parsedUrl","url","search","interpolateDynamicPath","pathname","params","defaultRouteRegex","param","Object","keys","groups","optional","repeat","builtParam","paramValue","value","Array","isArray","map","v","encodeURIComponent","join","replaceAll","normalizeDynamicRouteParams","defaultRouteMatches","ignoreMissingOptional","hasValidParams","defaultValue","isOptional","isDefaultValue","some","defaultVal","val","length","undefined","split","getServerUtils","page","i18n","basePath","rewrites","pageIsDynamic","trailingSlash","caseSensitive","dynamicRouteMatcher","prefixRouteKeys","handleRewrites","parsedUrl","rewrittenParsedUrl","structuredClone","rewriteParams","fsPathname","matchesPage","fsPathnameNoSlash","checkRewrite","rewrite","matcher","source","removeUnnamedParams","strict","sensitive","has","missing","hasParams","assign","parsedDestination","destQuery","appendParamsToQuery","destination","protocol","replace","RegExp","result","locales","nextInternalLocale","detectedLocale","dynamicParams","beforeFiles","finished","afterFiles","fallback","getParamsFromRouteMatches","routeMatchesHeader","routeKeys","re","exec","str","obj","fromEntries","URLSearchParams","entries","normalizedKey","keyName","paramName","group","pos","routeMatches","normalizeQueryParams","routeParamKeys","add","getPreviouslyRevalidatedTags","headers","previewModeId"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5322, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/request-meta.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { BaseNextRequest } from './base-http'\nimport type { CloneableBody } from './body-streams'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport type {\n  ResponseCacheEntry,\n  ServerComponentsHmrCache,\n} from './response-cache'\nimport type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'\nimport type { OpaqueFallbackRouteParams } from './request/fallback-params'\nimport type { IncrementalCache } from './lib/incremental-cache'\n\n// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n  [NEXT_REQUEST_META]?: RequestMeta\n}\n\n/**\n * The callback function to call when a response cache entry was generated or\n * looked up in the cache. When it returns true, the server assumes that the\n * handler has already responded to the request and will not do so itself.\n */\nexport type OnCacheEntryHandler = (\n  /**\n   * The response cache entry that was generated or looked up in the cache.\n   */\n  cacheEntry: ResponseCacheEntry,\n\n  /**\n   * The request metadata.\n   */\n  requestMeta: {\n    /**\n     * The URL that was used to make the request.\n     */\n    url: string | undefined\n  }\n) => Promise<boolean | void> | boolean | void\n\nexport interface RequestMeta {\n  /**\n   * The query that was used to make the request.\n   */\n  initQuery?: ParsedUrlQuery\n\n  /**\n   * The URL that was used to make the request.\n   */\n  initURL?: string\n\n  /**\n   * The protocol that was used to make the request.\n   */\n  initProtocol?: string\n\n  /**\n   * The body that was read from the request. This is used to allow the body to\n   * be read multiple times.\n   */\n  clonableBody?: CloneableBody\n\n  /**\n   * True when the request matched a locale domain that was configured in the\n   * next.config.js file.\n   */\n  isLocaleDomain?: boolean\n\n  /**\n   * True when the request had locale information stripped from the pathname\n   * part of the URL.\n   */\n  didStripLocale?: boolean\n\n  /**\n   * If the request had it's URL rewritten, this is the URL it was rewritten to.\n   */\n  rewroteURL?: string\n\n  /**\n   * The cookies that were added by middleware and were added to the response.\n   */\n  middlewareCookie?: string[]\n\n  /**\n   * The match on the request for a given route.\n   */\n  match?: RouteMatch\n\n  /**\n   * The incremental cache to use for the request.\n   */\n  incrementalCache?: IncrementalCache\n\n  /**\n   * The server components HMR cache, only for dev.\n   */\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  /**\n   * Equals the segment path that was used for the prefetch RSC request.\n   */\n  segmentPrefetchRSCRequest?: string\n\n  /**\n   * True when the request is for the prefetch flight data.\n   */\n  isPrefetchRSCRequest?: true\n\n  /**\n   * True when the request is for the flight data.\n   */\n  isRSCRequest?: true\n\n  /**\n   * A search param set by the Next.js client when performing RSC requests.\n   * Because some CDNs do not vary their cache entries on our custom headers,\n   * this search param represents a hash of the header values. For any cached\n   * RSC request, we should verify that the hash matches before responding.\n   * Otherwise this can lead to cache poisoning.\n   * TODO: Consider not using custom request headers at all, and instead encode\n   * everything into the search param.\n   */\n  cacheBustingSearchParam?: string\n\n  /**\n   * True when the request is for the `/_next/data` route using the pages\n   * router.\n   */\n  isNextDataReq?: true\n\n  /**\n   * Postponed state to use for resumption. If present it's assumed that the\n   * request is for a page that has postponed (there are no guarantees that the\n   * page actually has postponed though as it would incur an additional cache\n   * lookup).\n   */\n  postponed?: string\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   *\n   * @deprecated Use `onCacheEntryV2` instead.\n   */\n  onCacheEntry?: OnCacheEntryHandler\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   */\n  onCacheEntryV2?: OnCacheEntryHandler\n\n  /**\n   * The previous revalidate before rendering 404 page for notFound: true\n   */\n  notFoundRevalidate?: number | false\n\n  /**\n   * In development, the original source page that returned a 404.\n   */\n  developmentNotFoundSourcePage?: string\n\n  /**\n   * The path we routed to and should be invoked\n   */\n  invokePath?: string\n\n  /**\n   * The specific page output we should be matching\n   */\n  invokeOutput?: string\n\n  /**\n   * The status we are invoking the request with from routing\n   */\n  invokeStatus?: number\n\n  /**\n   * The routing error we are invoking with\n   */\n  invokeError?: Error\n\n  /**\n   * The query parsed for the invocation\n   */\n  invokeQuery?: Record<string, undefined | string | string[]>\n\n  /**\n   * Whether the request is a middleware invocation\n   */\n  middlewareInvoke?: boolean\n\n  /**\n   * Whether the request should render the fallback shell or not.\n   */\n  renderFallbackShell?: boolean\n\n  /**\n   * Whether the request is for the custom error page.\n   */\n  customErrorRender?: true\n\n  /**\n   * Whether to bubble up the NoFallbackError to the caller when a 404 is\n   * returned.\n   */\n  bubbleNoFallback?: true\n\n  /**\n   * True when the request had locale information inferred from the default\n   * locale.\n   */\n  localeInferredFromDefault?: true\n\n  /**\n   * The locale that was inferred or explicitly set for the request.\n   */\n  locale?: string\n\n  /**\n   * The default locale that was inferred or explicitly set for the request.\n   */\n  defaultLocale?: string\n\n  /**\n   * The relative project dir the server is running in from project root\n   */\n  relativeProjectDir?: string\n\n  /**\n   * The dist directory the server is currently using\n   */\n  distDir?: string\n\n  /**\n   * The query after resolving routes\n   */\n  query?: ParsedUrlQuery\n\n  /**\n   * The params after resolving routes\n   */\n  params?: ParsedUrlQuery\n\n  /**\n   * ErrorOverlay component to use in development for pages router\n   */\n  PagesErrorDebug?: PagesDevOverlayBridgeType\n\n  /**\n   * Whether server is in minimal mode (this will be replaced with more\n   * specific flags in future)\n   */\n  minimalMode?: boolean\n\n  /**\n   * DEV only: The fallback params that should be used when validating prerenders during dev\n   */\n  devFallbackParams?: OpaqueFallbackRouteParams\n\n  /**\n   * DEV only: Request timings in process.hrtime.bigint()\n   */\n  devRequestTimingStart?: bigint\n  devRequestTimingMiddlewareStart?: bigint\n  devRequestTimingMiddlewareEnd?: bigint\n  devRequestTimingInternalsEnd?: bigint\n\n  /**\n   * DEV only: The duration of getStaticPaths/generateStaticParams in process.hrtime.bigint()\n   */\n  devGenerateStaticParamsDuration?: bigint\n}\n\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport function getRequestMeta(\n  req: NextIncomingMessage,\n  key?: undefined\n): RequestMeta\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key: K\n): RequestMeta[K]\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key?: K\n): RequestMeta | RequestMeta[K] {\n  const meta = req[NEXT_REQUEST_META] || {}\n  return typeof key === 'string' ? meta[key] : meta\n}\n\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {\n  req[NEXT_REQUEST_META] = meta\n  return meta\n}\n\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport function addRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K,\n  value: RequestMeta[K]\n) {\n  const meta = getRequestMeta(request)\n  meta[key] = value\n  return setRequestMeta(request, meta)\n}\n\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport function removeRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K\n) {\n  const meta = getRequestMeta(request)\n  delete meta[key]\n  return setRequestMeta(request, meta)\n}\n\ntype NextQueryMetadata = {\n  /**\n   * The `_rsc` query parameter used for cache busting to ensure that the RSC\n   * requests do not get cached by the browser explicitly.\n   */\n  [NEXT_RSC_UNION_QUERY]?: string\n}\n\nexport type NextParsedUrlQuery = ParsedUrlQuery & NextQueryMetadata\n\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n  query: NextParsedUrlQuery\n}\n"],"names":["NEXT_REQUEST_META","Symbol","for","getRequestMeta","req","key","meta","setRequestMeta","addRequestMeta","request","value","removeRequestMeta"],"mappings":"AAeA,kGAAkG;;;;;;;;;;;;;AAC3F,MAAMA,oBAAoBC,OAAOC,GAAG,CAAC,2BAA0B;AAuR/D,SAASC,eACdC,GAAwB,EACxBC,GAAO;IAEP,MAAMC,OAAOF,GAAG,CAACJ,kBAAkB,IAAI,CAAC;IACxC,OAAO,OAAOK,QAAQ,WAAWC,IAAI,CAACD,IAAI,GAAGC;AAC/C;AASO,SAASC,eAAeH,GAAwB,EAAEE,IAAiB;IACxEF,GAAG,CAACJ,kBAAkB,GAAGM;IACzB,OAAOA;AACT;AAUO,SAASE,eACdC,OAA4B,EAC5BJ,GAAM,EACNK,KAAqB;IAErB,MAAMJ,OAAOH,eAAeM;IAC5BH,IAAI,CAACD,IAAI,GAAGK;IACZ,OAAOH,eAAeE,SAASH;AACjC;AASO,SAASK,kBACdF,OAA4B,EAC5BJ,GAAM;IAEN,MAAMC,OAAOH,eAAeM;IAC5B,OAAOH,IAAI,CAACD,IAAI;IAChB,OAAOE,eAAeE,SAASH;AACjC","ignoreList":[0]}},
    {"offset": {"line": 5358, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/client-component-renderer-logger.ts"],"sourcesContent":["import type { AppPageModule } from './route-modules/app-page/module'\n\n// Combined load times for loading client components\nlet clientComponentLoadStart = 0\nlet clientComponentLoadTimes = 0\nlet clientComponentLoadCount = 0\n\nexport function wrapClientComponentLoader(\n  ComponentMod: AppPageModule\n): AppPageModule['__next_app__'] {\n  if (!('performance' in globalThis)) {\n    return ComponentMod.__next_app__\n  }\n\n  return {\n    require: (...args) => {\n      const startTime = performance.now()\n\n      if (clientComponentLoadStart === 0) {\n        clientComponentLoadStart = startTime\n      }\n\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.require(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n    loadChunk: (...args) => {\n      const startTime = performance.now()\n      const result = ComponentMod.__next_app__.loadChunk(...args)\n      // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\n      // We only need to know when it's settled.\n      result.finally(() => {\n        clientComponentLoadTimes += performance.now() - startTime\n      })\n      return result\n    },\n  }\n}\n\nexport function getClientComponentLoaderMetrics(\n  options: { reset?: boolean } = {}\n) {\n  const metrics =\n    clientComponentLoadStart === 0\n      ? undefined\n      : {\n          clientComponentLoadStart,\n          clientComponentLoadTimes,\n          clientComponentLoadCount,\n        }\n\n  if (options.reset) {\n    clientComponentLoadStart = 0\n    clientComponentLoadTimes = 0\n    clientComponentLoadCount = 0\n  }\n\n  return metrics\n}\n"],"names":["clientComponentLoadStart","clientComponentLoadTimes","clientComponentLoadCount","wrapClientComponentLoader","ComponentMod","globalThis","__next_app__","require","args","startTime","performance","now","loadChunk","result","finally","getClientComponentLoaderMetrics","options","metrics","undefined","reset"],"mappings":";;;;;;AAEA,oDAAoD;AACpD,IAAIA,2BAA2B;AAC/B,IAAIC,2BAA2B;AAC/B,IAAIC,2BAA2B;AAExB,SAASC,0BACdC,YAA2B;IAE3B,IAAI,CAAE,CAAA,iBAAiBC,UAAS,GAAI;QAClC,OAAOD,aAAaE,YAAY;IAClC;IAEA,OAAO;QACLC,SAAS,CAAC,GAAGC;YACX,MAAMC,YAAYC,YAAYC,GAAG;YAEjC,IAAIX,6BAA6B,GAAG;gBAClCA,2BAA2BS;YAC7B;YAEA,IAAI;gBACFP,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACC,OAAO,IAAIC;YAC9C,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;QACAG,WAAW,CAAC,GAAGJ;YACb,MAAMC,YAAYC,YAAYC,GAAG;YACjC,MAAME,SAAST,aAAaE,YAAY,CAACM,SAAS,IAAIJ;YACtD,gHAAgH;YAChH,0CAA0C;YAC1CK,OAAOC,OAAO,CAAC;gBACbb,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;YACA,OAAOI;QACT;IACF;AACF;AAEO,SAASE,gCACdC,UAA+B,CAAC,CAAC;IAEjC,MAAMC,UACJjB,6BAA6B,IACzBkB,YACA;QACElB;QACAC;QACAC;IACF;IAEN,IAAIc,QAAQG,KAAK,EAAE;QACjBnB,2BAA2B;QAC3BC,2BAA2B;QAC3BC,2BAA2B;IAC7B;IAEA,OAAOe;AACT","ignoreList":[0]}},
    {"offset": {"line": 5414, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/pipe-readable.ts"],"sourcesContent":["import type { ServerResponse } from 'node:http'\n\nimport {\n  ResponseAbortedName,\n  createAbortController,\n} from './web/spec-extension/adapters/next-request'\nimport { DetachedPromise } from '../lib/detached-promise'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger'\n\nexport function isAbortError(e: any): e is Error & { name: 'AbortError' } {\n  return e?.name === 'AbortError' || e?.name === ResponseAbortedName\n}\n\nfunction createWriterFromResponse(\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n): WritableStream<Uint8Array> {\n  let started = false\n\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new DetachedPromise<void>()\n  function onDrain() {\n    drained.resolve()\n  }\n  res.on('drain', onDrain)\n\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once('close', () => {\n    res.off('drain', onDrain)\n    drained.resolve()\n  })\n\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new DetachedPromise<void>()\n  res.once('finish', () => {\n    finished.resolve()\n  })\n\n  // Create a writable stream that will write to the response.\n  return new WritableStream<Uint8Array>({\n    write: async (chunk) => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true\n\n        if (\n          'performance' in globalThis &&\n          process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n        ) {\n          const metrics = getClientComponentLoaderMetrics()\n          if (metrics) {\n            performance.measure(\n              `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,\n              {\n                start: metrics.clientComponentLoadStart,\n                end:\n                  metrics.clientComponentLoadStart +\n                  metrics.clientComponentLoadTimes,\n              }\n            )\n          }\n        }\n\n        res.flushHeaders()\n        getTracer().trace(\n          NextNodeServerSpan.startResponse,\n          {\n            spanName: 'start response',\n          },\n          () => undefined\n        )\n      }\n\n      try {\n        const ok = res.write(chunk)\n\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if ('flush' in res && typeof res.flush === 'function') {\n          res.flush()\n        }\n\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise\n\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new DetachedPromise<void>()\n        }\n      } catch (err) {\n        res.end()\n        throw new Error('failed to write chunk to response', { cause: err })\n      }\n    },\n    abort: (err) => {\n      if (res.writableFinished) return\n\n      res.destroy(err)\n    },\n    close: async () => {\n      // if a waitUntil promise was passed, wait for it to resolve before\n      // ending the response.\n      if (waitUntilForEnd) {\n        await waitUntilForEnd\n      }\n\n      if (res.writableFinished) return\n\n      res.end()\n      return finished.promise\n    },\n  })\n}\n\nexport async function pipeToNodeResponse(\n  readable: ReadableStream<Uint8Array>,\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n) {\n  try {\n    // If the response has already errored, then just return now.\n    const { errored, destroyed } = res\n    if (errored || destroyed) return\n\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = createAbortController(res)\n\n    const writer = createWriterFromResponse(res, waitUntilForEnd)\n\n    await readable.pipeTo(writer, { signal: controller.signal })\n  } catch (err: any) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return\n\n    throw new Error('failed to pipe response', { cause: err })\n  }\n}\n"],"names":["ResponseAbortedName","createAbortController","DetachedPromise","getTracer","NextNodeServerSpan","getClientComponentLoaderMetrics","isAbortError","e","name","createWriterFromResponse","res","waitUntilForEnd","started","drained","onDrain","resolve","on","once","off","finished","WritableStream","write","chunk","globalThis","process","env","NEXT_OTEL_PERFORMANCE_PREFIX","metrics","performance","measure","start","clientComponentLoadStart","end","clientComponentLoadTimes","flushHeaders","trace","startResponse","spanName","undefined","ok","flush","promise","err","Error","cause","abort","writableFinished","destroy","close","pipeToNodeResponse","readable","errored","destroyed","controller","writer","pipeTo","signal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5545, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/render-result.ts"],"sourcesContent":["import type { OutgoingHttpHeaders, ServerResponse } from 'http'\nimport type { CacheControl } from './lib/cache-control'\nimport type { FetchMetrics } from './base-http'\n\nimport {\n  chainStreams,\n  streamFromBuffer,\n  streamFromString,\n  streamToString,\n} from './stream-utils/node-web-streams-helper'\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable'\nimport type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport type {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  TEXT_PLAIN_CONTENT_TYPE_HEADER,\n} from '../lib/constants'\nimport type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'\n\ntype ContentTypeOption =\n  | typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses\n  | typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses\n  | typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests\n  | typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors\n\nexport type AppPageRenderResultMetadata = {\n  flightData?: Buffer\n  cacheControl?: CacheControl\n  staticBailoutInfo?: {\n    stack?: string\n    description?: string\n  }\n\n  /**\n   * The postponed state if the render had postponed and needs to be resumed.\n   */\n  postponed?: string\n\n  /**\n   * The headers to set on the response that were added by the render.\n   */\n  headers?: OutgoingHttpHeaders\n  statusCode?: number\n  fetchTags?: string\n  fetchMetrics?: FetchMetrics\n\n  segmentData?: Map<string, Buffer>\n\n  /**\n   * In development, the resume data cache is warmed up before the render. This\n   * is attached to the metadata so that it can be used during the render. When\n   * prerendering, the filled resume data cache is also attached to the metadata\n   * so that it can be used when prerendering matching fallback shells.\n   */\n  renderResumeDataCache?: RenderResumeDataCache\n}\n\nexport type PagesRenderResultMetadata = {\n  pageData?: any\n  cacheControl?: CacheControl\n  assetQueryString?: string\n  isNotFound?: boolean\n  isRedirect?: boolean\n}\n\nexport type StaticRenderResultMetadata = {}\n\nexport type RenderResultMetadata = AppPageRenderResultMetadata &\n  PagesRenderResultMetadata &\n  StaticRenderResultMetadata\n\nexport type RenderResultResponse =\n  | ReadableStream<Uint8Array>[]\n  | ReadableStream<Uint8Array>\n  | string\n  | Buffer\n  | null\n\nexport type RenderResultOptions<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> = {\n  contentType: ContentTypeOption | null\n  waitUntil?: Promise<unknown>\n  metadata: Metadata\n}\n\nexport default class RenderResult<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> {\n  /**\n   * The detected content type for the response. This is used to set the\n   * `Content-Type` header.\n   */\n  public readonly contentType: ContentTypeOption | null\n\n  /**\n   * The metadata for the response. This is used to set the revalidation times\n   * and other metadata.\n   */\n  public readonly metadata: Readonly<Metadata>\n\n  /**\n   * The response itself. This can be a string, a stream, or null. If it's a\n   * string, then it's a static response. If it's a stream, then it's a\n   * dynamic response. If it's null, then the response was not found or was\n   * already sent.\n   */\n  private response: RenderResultResponse\n\n  /**\n   * A render result that represents an empty response. This is used to\n   * represent a response that was not found or was already sent.\n   */\n  public static readonly EMPTY = new RenderResult<StaticRenderResultMetadata>(\n    null,\n    { metadata: {}, contentType: null }\n  )\n\n  /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @param contentType the content type of the response\n   * @returns a new RenderResult instance\n   */\n  public static fromStatic(\n    value: string | Buffer,\n    contentType: ContentTypeOption\n  ) {\n    return new RenderResult<StaticRenderResultMetadata>(value, {\n      metadata: {},\n      contentType,\n    })\n  }\n\n  private readonly waitUntil?: Promise<unknown>\n\n  constructor(\n    response: RenderResultResponse,\n    { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>\n  ) {\n    this.response = response\n    this.contentType = contentType\n    this.metadata = metadata\n    this.waitUntil = waitUntil\n  }\n\n  public assignMetadata(metadata: Metadata) {\n    Object.assign(this.metadata, metadata)\n  }\n\n  /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */\n  public get isNull(): boolean {\n    return this.response === null\n  }\n\n  /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */\n  public get isDynamic(): boolean {\n    return typeof this.response !== 'string'\n  }\n\n  /**\n   * Returns the response if it is a string. If the page was dynamic, this will\n   * return a promise if the `stream` option is true, or it will throw an error.\n   *\n   * @param stream Whether or not to return a promise if the response is dynamic\n   * @returns The response as a string\n   */\n  public toUnchunkedString(stream?: false): string\n  public toUnchunkedString(stream: true): Promise<string>\n  public toUnchunkedString(stream = false): Promise<string> | string {\n    if (this.response === null) {\n      // If the response is null, return an empty string. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return ''\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new InvariantError(\n          'dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToString(this.readable)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Returns a readable stream of the response.\n   */\n  private get readable(): ReadableStream<Uint8Array> {\n    if (this.response === null) {\n      // If the response is null, return an empty stream. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return new ReadableStream<Uint8Array>({\n        start(controller) {\n          controller.close()\n        },\n      })\n    }\n\n    if (typeof this.response === 'string') {\n      return streamFromString(this.response)\n    }\n\n    if (Buffer.isBuffer(this.response)) {\n      return streamFromBuffer(this.response)\n    }\n\n    // If the response is an array of streams, then chain them together.\n    if (Array.isArray(this.response)) {\n      return chainStreams(...this.response)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Coerces the response to an array of streams. This will convert the response\n   * to an array of streams if it is not already one.\n   *\n   * @returns An array of streams\n   */\n  private coerce(): ReadableStream<Uint8Array>[] {\n    if (this.response === null) {\n      // If the response is null, return an empty stream. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return []\n    }\n\n    if (typeof this.response === 'string') {\n      return [streamFromString(this.response)]\n    } else if (Array.isArray(this.response)) {\n      return this.response\n    } else if (Buffer.isBuffer(this.response)) {\n      return [streamFromBuffer(this.response)]\n    } else {\n      return [this.response]\n    }\n  }\n\n  /**\n   * Unshifts a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the start of the array. When this response is piped, all of the streams\n   * will be piped one after the other.\n   *\n   * @param readable The new stream to unshift\n   */\n  public unshift(readable: ReadableStream<Uint8Array>): void {\n    // Coerce the response to an array of streams.\n    this.response = this.coerce()\n\n    // Add the new stream to the start of the array.\n    this.response.unshift(readable)\n  }\n\n  /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */\n  public push(readable: ReadableStream<Uint8Array>): void {\n    // Coerce the response to an array of streams.\n    this.response = this.coerce()\n\n    // Add the new stream to the end of the array.\n    this.response.push(readable)\n  }\n\n  /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */\n  public async pipeTo(writable: WritableStream<Uint8Array>): Promise<void> {\n    try {\n      await this.readable.pipeTo(writable, {\n        // We want to close the writable stream ourselves so that we can wait\n        // for the waitUntil promise to resolve before closing it. If an error\n        // is encountered, we'll abort the writable stream if we swallowed the\n        // error.\n        preventClose: true,\n      })\n\n      // If there is a waitUntil promise, wait for it to resolve before\n      // closing the writable stream.\n      if (this.waitUntil) await this.waitUntil\n\n      // Close the writable stream.\n      await writable.close()\n    } catch (err) {\n      // If this is an abort error, we should abort the writable stream (as we\n      // took ownership of it when we started piping). We don't need to re-throw\n      // because we handled the error.\n      if (isAbortError(err)) {\n        // Abort the writable stream if an error is encountered.\n        await writable.abort(err)\n\n        return\n      }\n\n      // We're not aborting the writer here as when this method throws it's not\n      // clear as to how so the caller should assume it's their responsibility\n      // to clean up the writer.\n      throw err\n    }\n  }\n\n  /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */\n  public async pipeToNodeResponse(res: ServerResponse) {\n    await pipeToNodeResponse(this.readable, res, this.waitUntil)\n  }\n}\n"],"names":["chainStreams","streamFromBuffer","streamFromString","streamToString","isAbortError","pipeToNodeResponse","InvariantError","RenderResult","EMPTY","metadata","contentType","fromStatic","value","constructor","response","waitUntil","assignMetadata","Object","assign","isNull","isDynamic","toUnchunkedString","stream","readable","ReadableStream","start","controller","close","Buffer","isBuffer","Array","isArray","coerce","unshift","push","pipeTo","writable","preventClose","err","abort","res"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5740, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/internal-utils.ts"],"sourcesContent":["import type { NextParsedUrlQuery } from './request-meta'\n\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n\nconst INTERNAL_QUERY_NAMES = [NEXT_RSC_UNION_QUERY] as const\n\nexport function stripInternalQueries(query: NextParsedUrlQuery) {\n  for (const name of INTERNAL_QUERY_NAMES) {\n    delete query[name]\n  }\n}\n\nexport function stripInternalSearchParams<T extends string | URL>(url: T): T {\n  const isStringUrl = typeof url === 'string'\n  const instance = isStringUrl ? new URL(url) : (url as URL)\n\n  instance.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  return (isStringUrl ? instance.toString() : instance) as T\n}\n"],"names":["NEXT_RSC_UNION_QUERY","INTERNAL_QUERY_NAMES","stripInternalQueries","query","name","stripInternalSearchParams","url","isStringUrl","instance","URL","searchParams","delete","toString"],"mappings":";;;;;;AAEA,SAASA,oBAAoB,QAAQ,0CAAyC;;AAE9E,MAAMC,uBAAuB;IAACD,sOAAAA;CAAqB;AAE5C,SAASE,qBAAqBC,KAAyB;IAC5D,KAAK,MAAMC,QAAQH,qBAAsB;QACvC,OAAOE,KAAK,CAACC,KAAK;IACpB;AACF;AAEO,SAASC,0BAAkDC,GAAM;IACtE,MAAMC,cAAc,OAAOD,QAAQ;IACnC,MAAME,WAAWD,cAAc,IAAIE,IAAIH,OAAQA;IAE/CE,SAASE,YAAY,CAACC,MAAM,CAACX,sOAAAA;IAE7B,OAAQO,cAAcC,SAASI,QAAQ,KAAKJ;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 5766, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/revalidation-utils.ts"],"sourcesContent":["import type { WorkStore } from './app-render/work-async-storage.external'\nimport type { IncrementalCache } from './lib/incremental-cache'\nimport { getCacheHandlers } from './use-cache/handlers'\n\n/** Run a callback, and execute any *new* revalidations added during its runtime. */\nexport async function withExecuteRevalidates<T>(\n  store: WorkStore | undefined,\n  callback: () => Promise<T>\n): Promise<T> {\n  if (!store) {\n    return callback()\n  }\n  // If we executed any revalidates during the request, then we don't want to execute them again.\n  // save the state so we can check if anything changed after we're done running callbacks.\n  const savedRevalidationState = cloneRevalidationState(store)\n  try {\n    return await callback()\n  } finally {\n    // Check if we have any new revalidates, and if so, wait until they are all resolved.\n    const newRevalidates = diffRevalidationState(\n      savedRevalidationState,\n      cloneRevalidationState(store)\n    )\n    await executeRevalidates(store, newRevalidates)\n  }\n}\n\ntype RevalidationState = Required<\n  Pick<\n    WorkStore,\n    'pendingRevalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n  >\n>\n\nfunction cloneRevalidationState(store: WorkStore): RevalidationState {\n  return {\n    pendingRevalidatedTags: store.pendingRevalidatedTags\n      ? [...store.pendingRevalidatedTags]\n      : [],\n    pendingRevalidates: { ...store.pendingRevalidates },\n    pendingRevalidateWrites: store.pendingRevalidateWrites\n      ? [...store.pendingRevalidateWrites]\n      : [],\n  }\n}\n\nfunction diffRevalidationState(\n  prev: RevalidationState,\n  curr: RevalidationState\n): RevalidationState {\n  const prevTagsWithProfile = new Set(\n    prev.pendingRevalidatedTags.map((item) => {\n      const profileKey =\n        typeof item.profile === 'object'\n          ? JSON.stringify(item.profile)\n          : item.profile || ''\n      return `${item.tag}:${profileKey}`\n    })\n  )\n  const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n  return {\n    pendingRevalidatedTags: curr.pendingRevalidatedTags.filter((item) => {\n      const profileKey =\n        typeof item.profile === 'object'\n          ? JSON.stringify(item.profile)\n          : item.profile || ''\n      return !prevTagsWithProfile.has(`${item.tag}:${profileKey}`)\n    }),\n    pendingRevalidates: Object.fromEntries(\n      Object.entries(curr.pendingRevalidates).filter(\n        ([key]) => !(key in prev.pendingRevalidates)\n      )\n    ),\n    pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(\n      (promise) => !prevRevalidateWrites.has(promise)\n    ),\n  }\n}\n\nasync function revalidateTags(\n  tagsWithProfile: Array<{\n    tag: string\n    profile?: string | { expire?: number }\n  }>,\n  incrementalCache: IncrementalCache | undefined,\n  workStore?: WorkStore\n): Promise<void> {\n  if (tagsWithProfile.length === 0) {\n    return\n  }\n\n  const handlers = getCacheHandlers()\n  const promises: Promise<void>[] = []\n\n  // Group tags by profile for batch processing\n  const tagsByProfile = new Map<\n    | string\n    | { stale?: number; revalidate?: number; expire?: number }\n    | undefined,\n    string[]\n  >()\n\n  for (const item of tagsWithProfile) {\n    const profile = item.profile\n    // Find existing profile by comparing values\n    let existingKey = undefined\n    for (const [key] of tagsByProfile) {\n      if (\n        typeof key === 'string' &&\n        typeof profile === 'string' &&\n        key === profile\n      ) {\n        existingKey = key\n        break\n      }\n      if (\n        typeof key === 'object' &&\n        typeof profile === 'object' &&\n        JSON.stringify(key) === JSON.stringify(profile)\n      ) {\n        existingKey = key\n        break\n      }\n      if (key === profile) {\n        existingKey = key\n        break\n      }\n    }\n\n    const profileKey = existingKey || profile\n    if (!tagsByProfile.has(profileKey)) {\n      tagsByProfile.set(profileKey, [])\n    }\n    tagsByProfile.get(profileKey)!.push(item.tag)\n  }\n\n  // Process each profile group\n  for (const [profile, tagsForProfile] of tagsByProfile) {\n    // Look up the cache profile from workStore if available\n    let durations: { expire?: number } | undefined\n\n    if (profile) {\n      let cacheLife:\n        | { stale?: number; revalidate?: number; expire?: number }\n        | undefined\n\n      if (typeof profile === 'object') {\n        // Profile is already a cacheLife configuration object\n        cacheLife = profile\n      } else if (typeof profile === 'string') {\n        // Profile is a string key, look it up in workStore\n        cacheLife = workStore?.cacheLifeProfiles?.[profile]\n\n        if (!cacheLife) {\n          throw new Error(\n            `Invalid profile provided \"${profile}\" must be configured under cacheLife in next.config or be \"max\"`\n          )\n        }\n      }\n\n      if (cacheLife) {\n        durations = {\n          expire: cacheLife.expire,\n        }\n      }\n    }\n    // If profile is not found and not 'max', durations will be undefined\n    // which will trigger immediate expiration in the cache handler\n\n    for (const handler of handlers || []) {\n      if (profile) {\n        promises.push(handler.updateTags?.(tagsForProfile, durations))\n      } else {\n        promises.push(handler.updateTags?.(tagsForProfile))\n      }\n    }\n\n    if (incrementalCache) {\n      promises.push(incrementalCache.revalidateTag(tagsForProfile, durations))\n    }\n  }\n\n  await Promise.all(promises)\n}\n\nexport async function executeRevalidates(\n  workStore: WorkStore,\n  state?: RevalidationState\n) {\n  const pendingRevalidatedTags =\n    state?.pendingRevalidatedTags ?? workStore.pendingRevalidatedTags ?? []\n\n  const pendingRevalidates =\n    state?.pendingRevalidates ?? workStore.pendingRevalidates ?? {}\n\n  const pendingRevalidateWrites =\n    state?.pendingRevalidateWrites ?? workStore.pendingRevalidateWrites ?? []\n\n  return Promise.all([\n    revalidateTags(\n      pendingRevalidatedTags,\n      workStore.incrementalCache,\n      workStore\n    ),\n    ...Object.values(pendingRevalidates),\n    ...pendingRevalidateWrites,\n  ])\n}\n"],"names":["getCacheHandlers","withExecuteRevalidates","store","callback","savedRevalidationState","cloneRevalidationState","newRevalidates","diffRevalidationState","executeRevalidates","pendingRevalidatedTags","pendingRevalidates","pendingRevalidateWrites","prev","curr","prevTagsWithProfile","Set","map","item","profileKey","profile","JSON","stringify","tag","prevRevalidateWrites","filter","has","Object","fromEntries","entries","key","promise","revalidateTags","tagsWithProfile","incrementalCache","workStore","length","handlers","promises","tagsByProfile","Map","existingKey","undefined","set","get","push","tagsForProfile","durations","cacheLife","cacheLifeProfiles","Error","expire","handler","updateTags","revalidateTag","Promise","all","state","values"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5905, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["import type { NonStaticRenderStage } from './app-render/staged-rendering'\nimport type { RequestStore } from './app-render/work-unit-async-storage.external'\n\nexport function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(\n  underlying: T,\n  requestStore: RequestStore,\n  stage: NonStaticRenderStage\n): Promise<T> {\n  if (requestStore.stagedRendering) {\n    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n    return requestStore.stagedRendering.delayUntilStage(\n      stage,\n      undefined,\n      underlying\n    )\n  }\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n"],"names":["isHangingPromiseRejectionError","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","route","expression","abortListenersBySignal","WeakMap","makeHangingPromise","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","bind","currentListeners","get","push","listeners","set","addEventListener","i","length","once","catch","ignoreReject","makeDevtoolsIOAwarePromise","underlying","requestStore","stage","stagedRendering","delayUntilStage","undefined","resolve","setTimeout"],"mappings":";;;;;;;;AAGO,SAASA,+BACdC,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YACkBC,KAAa,EACbC,UAAkB,CAClC;QACA,KAAK,CACH,CAAC,qBAAqB,EAAEA,WAAW,qGAAqG,EAAEA,WAAW,8KAA8K,EAAED,MAAM,EAAE,CAAC,GAAA,IAAA,CAJhUA,KAAAA,GAAAA,OAAAA,IAAAA,CACAC,UAAAA,GAAAA,YAAAA,IAAAA,CAJFN,MAAAA,GAASC;IASzB;AACF;AAGA,MAAMM,yBAAyB,IAAIC;AAS5B,SAASC,mBACdC,MAAmB,EACnBL,KAAa,EACbC,UAAkB;IAElB,IAAII,OAAOC,OAAO,EAAE;QAClB,OAAOC,QAAQC,MAAM,CAAC,IAAIX,6BAA6BG,OAAOC;IAChE,OAAO;QACL,MAAMQ,iBAAiB,IAAIF,QAAW,CAACG,GAAGF;YACxC,MAAMG,iBAAiBH,OAAOI,IAAI,CAChC,MACA,IAAIf,6BAA6BG,OAAOC;YAE1C,IAAIY,mBAAmBX,uBAAuBY,GAAG,CAACT;YAClD,IAAIQ,kBAAkB;gBACpBA,iBAAiBE,IAAI,CAACJ;YACxB,OAAO;gBACL,MAAMK,YAAY;oBAACL;iBAAe;gBAClCT,uBAAuBe,GAAG,CAACZ,QAAQW;gBACnCX,OAAOa,gBAAgB,CACrB,SACA;oBACE,IAAK,IAAIC,IAAI,GAAGA,IAAIH,UAAUI,MAAM,EAAED,IAAK;wBACzCH,SAAS,CAACG,EAAE;oBACd;gBACF,GACA;oBAAEE,MAAM;gBAAK;YAEjB;QACF;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzFZ,eAAea,KAAK,CAACC;QACrB,OAAOd;IACT;AACF;AAEA,SAASc,gBAAgB;AAElB,SAASC,2BACdC,UAAa,EACbC,YAA0B,EAC1BC,KAA2B;IAE3B,IAAID,aAAaE,eAAe,EAAE;QAChC,iFAAiF;QACjF,OAAOF,aAAaE,eAAe,CAACC,eAAe,CACjDF,OACAG,WACAL;IAEJ;IACA,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAIlB,QAAW,CAACwB;QACrB,sFAAsF;QACtFC,WAAW;YACTD,QAAQN;QACV,GAAG;IACL;AACF","ignoreList":[0]}},
    {"offset": {"line": 5975, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/htmlescape.ts"],"sourcesContent":["// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\nconst ESCAPE_LOOKUP: { [match: string]: string } = {\n  '&': '\\\\u0026',\n  '>': '\\\\u003e',\n  '<': '\\\\u003c',\n  '\\u2028': '\\\\u2028',\n  '\\u2029': '\\\\u2029',\n}\n\nexport const ESCAPE_REGEX = /[&><\\u2028\\u2029]/g\n\nexport function htmlEscapeJsonString(str: string): string {\n  return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match])\n}\n"],"names":["ESCAPE_LOOKUP","ESCAPE_REGEX","htmlEscapeJsonString","str","replace","match"],"mappings":";;;;;;AAAA,iEAAiE;AACjE,uGAAuG;AAEvG,MAAMA,gBAA6C;IACjD,KAAK;IACL,KAAK;IACL,KAAK;IACL,UAAU;IACV,UAAU;AACZ;AAEO,MAAMC,eAAe,qBAAoB;AAEzC,SAASC,qBAAqBC,GAAW;IAC9C,OAAOA,IAAIC,OAAO,CAACH,cAAc,CAACI,QAAUL,aAAa,CAACK,MAAM;AAClE","ignoreList":[0]}},
    {"offset": {"line": 5998, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;;AAAO,IAAWA,YAAAA,WAAAA,GAAAA,SAAAA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;WAtBeA;MAwBjB","ignoreList":[0]}},
    {"offset": {"line": 6026, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/resume-data-cache/cache-store.ts"],"sourcesContent":["import {\n  arrayBufferToString,\n  stringToUint8Array,\n} from '../app-render/encryption-utils'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CachedFetchValue } from '../response-cache/types'\nimport { DYNAMIC_EXPIRE } from '../use-cache/constants'\n\n/**\n * A generic cache store type that provides a subset of Map functionality\n */\ntype CacheStore<T> = Pick<\n  Map<string, T>,\n  'entries' | 'keys' | 'size' | 'get' | 'set'\n>\n\n/**\n * A cache store specifically for fetch cache values\n */\nexport type FetchCacheStore = CacheStore<CachedFetchValue>\n\n/**\n * A cache store for encrypted bound args of inline server functions.\n */\nexport type EncryptedBoundArgsCacheStore = CacheStore<string>\n\n/**\n * An in-memory-only cache store for decrypted bound args of inline server\n * functions.\n */\nexport type DecryptedBoundArgsCacheStore = CacheStore<string>\n\n/**\n * Serialized format for \"use cache\" entries\n */\nexport interface UseCacheCacheStoreSerialized {\n  value: string\n  tags: string[]\n  stale: number\n  timestamp: number\n  expire: number\n  revalidate: number\n}\n\n/**\n * A cache store specifically for \"use cache\" values that stores promises of\n * cache entries.\n */\nexport type UseCacheCacheStore = CacheStore<Promise<CacheEntry>>\n\n/**\n * Parses serialized cache entries into a UseCacheCacheStore\n * @param entries - The serialized entries to parse\n * @returns A new UseCacheCacheStore containing the parsed entries\n */\nexport function parseUseCacheCacheStore(\n  entries: Iterable<[string, UseCacheCacheStoreSerialized]>\n): UseCacheCacheStore {\n  const store = new Map<string, Promise<CacheEntry>>()\n\n  for (const [\n    key,\n    { value, tags, stale, timestamp, expire, revalidate },\n  ] of entries) {\n    store.set(\n      key,\n      Promise.resolve({\n        // Create a ReadableStream from the Uint8Array\n        value: new ReadableStream<Uint8Array>({\n          start(controller) {\n            // Enqueue the Uint8Array to the stream\n            controller.enqueue(stringToUint8Array(atob(value)))\n\n            // Close the stream\n            controller.close()\n          },\n        }),\n        tags,\n        stale,\n        timestamp,\n        expire,\n        revalidate,\n      })\n    )\n  }\n\n  return store\n}\n\n/**\n * Serializes UseCacheCacheStore entries into an array of key-value pairs\n * @param entries - The store entries to stringify\n * @returns A promise that resolves to an array of key-value pairs with serialized values\n */\nexport async function serializeUseCacheCacheStore(\n  entries: IterableIterator<[string, Promise<CacheEntry>]>,\n  isCacheComponentsEnabled: boolean\n): Promise<Array<[string, UseCacheCacheStoreSerialized] | null>> {\n  return Promise.all(\n    Array.from(entries).map(([key, value]) => {\n      return value\n        .then(async (entry) => {\n          if (\n            isCacheComponentsEnabled &&\n            (entry.revalidate === 0 || entry.expire < DYNAMIC_EXPIRE)\n          ) {\n            // The entry was omitted from the prerender result, and subsequently\n            // does not need to be included in the serialized RDC.\n            return null\n          }\n\n          const [left, right] = entry.value.tee()\n          entry.value = right\n\n          let binaryString: string = ''\n\n          // We want to encode the value as a string, but we aren't sure if the\n          // value is a a stream of UTF-8 bytes or not, so let's just encode it\n          // as a string using base64.\n          for await (const chunk of left) {\n            binaryString += arrayBufferToString(chunk)\n          }\n\n          return [\n            key,\n            {\n              // Encode the value as a base64 string.\n              value: btoa(binaryString),\n              tags: entry.tags,\n              stale: entry.stale,\n              timestamp: entry.timestamp,\n              expire: entry.expire,\n              revalidate: entry.revalidate,\n            },\n          ] satisfies [string, UseCacheCacheStoreSerialized]\n        })\n        .catch(() => {\n          // Any failed cache writes should be ignored as to not discard the\n          // entire cache.\n          return null\n        })\n    })\n  )\n}\n"],"names":["arrayBufferToString","stringToUint8Array","DYNAMIC_EXPIRE","parseUseCacheCacheStore","entries","store","Map","key","value","tags","stale","timestamp","expire","revalidate","set","Promise","resolve","ReadableStream","start","controller","enqueue","atob","close","serializeUseCacheCacheStore","isCacheComponentsEnabled","all","Array","from","map","then","entry","left","right","tee","binaryString","chunk","btoa","catch"],"mappings":";;;;;;AAAA,SACEA,mBAAmB,EACnBC,kBAAkB,QACb,iCAAgC;AAGvC,SAASC,cAAc,QAAQ,yBAAwB;;;AAiDhD,SAASC,wBACdC,OAAyD;IAEzD,MAAMC,QAAQ,IAAIC;IAElB,KAAK,MAAM,CACTC,KACA,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,SAAS,EAAEC,MAAM,EAAEC,UAAU,EAAE,CACtD,IAAIT,QAAS;QACZC,MAAMS,GAAG,CACPP,KACAQ,QAAQC,OAAO,CAAC;YACd,8CAA8C;YAC9CR,OAAO,IAAIS,eAA2B;gBACpCC,OAAMC,UAAU;oBACd,uCAAuC;oBACvCA,WAAWC,OAAO,KAACnB,kOAAAA,EAAmBoB,KAAKb;oBAE3C,mBAAmB;oBACnBW,WAAWG,KAAK;gBAClB;YACF;YACAb;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,OAAOR;AACT;AAOO,eAAekB,4BACpBnB,OAAwD,EACxDoB,wBAAiC;IAEjC,OAAOT,QAAQU,GAAG,CAChBC,MAAMC,IAAI,CAACvB,SAASwB,GAAG,CAAC,CAAC,CAACrB,KAAKC,MAAM;QACnC,OAAOA,MACJqB,IAAI,CAAC,OAAOC;YACX,IACEN,4BACCM,CAAAA,MAAMjB,UAAU,KAAK,KAAKiB,MAAMlB,MAAM,GAAGV,mNAAa,GACvD;gBACA,oEAAoE;gBACpE,sDAAsD;gBACtD,OAAO;YACT;YAEA,MAAM,CAAC6B,MAAMC,MAAM,GAAGF,MAAMtB,KAAK,CAACyB,GAAG;YACrCH,MAAMtB,KAAK,GAAGwB;YAEd,IAAIE,eAAuB;YAE3B,qEAAqE;YACrE,qEAAqE;YACrE,4BAA4B;YAC5B,WAAW,MAAMC,SAASJ,KAAM;gBAC9BG,oBAAgBlC,mOAAAA,EAAoBmC;YACtC;YAEA,OAAO;gBACL5B;gBACA;oBACE,uCAAuC;oBACvCC,OAAO4B,KAAKF;oBACZzB,MAAMqB,MAAMrB,IAAI;oBAChBC,OAAOoB,MAAMpB,KAAK;oBAClBC,WAAWmB,MAAMnB,SAAS;oBAC1BC,QAAQkB,MAAMlB,MAAM;oBACpBC,YAAYiB,MAAMjB,UAAU;gBAC9B;aACD;QACH,GACCwB,KAAK,CAAC;YACL,kEAAkE;YAClE,gBAAgB;YAChB,OAAO;QACT;IACJ;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 6098, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/resume-data-cache/resume-data-cache.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  type UseCacheCacheStore,\n  type FetchCacheStore,\n  type EncryptedBoundArgsCacheStore,\n  serializeUseCacheCacheStore,\n  parseUseCacheCacheStore,\n  type DecryptedBoundArgsCacheStore,\n  type UseCacheCacheStoreSerialized,\n} from './cache-store'\n\n/**\n * An immutable version of the resume data cache used during rendering.\n * This cache is read-only and cannot be modified once created.\n */\nexport interface RenderResumeDataCache {\n  /**\n   * A read-only Map store for values cached by the 'use cache' React hook.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly cache: Omit<UseCacheCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for cached fetch responses.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly fetch: Omit<FetchCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for encrypted bound args of inline server functions.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly encryptedBoundArgs: Omit<EncryptedBoundArgsCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for decrypted bound args of inline server functions.\n   * This is only intended for in-memory usage during pre-rendering, and must\n   * not be persisted in the resume store. The 'set' operation is omitted to\n   * enforce immutability.\n   */\n  readonly decryptedBoundArgs: Omit<DecryptedBoundArgsCacheStore, 'set'>\n}\n\n/**\n * A mutable version of the resume data cache used during pre-rendering.\n * This cache allows both reading and writing of cached values.\n */\nexport interface PrerenderResumeDataCache {\n  /**\n   * A mutable Map store for values cached by the 'use cache' React hook.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly cache: UseCacheCacheStore\n\n  /**\n   * A mutable Map store for cached fetch responses.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly fetch: FetchCacheStore\n\n  /**\n   * A mutable Map store for encrypted bound args of inline server functions.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly encryptedBoundArgs: EncryptedBoundArgsCacheStore\n\n  /**\n   * A mutable Map store for decrypted bound args of inline server functions.\n   * This is only intended for in-memory usage during pre-rendering, and must\n   * not be persisted in the resume store. Supports both 'get' and 'set'\n   * operations to build the cache during pre-rendering.\n   */\n  readonly decryptedBoundArgs: DecryptedBoundArgsCacheStore\n}\n\ntype ResumeStoreSerialized = {\n  store: {\n    cache: {\n      [key: string]: any\n    }\n    fetch: {\n      [key: string]: any\n    }\n    encryptedBoundArgs: {\n      [key: string]: string\n    }\n  }\n}\n\n/**\n * Serializes a resume data cache into a JSON string for storage or\n * transmission. Handles 'use cache' values, fetch responses, and encrypted\n * bound args for inline server functions.\n *\n * @param resumeDataCache - The immutable cache to serialize\n * @returns A Promise that resolves to the serialized cache as a JSON string, or\n * 'null' if empty\n */\nexport async function stringifyResumeDataCache(\n  resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache,\n  isCacheComponentsEnabled: boolean\n): Promise<string> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`stringifyResumeDataCache` should not be called in edge runtime.'\n    )\n  } else {\n    if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n      return 'null'\n    }\n\n    const json: ResumeStoreSerialized = {\n      store: {\n        fetch: Object.fromEntries(Array.from(resumeDataCache.fetch.entries())),\n        cache: Object.fromEntries(\n          (\n            await serializeUseCacheCacheStore(\n              resumeDataCache.cache.entries(),\n              isCacheComponentsEnabled\n            )\n          ).filter(\n            (entry): entry is [string, UseCacheCacheStoreSerialized] =>\n              entry !== null\n          )\n        ),\n        encryptedBoundArgs: Object.fromEntries(\n          Array.from(resumeDataCache.encryptedBoundArgs.entries())\n        ),\n      },\n    }\n\n    // Compress the JSON string using zlib. As the data we already want to\n    // decompress is in memory, we use the synchronous deflateSync function.\n    const { deflateSync } = require('node:zlib') as typeof import('node:zlib')\n\n    return deflateSync(JSON.stringify(json)).toString('base64')\n  }\n}\n\n/**\n * Creates a new empty mutable resume data cache for pre-rendering.\n * Initializes fresh Map instances for both the 'use cache' and fetch caches.\n * Used at the start of pre-rendering to begin collecting cached values.\n *\n * @returns A new empty PrerenderResumeDataCache instance\n */\nexport function createPrerenderResumeDataCache(): PrerenderResumeDataCache {\n  return {\n    cache: new Map(),\n    fetch: new Map(),\n    encryptedBoundArgs: new Map(),\n    decryptedBoundArgs: new Map(),\n  }\n}\n\n/**\n * Creates an immutable render resume data cache from either:\n * 1. An existing prerender cache instance\n * 2. A serialized cache string\n *\n * @param renderResumeDataCache - A RenderResumeDataCache instance to be used directly\n * @param prerenderResumeDataCache - A PrerenderResumeDataCache instance to convert to immutable\n * @param persistedCache - A serialized cache string to parse\n * @param maxPostponedStateSizeBytes - The max compressed size limit in bytes (used to calculate 5x decompression limit)\n * @returns An immutable RenderResumeDataCache instance\n */\nexport function createRenderResumeDataCache(\n  renderResumeDataCache: RenderResumeDataCache\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  persistedCache: string,\n  maxPostponedStateSizeBytes: number | undefined\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  resumeDataCacheOrPersistedCache:\n    | RenderResumeDataCache\n    | PrerenderResumeDataCache\n    | string,\n  maxPostponedStateSizeBytes?: number | undefined\n): RenderResumeDataCache {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`createRenderResumeDataCache` should not be called in edge runtime.'\n    )\n  } else {\n    if (typeof resumeDataCacheOrPersistedCache !== 'string') {\n      // If the cache is already a prerender or render cache, we can return it\n      // directly. For the former, we're just performing a type change.\n      return resumeDataCacheOrPersistedCache\n    }\n\n    if (resumeDataCacheOrPersistedCache === 'null') {\n      return {\n        cache: new Map(),\n        fetch: new Map(),\n        encryptedBoundArgs: new Map(),\n        decryptedBoundArgs: new Map(),\n      }\n    }\n\n    // This should be a compressed string. Let's decompress it using zlib.\n    // As the data we already want to decompress is in memory, we use the\n    // synchronous inflateSync function.\n    const { inflateSync } = require('node:zlib') as typeof import('node:zlib')\n\n    // Limit decompressed size to prevent zipbomb attacks. This is 5x the\n    // configured maxPostponedStateSize, allowing reasonable compression\n    // ratios while preventing extreme decompression bombs.\n    // Default is 500MB (5x the default 100MB compressed limit).\n    const maxDecompressedSize = maxPostponedStateSizeBytes\n      ? maxPostponedStateSizeBytes * 5\n      : 500 * 1024 * 1024\n\n    let json: ResumeStoreSerialized\n    try {\n      json = JSON.parse(\n        inflateSync(Buffer.from(resumeDataCacheOrPersistedCache, 'base64'), {\n          maxOutputLength: maxDecompressedSize,\n        }).toString('utf-8')\n      )\n    } catch (err: unknown) {\n      if (\n        err instanceof RangeError &&\n        (err as NodeJS.ErrnoException).code === 'ERR_BUFFER_TOO_LARGE'\n      ) {\n        throw new Error(\n          `Decompressed resume data cache exceeded ${maxDecompressedSize} byte limit`\n        )\n      }\n      throw err\n    }\n\n    return {\n      cache: parseUseCacheCacheStore(Object.entries(json.store.cache)),\n      fetch: new Map(Object.entries(json.store.fetch)),\n      encryptedBoundArgs: new Map(\n        Object.entries(json.store.encryptedBoundArgs)\n      ),\n      decryptedBoundArgs: new Map(),\n    }\n  }\n}\n"],"names":["InvariantError","serializeUseCacheCacheStore","parseUseCacheCacheStore","stringifyResumeDataCache","resumeDataCache","isCacheComponentsEnabled","process","env","NEXT_RUNTIME","fetch","size","cache","json","store","Object","fromEntries","Array","from","entries","filter","entry","encryptedBoundArgs","deflateSync","require","JSON","stringify","toString","createPrerenderResumeDataCache","Map","decryptedBoundArgs","createRenderResumeDataCache","resumeDataCacheOrPersistedCache","maxPostponedStateSizeBytes","inflateSync","maxDecompressedSize","parse","Buffer","maxOutputLength","err","RangeError","code","Error"],"mappings":";;;;;;;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAIEC,2BAA2B,EAC3BC,uBAAuB,QAGlB,gBAAe;;;AA4Ff,eAAeC,yBACpBC,eAAiE,EACjEC,wBAAiC;IAEjC,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIR,mNAAAA,CACR,qEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;AA+BT;AASO,SAAS2B;IACd,OAAO;QACLhB,OAAO,IAAIiB;QACXnB,OAAO,IAAImB;QACXP,oBAAoB,IAAIO;QACxBC,oBAAoB,IAAID;IAC1B;AACF;AAuBO,SAASE,4BACdC,+BAGU,EACVC,0BAA+C;IAE/C,IAAI1B,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIR,mNAAAA,CACR,wEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;AAyDT","ignoreList":[0]}},
    {"offset": {"line": 6142, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/dev/hot-reloader-types.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport type { UrlObject } from 'url'\nimport type { Duplex } from 'stream'\nimport type { webpack } from 'next/dist/compiled/webpack/webpack'\nimport type getBaseWebpackConfig from '../../build/webpack-config'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { Project, Update as TurbopackUpdate } from '../../build/swc/types'\nimport type { VersionInfo } from './parse-version-info'\nimport type { DebugInfo } from '../../next-devtools/shared/types'\nimport type { DevIndicatorServerState } from './dev-indicator-server-state'\nimport type {\n  CacheIndicatorState,\n  ServerCacheStatus,\n} from '../../next-devtools/dev-overlay/cache-indicator'\nimport type { DevToolsConfig } from '../../next-devtools/dev-overlay/shared'\nimport type { ReactDebugChannelForBrowser } from './debug-channel'\n\nexport const enum HMR_MESSAGE_SENT_TO_BROWSER {\n  // JSON messages:\n  ADDED_PAGE = 'addedPage',\n  REMOVED_PAGE = 'removedPage',\n  RELOAD_PAGE = 'reloadPage',\n  SERVER_COMPONENT_CHANGES = 'serverComponentChanges',\n  MIDDLEWARE_CHANGES = 'middlewareChanges',\n  CLIENT_CHANGES = 'clientChanges',\n  SERVER_ONLY_CHANGES = 'serverOnlyChanges',\n  SYNC = 'sync',\n  BUILT = 'built',\n  BUILDING = 'building',\n  DEV_PAGES_MANIFEST_UPDATE = 'devPagesManifestUpdate',\n  TURBOPACK_MESSAGE = 'turbopack-message',\n  SERVER_ERROR = 'serverError',\n  TURBOPACK_CONNECTED = 'turbopack-connected',\n  ISR_MANIFEST = 'isrManifest',\n  CACHE_INDICATOR = 'cacheIndicator',\n  DEV_INDICATOR = 'devIndicator',\n  DEVTOOLS_CONFIG = 'devtoolsConfig',\n  REQUEST_CURRENT_ERROR_STATE = 'requestCurrentErrorState',\n  REQUEST_PAGE_METADATA = 'requestPageMetadata',\n\n  // Binary messages:\n  REACT_DEBUG_CHUNK = 0,\n  ERRORS_TO_SHOW_IN_BROWSER = 1,\n}\n\nexport const enum HMR_MESSAGE_SENT_TO_SERVER {\n  // JSON messages:\n  MCP_ERROR_STATE_RESPONSE = 'mcp-error-state-response',\n  MCP_PAGE_METADATA_RESPONSE = 'mcp-page-metadata-response',\n  PING = 'ping',\n}\n\nexport interface ServerErrorMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR\n  errorJSON: string\n}\n\nexport interface TurbopackMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE\n  data: TurbopackUpdate | TurbopackUpdate[]\n}\n\nexport interface BuildingMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.BUILDING\n}\n\nexport interface CompilationError {\n  moduleName?: string\n  message: string\n  details?: string\n  moduleTrace?: Array<{ moduleName?: string }>\n  stack?: string\n}\n\nexport interface SyncMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.SYNC\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  versionInfo: VersionInfo\n  updatedModules?: ReadonlyArray<string>\n  debug?: DebugInfo\n  devIndicator: DevIndicatorServerState\n  devToolsConfig?: DevToolsConfig\n}\n\nexport interface BuiltMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.BUILT\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  updatedModules?: ReadonlyArray<string>\n}\n\nexport interface AddedPageMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE\n  data: [page: string | null]\n}\n\nexport interface RemovedPageMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE\n  data: [page: string | null]\n}\n\nexport interface ReloadPageMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE\n  data: string\n}\n\nexport interface ServerComponentChangesMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES\n  hash: string\n}\n\nexport interface MiddlewareChangesMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n}\n\nexport interface ClientChangesMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES\n}\n\nexport interface ServerOnlyChangesMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES\n  pages: ReadonlyArray<string>\n}\n\nexport interface DevPagesManifestUpdateMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE\n  data: [\n    {\n      devPagesManifest: true\n    },\n  ]\n}\n\nexport interface TurbopackConnectedMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n  data: { sessionId: number }\n}\n\nexport interface AppIsrManifestMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST\n  data: Record<string, boolean>\n}\n\nexport interface DevToolsConfigMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG\n  data: DevToolsConfig\n}\n\nexport interface ReactDebugChunkMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK\n  requestId: string\n  /**\n   * A null chunk signals to the browser that no more chunks will be sent.\n   */\n  chunk: Uint8Array | null\n}\n\nexport interface ErrorsToShowInBrowserMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER\n  serializedErrors: Uint8Array\n}\n\nexport interface RequestCurrentErrorStateMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE\n  requestId: string\n}\n\nexport interface RequestPageMetadataMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA\n  requestId: string\n}\n\nexport interface CacheIndicatorMessage {\n  type: HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR\n  state: CacheIndicatorState\n}\n\nexport type HmrMessageSentToBrowser =\n  | TurbopackMessage\n  | TurbopackConnectedMessage\n  | BuildingMessage\n  | SyncMessage\n  | BuiltMessage\n  | AddedPageMessage\n  | RemovedPageMessage\n  | ReloadPageMessage\n  | ServerComponentChangesMessage\n  | ClientChangesMessage\n  | MiddlewareChangesMessage\n  | ServerOnlyChangesMessage\n  | DevPagesManifestUpdateMessage\n  | ServerErrorMessage\n  | AppIsrManifestMessage\n  | DevToolsConfigMessage\n  | ErrorsToShowInBrowserMessage\n  | ReactDebugChunkMessage\n  | RequestCurrentErrorStateMessage\n  | RequestPageMetadataMessage\n  | CacheIndicatorMessage\n\nexport type BinaryHmrMessageSentToBrowser = Extract<\n  HmrMessageSentToBrowser,\n  { type: number }\n>\n\nexport type TurbopackMessageSentToBrowser =\n  | {\n      type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE\n      data: any\n    }\n  | {\n      type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n      data: { sessionId: number }\n    }\n\nexport interface NextJsHotReloaderInterface {\n  turbopackProject?: Project\n  activeWebpackConfigs?: Array<Awaited<ReturnType<typeof getBaseWebpackConfig>>>\n  serverStats: webpack.Stats | null\n  edgeServerStats: webpack.Stats | null\n  run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlObject\n  ): Promise<{ finished?: true }>\n\n  setHmrServerError(error: Error | null): void\n  clearHmrServerError(): void\n  start(): Promise<void>\n  send(action: HmrMessageSentToBrowser): void\n  /**\n   * Send the given action only to legacy clients, i.e. Pages Router clients,\n   * and App Router clients that don't have Cache Components enabled.\n   */\n  sendToLegacyClients(action: HmrMessageSentToBrowser): void\n  setCacheStatus(status: ServerCacheStatus, htmlRequestId: string): void\n  setReactDebugChannel(\n    debugChannel: ReactDebugChannelForBrowser,\n    htmlRequestId: string,\n    requestId: string\n  ): void\n  sendErrorsToBrowser(\n    errorsRscStream: ReadableStream<Uint8Array>,\n    htmlRequestId: string\n  ): void\n  getCompilationErrors(page: string): Promise<any[]>\n  onHMR(\n    req: IncomingMessage,\n    _socket: Duplex,\n    head: Buffer,\n    onUpgrade: (\n      client: { send(data: string): void },\n      context: { isLegacyClient: boolean }\n    ) => void\n  ): void\n  invalidate({\n    reloadAfterInvalidation,\n  }: {\n    reloadAfterInvalidation: boolean\n  }): Promise<void> | void\n  buildFallbackError(): Promise<void>\n  ensurePage({\n    page,\n    clientOnly,\n    appPaths,\n    definition,\n    isApp,\n    url,\n  }: {\n    page: string\n    clientOnly: boolean\n    appPaths?: ReadonlyArray<string> | null\n    isApp?: boolean\n    definition: RouteDefinition | undefined\n    url?: string\n  }): Promise<void>\n  close(): void\n}\n"],"names":["HMR_MESSAGE_SENT_TO_BROWSER","HMR_MESSAGE_SENT_TO_SERVER"],"mappings":";;;;;;AAiBO,IAAWA,8BAAAA,WAAAA,GAAAA,SAAAA,2BAAAA;IAChB,iBAAiB;;;;;;;;;;;;;;;;;;;;;IAsBjB,mBAAmB;;;WAvBHA;MA0BjB;AAEM,IAAWC,6BAAAA,WAAAA,GAAAA,SAAAA,0BAAAA;IAChB,iBAAiB;;;;WADDA;MAKjB","ignoreList":[0]}},
    {"offset": {"line": 6186, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/instrumentation/utils.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isStaticGeneration?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isStaticGeneration) {\n    return 'stale'\n  }\n  return undefined\n}\n"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isStaticGeneration","undefined"],"mappings":";;;;AAAO,SAASA,oBAAoBC,MAGnC;IACC,IAAIA,OAAOC,oBAAoB,EAAE;QAC/B,OAAO;IACT;IACA,IAAID,OAAOE,kBAAkB,EAAE;QAC7B,OAAO;IACT;IACA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 6203, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/instrumentation/utils.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isStaticGeneration?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isStaticGeneration) {\n    return 'stale'\n  }\n  return undefined\n}\n"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isStaticGeneration","undefined"],"mappings":";;;;AAAO,SAASA,oBAAoBC,MAGnC;IACC,IAAIA,OAAOC,oBAAoB,EAAE;QAC/B,OAAO;IACT;IACA,IAAID,OAAOE,kBAAkB,EAAE;QAC7B,OAAO;IACT;IACA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 6220, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/node-environment-extensions/fast-set-immediate.external.ts"],"sourcesContent":["import { promisify } from 'node:util'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { bindSnapshot } from '../app-render/async-local-storage'\n\ntype Execution = {\n  state: ExecutionState\n  queuedImmediates: QueueItem[]\n}\n\nenum ExecutionState {\n  Waiting = 1,\n  Working = 2,\n  Finished = 3,\n  Abandoned = 4,\n}\n\nlet wasEnabledAtLeastOnce = false\n\nlet pendingNextTicks = 0\nlet currentExecution: Execution | null = null\n\nconst originalSetImmediate = globalThis.setImmediate\nconst originalClearImmediate = globalThis.clearImmediate\nconst originalNextTick = process.nextTick\n\nexport { originalSetImmediate as unpatchedSetImmediate }\n\nfunction install() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    // Nothing to patch. The exported functions all error if used in the edge runtime,\n    // so we're not going to violate any assumptions by not patching.\n    return\n  } else {\n    debug?.('installing fast setImmediate patch')\n\n    const nodeTimers = require('node:timers') as typeof import('node:timers')\n    globalThis.setImmediate = nodeTimers.setImmediate =\n      // Workaround for missing __promisify__ which is not a real property\n      patchedSetImmediate as unknown as typeof setImmediate\n    globalThis.clearImmediate = nodeTimers.clearImmediate =\n      patchedClearImmediate\n\n    const nodeTimersPromises =\n      require('node:timers/promises') as typeof import('node:timers/promises')\n    nodeTimersPromises.setImmediate =\n      patchedSetImmediatePromise as typeof import('node:timers/promises').setImmediate\n\n    process.nextTick = patchedNextTick\n  }\n}\n\n/**\n * **WARNING: This function changes the usual behavior of the event loop!**\n * **Be VERY careful about where you call it.**\n *\n * Starts capturing calls to `setImmediate` to run them as \"fast immediates\".\n * All calls captured in this way will be executed after the current task\n * (after callbacks from `process.nextTick()`, microtasks, and nextTicks scheduled from microtasks).\n * This function needs to be called again in each task that needs the\n * \"fast immediates\" behavior.\n *\n * ### Motivation\n *\n * We don't want `setImmediate` to be considered IO in Cache Components.\n * To achieve this in a staged (pre)render, we want to allow immediates scheduled\n * in stage N to run before stage N+1.\n * Since we schedule stages using sequential `setTimeout`, this isn't possible without\n * intercepting `setImmediate` and doing the scheduling on our own.\n * We refer to this as a \"fast immediate\".\n *\n * Notably, this affects React's `scheduleWork` in render, which uses `setImmediate`.\n * This is desirable -- if async work was scheduled during a stage, then it should\n * get to run before we finish that stage.\n *\n * ### Example\n *\n * ```ts\n * setTimeout(() => {\n *   runPendingImmediatesAfterCurrentTask()\n *   console.log(\"timeout 1\")\n *   setImmediate(() => {\n *     console.log(\"immediate!!!\")\n *   })\n * })\n * setTimeout(() => {\n *   console.log(\"timeout 2\")\n * })\n * ```\n * will print\n *\n * ```\n * timeout 1\n * immediate!!!\n * timeout 2\n * ```\n *\n * instead of the usual order\n * ```\n * timeout 1\n * timeout 2\n * immediate!!!\n * ```\n * > **NOTE**\n * > The above is *most common* order, but it's not guaranteed.\n * > Under some circumstances (e.g. when the event loop is blocked on CPU work),\n * > Node will reorder things and run the immediate before timeout 2.\n * > So, in a sense, we're just making this reordering happen consistently.\n *\n * Recursive `setImmediate` calls will also be executed as \"fast immediates\".\n * If multiple immediates were scheduled, `process.nextTick()` (and associated microtasks)\n * will be allowed to execute between them.\n * See the unit tests for more examples.\n * */\nexport function DANGEROUSLY_runPendingImmediatesAfterCurrentTask() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'DANGEROUSLY_runPendingImmediatesAfterCurrentTask cannot be called in the edge runtime'\n    )\n  } else {\n    const execution = startCapturingImmediates()\n\n    try {\n      scheduleWorkAfterNextTicksAndMicrotasks(execution)\n    } catch (err) {\n      // If this error comes from a bail() call, rethrow it.\n      if (execution.state === ExecutionState.Abandoned) {\n        throw err\n      }\n      // Otherwise, bail out here.\n      bail(\n        execution,\n        new InvariantError(\n          'An unexpected error occurred while starting to capture immediates',\n          {\n            cause: err,\n          }\n        )\n      )\n    }\n  }\n}\n\n/**\n * This should always be called a task after `DANGEROUSLY_runPendingImmediatesAfterCurrentTask`\n * to make sure that everything executed as expected and we're not left in an inconsistent state.\n * Ideally, this wouldn't be necessary, but we're not in control of the event loop\n * and need to guard against unexpected behaviors not forseen in this implementation,\n * so we have to be defensive.\n */\nexport function expectNoPendingImmediates() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'expectNoPendingImmediates cannot be called in the edge runtime'\n    )\n  } else {\n    if (currentExecution !== null) {\n      bail(\n        currentExecution,\n        new InvariantError(\n          `Expected all captured immediates to have been executed (state: ${ExecutionState[currentExecution.state]})`\n        )\n      )\n    }\n  }\n}\n\n/**\n * Wait until all nextTicks and microtasks spawned from the current task are done,\n * then execute any immediates that they queued.\n * */\nfunction scheduleWorkAfterNextTicksAndMicrotasks(execution: Execution) {\n  if (execution.state !== ExecutionState.Waiting) {\n    throw new InvariantError(\n      `scheduleWorkAfterTicksAndMicrotasks can only be called while waiting (state: ${ExecutionState[execution.state]})`\n    )\n  }\n\n  // We want to execute \"fast immediates\" after all the nextTicks and microtasks\n  // spawned from the current task are done.\n  // The ordering here is:\n  //\n  // 1. sync code\n  // 2. process.nextTick (scheduled from sync code, or from one of these nextTicks)\n  // 3. microtasks\n  // 4. process.nextTick (scheduled from microtasks, e.g. `queueMicrotask(() => process.nextTick(callback))`)\n  //\n  // We want to run to run in step 4, because that's the latest point before the next tick.\n  // However, there might also be other callbacks scheduled to run in that step.\n  // But importantly, they had to be scheduled using a `process.nextTick`,\n  // so we can detect them by checking if `pendingNextTicks > 0`.\n  // In that case, we'll just reschedule ourselves in the same way again to let them run first.\n  // (this process can theoretically repeat multiple times, hence the recursion).\n\n  queueMicrotask(() => {\n    // (note that this call won't increment `pendingNextTicks`,\n    // only the patched `process.nextTick` does that, so this won't loop infinitely)\n    originalNextTick(() => {\n      // We're now in a nextTick, which means that we're executing inside `processTicksAndRejections`:\n      // https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L84\n      // All the work scheduled here will happen within that `processTicksAndRejections` loop.\n      // Reading the source of `processTicksAndRejections` can help understand the timing here --\n      // All we're really doing is strategically pushing callbacks into the two queues\n      // (nextTicks and microtasks) that that function is currently looping over.\n\n      try {\n        if (\n          execution.state === ExecutionState.Abandoned ||\n          currentExecution !== execution\n        ) {\n          debug?.(`scheduler :: the execution was abandoned`)\n          return\n        }\n        if (pendingNextTicks > 0) {\n          // Other nextTicks have been scheduled. Let those run first, then try again --\n          // we're simulating a event loop task, so all nextTicks should be exhausted before we execute.\n          debug?.(`scheduler :: yielding to ${pendingNextTicks} nextTicks`)\n          return scheduleWorkAfterNextTicksAndMicrotasks(execution)\n        }\n\n        // There's no other nextTicks, we're the last one, so we're about to move on to the next task (likely a timer).\n        // Now, we can try and execute any queued immediates.\n        return performWork(execution)\n      } catch (err) {\n        // If this error comes from a bail() call, rethrow it.\n\n        // typescript can't tell that the state might've been mutated\n        // and the narrowing from above is no longer valid\n        const executionAfterWork = execution as Execution\n        if (executionAfterWork.state === ExecutionState.Abandoned) {\n          throw err\n        }\n\n        // Otherwise, bail out here (which will trigger an uncaught exception)\n        // Note that we're using the same microtask trick as `safelyRunNextTickCallback`.\n        queueMicrotask(() => {\n          bail(\n            execution,\n            new InvariantError(\n              'An unexpected error occurred while executing immediates',\n              { cause: err }\n            )\n          )\n        })\n      }\n    })\n  })\n}\n\n/** Execute one immediate, and schedule a check for more (in case there's others in the queue) */\nfunction performWork(execution: Execution) {\n  if (execution.state === ExecutionState.Abandoned) {\n    return\n  }\n\n  debug?.(`scheduler :: performing work`)\n\n  if (execution.state !== ExecutionState.Waiting) {\n    throw new InvariantError(\n      `performWork can only be called while waiting (state: ${ExecutionState[execution.state]})`\n    )\n  }\n  execution.state = ExecutionState.Working\n\n  const queueItem = takeNextActiveQueueItem(execution)\n\n  if (queueItem === null) {\n    debug?.(`scheduler :: no immediates queued, exiting`)\n    stopCapturingImmediates(execution)\n    return\n  }\n\n  debug?.(`scheduler :: executing queued immediate`)\n\n  const { immediateObject, callback, args } = queueItem\n\n  immediateObject[INTERNALS].queueItem = null\n  clearQueueItem(queueItem)\n\n  // Execute the immediate.\n\n  // If a sync error was thrown in the immediate, we want to trigger a `uncaughtException`.\n  // However, we're executing in a nextTick, and if a nextTick callback errors,\n  // It'll break out of `processTicksAndRejections` (note the lack of a `catch` block):\n  //   https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L81-L97\n  // Meaning that the event loop will stop executing nextTicks and move on to the next timer\n  // (or other phase of the event loop, but we expect to be running in a sequence of timers here).\n  // Then, the remaining ticks will run after that timer, since they're still in the queue.\n  //\n  // This would completely break the timing we're trying to achieve here --\n  // The point of this patch is to execute immediates before the next timer!\n  // So, we need to work around this behavior. (both here and in our `process.nextTick` patch).\n  //\n  // We can sidestep this by catching the synchronous error and rethrowing it in a microtask.\n  // (NOTE: if we use `queueMicrotask`, it'll trigger `uncaughtException`, not `unhandledRejection`,\n  // because there's no promise being rejected.)\n  //\n  // This will make `uncaughtException` happen:\n  // - Before the next fast immediate (`scheduleWorkAfterNextTicksAndMicrotasks` also uses `queueMicrotask`).\n  //   This is good, and matches usual observable behavior of immediates.\n  // - AFTER nextTicks scheduled from the immediate itself.\n  //   This deviates from native setImmediate, which would call `uncaughtException` first,\n  //   and skip ahead to the next task as explained above.\n  //\n  // This is technically an observable difference in behavior, but it seems niche enough that\n  // it shouldn't cause problems -- we don't expect user code to use `uncaughtException` for control flow,\n  // only error reporting, so subtly changing the timing shouldn't matter.\n\n  let didThrow = false\n  let thrownValue: unknown = undefined\n  queueMicrotask(() => {\n    if (didThrow) {\n      debug?.('scheduler :: rethrowing sync error from immediate in microtask')\n      throw thrownValue\n    }\n  })\n\n  try {\n    if (args !== null) {\n      callback.apply(null, args)\n    } else {\n      callback()\n    }\n  } catch (err) {\n    // We'll rethrow the error in the microtask above.\n    didThrow = true\n    thrownValue = err\n  }\n\n  // Schedule the loop again in case there's more immediates after this one.\n  // Note that we can't just check if the queue is empty now, because new immediates\n  // might still be scheduled asynchronously, from an upcoming nextTick or microtask.\n  execution.state = ExecutionState.Waiting\n  scheduleWorkAfterNextTicksAndMicrotasks(execution)\n}\n\nfunction takeNextActiveQueueItem(execution: Execution): ActiveQueueItem | null {\n  // Find the first (if any) queued immediate that wasn't cleared.\n  // We don't remove immediates from the array when they're cleared,\n  // so this requires some legwork to exclude (and possibly drop) cleared items.\n  const { queuedImmediates } = execution\n\n  let firstActiveItem: ActiveQueueItem | null = null\n  let firstActiveItemIndex = -1\n  for (let i = 0; i < queuedImmediates.length; i++) {\n    const item = queuedImmediates[i]\n    if (!item.isCleared) {\n      firstActiveItem = item\n      firstActiveItemIndex = i\n      break\n    }\n  }\n\n  if (firstActiveItem === null) {\n    // We didn't find an active item.\n\n    // If the queue isn't empty, then it must only contain cleared items. Empty it.\n    if (queuedImmediates.length > 0) {\n      queuedImmediates.length = 0\n    }\n\n    return null\n  }\n\n  // Remove all items up to and including `nextActiveItemIndex` from the queue.\n  // (if it's not the first item, then it must be preceded by cleared items, which we want to drop anyway)\n  if (firstActiveItemIndex === 0) {\n    // Fast path - drop the first item\n    // (`splice` creates a result array for the removed items, so this is more efficient)\n    queuedImmediates.shift()\n  } else {\n    queuedImmediates.splice(0, firstActiveItemIndex + 1)\n  }\n\n  return firstActiveItem\n}\n\nfunction startCapturingImmediates(): Execution {\n  if (currentExecution !== null) {\n    bail(\n      currentExecution,\n      new InvariantError(\n        `Cannot start capturing immediates again without finishing the previous task (state: ${ExecutionState[currentExecution.state]})`\n      )\n    )\n  }\n  wasEnabledAtLeastOnce = true\n\n  const execution: Execution = {\n    state: ExecutionState.Waiting,\n    queuedImmediates: [],\n  }\n  currentExecution = execution\n\n  return execution\n}\n\nfunction stopCapturingImmediates(execution: Execution) {\n  if (execution.state === ExecutionState.Abandoned) {\n    return\n  }\n\n  // This check enforces that we run performWork at least once before stopping\n  // to make sure that we've waited for all the nextTicks and microtasks\n  // that might've scheduled some immediates after sync code.\n  if (execution.state !== ExecutionState.Working) {\n    throw new InvariantError(\n      `Cannot stop capturing immediates before execution is finished (state: ${ExecutionState[execution.state]})`\n    )\n  }\n\n  execution.state = ExecutionState.Finished\n\n  if (currentExecution === execution) {\n    currentExecution = null\n  }\n}\n\nfunction bail(execution: Execution, error: Error): never {\n  // Reset the state as best we can to prevent further crashes.\n  // Otherwise, any subsequent call to `DANGEROUSLY_runPendingImmediatesAfterCurrentTask`\n  // would error, requiring a server restart to fix.\n\n  if (currentExecution === execution) {\n    currentExecution = null\n  }\n\n  execution.state = ExecutionState.Abandoned\n\n  // If we have any queued immediates, schedule them with native `setImmediate` and clear the queue.\n  // We don't want to skip running them altogether, because that could lead to\n  // e.g. hanging promises (for `new Promise((resolve) => setImmediate(resolve))`),\n  // but we're in an inconsistent state and can't run them as fast immediates,\n  // so this is the next best thing.\n  for (const queueItem of execution.queuedImmediates) {\n    if (queueItem.isCleared) {\n      continue\n    }\n    scheduleQueuedImmediateAsNativeImmediate(queueItem)\n  }\n  execution.queuedImmediates.length = 0\n\n  // Don't reset `pendingNextTicks` -- it will reset to 0 on its own as the nextTicks execute.\n  // If we set it to 0 here while we still have pending ticks, they'd decrement it below 0.\n\n  throw error\n}\n\nfunction scheduleQueuedImmediateAsNativeImmediate(queueItem: ActiveQueueItem) {\n  const { callback, args, immediateObject } = queueItem\n  const hasRef = immediateObject[INTERNALS].hasRef\n\n  clearQueueItem(queueItem)\n\n  const nativeImmediate =\n    args !== null\n      ? originalSetImmediate(callback, ...args)\n      : originalSetImmediate(callback)\n\n  if (!hasRef) {\n    nativeImmediate.unref()\n  }\n\n  // Make our fake immediate object proxy all relevant operations\n  // (clearing, ref(), unref(), hasRef()) to the actual native immediate.\n  proxyQueuedImmediateToNativeImmediate(immediateObject, nativeImmediate)\n}\n\ntype QueueItem = ActiveQueueItem | ClearedQueueItem\ntype ActiveQueueItem = {\n  isCleared: false\n  callback: (...args: any[]) => any\n  args: any[] | null\n  immediateObject: NextImmediate\n}\ntype ClearedQueueItem = {\n  isCleared: true\n  callback: null\n  args: null\n  immediateObject: null\n}\n\nfunction clearQueueItem(originalQueueItem: QueueItem) {\n  const queueItem = originalQueueItem as ClearedQueueItem\n  queueItem.isCleared = true\n  queueItem.callback = null\n  queueItem.args = null\n  queueItem.immediateObject = null\n}\n\n//========================================================\n\nfunction patchedNextTick<TArgs extends any[]>(\n  callback: (...args: TArgs) => void,\n  ...args: TArgs\n): void\nfunction patchedNextTick() {\n  if (currentExecution === null) {\n    return originalNextTick.apply(\n      null,\n      // @ts-expect-error: this is valid, but typescript doesn't get it\n      arguments\n    )\n  }\n\n  if (arguments.length === 0 || typeof arguments[0] !== 'function') {\n    // Let the original nextTick error for invalid arguments\n    // so that we don't have to mirror the error message.\n    originalNextTick.apply(\n      null,\n      // @ts-expect-error: explicitly passing arguments that we know are invalid\n      arguments\n    )\n\n    // We expect the above call to throw. If it didn't, something's broken.\n    bail(\n      currentExecution,\n      new InvariantError(\n        'Expected process.nextTick to reject invalid arguments'\n      )\n    )\n  }\n\n  debug?.(\n    `scheduler :: process.nextTick called (previous pending: ${pendingNextTicks})`\n  )\n\n  const callback: (...args: any[]) => any = arguments[0]\n  const args: any[] | null =\n    arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null\n\n  pendingNextTicks += 1\n  return originalNextTick(safelyRunNextTickCallback, callback, args)\n}\n\nfunction safelyRunNextTickCallback(\n  callback: (...args: any[]) => any,\n  args: any[] | null\n) {\n  pendingNextTicks -= 1\n  debug?.(\n    `scheduler :: process.nextTick executing (still pending: ${pendingNextTicks})`\n  )\n\n  // Synchronous errors in nextTick break out of `processTicksAndRejections` and cause us\n  // to move on to the next timer without having executed the whole nextTick queue,\n  // which breaks our entire scheduling mechanism. See `performWork` for more details.\n  try {\n    if (args !== null) {\n      callback.apply(null, args)\n    } else {\n      callback()\n    }\n  } catch (err) {\n    // We want to make sure `nextTick` is cheap, so unlike `performWork`,\n    // we only queue the microtask if an error actually occurs.\n    // This (observably) changes the timing of `uncaughtException` even more,\n    // because it'll run after microtasks queued from the nextTick,\n    // but hopefully this is niche enough to not affect any real world code.\n    queueMicrotask(() => {\n      debug?.(`scheduler :: rethrowing sync error from nextTick in a microtask`)\n      throw err\n    })\n  }\n}\n\nfunction patchedSetImmediate<TArgs extends any[]>(\n  callback: (...args: TArgs) => void,\n  ...args: TArgs\n): NodeJS.Immediate\nfunction patchedSetImmediate(callback: (args: void) => void): NodeJS.Immediate\nfunction patchedSetImmediate(): NodeJS.Immediate {\n  if (currentExecution === null) {\n    return originalSetImmediate.apply(\n      null,\n      // @ts-expect-error: this is valid, but typescript doesn't get it\n      arguments\n    )\n  }\n\n  if (arguments.length === 0 || typeof arguments[0] !== 'function') {\n    // Let the original setImmediate error for invalid arguments\n    // so that we don't have to mirror the error message.\n    originalSetImmediate.apply(\n      null,\n      // @ts-expect-error: explicitly passing arguments that we know are invalid\n      arguments\n    )\n\n    // We expect the above call to throw. If it didn't, something's broken.\n    bail(\n      currentExecution,\n      new InvariantError('Expected setImmediate to reject invalid arguments')\n    )\n  }\n\n  const callback: (...args: any[]) => any = arguments[0]\n  const args: any[] | null =\n    arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null\n\n  // Normally, Node would capture and propagate the async context to the immediate.\n  // We'll be running it on our own queue, so we need to propagate it ourselves.\n  const callbackWithAsyncContext = bindSnapshot(callback)\n\n  const immediateObject = new NextImmediate()\n\n  const queueItem: ActiveQueueItem = {\n    isCleared: false,\n    callback: callbackWithAsyncContext,\n    args,\n    immediateObject,\n  }\n  currentExecution.queuedImmediates.push(queueItem)\n\n  immediateObject[INTERNALS].queueItem = queueItem\n\n  return immediateObject\n}\n\nfunction patchedSetImmediatePromise<T = void>(\n  value: T,\n  options?: import('node:timers').TimerOptions\n): Promise<T> {\n  if (currentExecution === null) {\n    const originalPromisify: (typeof setImmediate)['__promisify__'] =\n      // @ts-expect-error: the types for `promisify.custom` are strange\n      originalSetImmediate[promisify.custom]\n    return originalPromisify(value, options)\n  }\n\n  return new Promise<T>((resolve, reject) => {\n    // The abort signal makes the promise reject.\n    // If it is already aborted, we reject immediately.\n    const signal = options?.signal\n    if (signal && signal.aborted) {\n      return reject(signal.reason)\n    }\n\n    const immediate = patchedSetImmediate(resolve, value)\n\n    // Unref-ing only really has an observable effect if we bail out to a native immediate,\n    // but we do it for completeness\n    if (options?.ref === false) {\n      immediate.unref()\n    }\n\n    if (signal) {\n      signal.addEventListener(\n        'abort',\n        () => {\n          patchedClearImmediate(immediate)\n          reject(signal.reason)\n        },\n        { once: true }\n      )\n    }\n  })\n}\n\npatchedSetImmediate[promisify.custom] = patchedSetImmediatePromise\n\nconst patchedClearImmediate = (\n  immediateObject: NodeJS.Immediate | undefined\n) => {\n  // NOTE: we defensively check for patched immediates even if we're not\n  // currently capturing immediates, because the objects returned from\n  // the patched setImmediate can be kept around for arbitrarily long.\n  // As an optimization, we only do this if the patch was enabled at least once --\n  // otherwise, no patched objects could've been created.\n  if (\n    wasEnabledAtLeastOnce &&\n    immediateObject &&\n    typeof immediateObject === 'object' &&\n    INTERNALS in immediateObject\n  ) {\n    ;(immediateObject as NextImmediate)[Symbol.dispose]()\n  } else {\n    originalClearImmediate(immediateObject)\n  }\n}\n\n//========================================================\n\nconst INTERNALS: unique symbol = Symbol.for('next.Immediate.internals')\n\ntype NextImmediateInternals =\n  | {\n      /** Stored to reflect `ref()`/`unref()` calls, but has no effect otherwise */\n      hasRef: boolean\n      queueItem: ActiveQueueItem | null\n      nativeImmediate: null\n    }\n  | {\n      hasRef: null\n      queueItem: null\n      nativeImmediate: NodeJS.Immediate\n    }\n\nfunction proxyQueuedImmediateToNativeImmediate(\n  immediateObject: NextImmediate,\n  nativeImmediate: NodeJS.Immediate\n) {\n  immediateObject[INTERNALS].hasRef = null\n  immediateObject[INTERNALS].queueItem = null\n  immediateObject[INTERNALS].nativeImmediate = nativeImmediate\n}\n\n/** Makes sure that we're implementing all the public `Immediate` methods */\ninterface NativeImmediate extends NodeJS.Immediate {}\n\n/** Implements a shim for the native `Immediate` class returned by `setImmediate` */\nclass NextImmediate implements NativeImmediate {\n  [INTERNALS]: NextImmediateInternals = {\n    queueItem: null,\n    hasRef: true,\n    nativeImmediate: null,\n  }\n  hasRef() {\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      return internals.hasRef\n    } else if (internals.nativeImmediate) {\n      return internals.nativeImmediate.hasRef()\n    } else {\n      // if we're no longer queued (cleared or executed), hasRef is always false\n      return false\n    }\n  }\n  ref() {\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      internals.hasRef = true\n    } else if (internals.nativeImmediate) {\n      internals.nativeImmediate.ref()\n    }\n    return this\n  }\n  unref() {\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      internals.hasRef = false\n    } else if (internals.nativeImmediate) {\n      internals.nativeImmediate.unref()\n    }\n    return this\n  }\n\n  /**\n   * Node invokes `_onImmediate` when an immediate is executed:\n   * https://github.com/nodejs/node/blob/42d363205715ffa5a4a6d90f4be1311487053d65/lib/internal/timers.js#L504\n   * It's visible on the public types, so we want to have it here for parity, but it's a noop.\n   * */\n  _onImmediate() {}\n\n  [Symbol.dispose]() {\n    // This is equivalent to `clearImmediate`.\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      // this is still queued. drop it.\n      const queueItem = internals.queueItem\n      internals.queueItem = null\n      clearQueueItem(queueItem)\n    } else if (internals.nativeImmediate) {\n      internals.nativeImmediate[Symbol.dispose]()\n    }\n  }\n}\n\n// ==========================================\n\nconst debug =\n  process.env.NEXT_DEBUG_IMMEDIATES !== '1'\n    ? undefined\n    : (...args: any[]) => {\n        if (process.env.NEXT_RUNTIME === 'edge') {\n          throw new InvariantError(\n            'Fast setImmediate is not available in the edge runtime.'\n          )\n        } else {\n          const { inspect } = require('node:util') as typeof import('node:util')\n          const { writeFileSync } =\n            require('node:fs') as typeof import('node:fs')\n\n          let logLine =\n            args\n              .map((arg) =>\n                typeof arg === 'string' ? arg : inspect(arg, { colors: true })\n              )\n              .join(' ') + '\\n'\n\n          logLine = '\\x1B[2m' + logLine + '\\x1B[22m' // styleText('dim', logLine)\n          writeFileSync(process.stdout.fd, logLine)\n        }\n      }\n\n// ==========================================\n\ninstall()\n"],"names":["promisify","InvariantError","bindSnapshot","ExecutionState","wasEnabledAtLeastOnce","pendingNextTicks","currentExecution","originalSetImmediate","globalThis","setImmediate","originalClearImmediate","clearImmediate","originalNextTick","process","nextTick","unpatchedSetImmediate","install","env","NEXT_RUNTIME","debug","nodeTimers","require","patchedSetImmediate","patchedClearImmediate","nodeTimersPromises","patchedSetImmediatePromise","patchedNextTick","DANGEROUSLY_runPendingImmediatesAfterCurrentTask","execution","startCapturingImmediates","scheduleWorkAfterNextTicksAndMicrotasks","err","state","bail","cause","expectNoPendingImmediates","queueMicrotask","performWork","executionAfterWork","queueItem","takeNextActiveQueueItem","stopCapturingImmediates","immediateObject","callback","args","INTERNALS","clearQueueItem","didThrow","thrownValue","undefined","apply","queuedImmediates","firstActiveItem","firstActiveItemIndex","i","length","item","isCleared","shift","splice","error","scheduleQueuedImmediateAsNativeImmediate","hasRef","nativeImmediate","unref","proxyQueuedImmediateToNativeImmediate","originalQueueItem","arguments","Array","prototype","slice","call","safelyRunNextTickCallback","callbackWithAsyncContext","NextImmediate","push","value","options","originalPromisify","custom","Promise","resolve","reject","signal","aborted","reason","immediate","ref","addEventListener","once","Symbol","dispose","for","internals","_onImmediate","NEXT_DEBUG_IMMEDIATES","inspect","writeFileSync","logLine","map","arg","colors","join","stdout","fd"],"mappings":";;;;;;;;AAAA,SAASA,SAAS,QAAQ,YAAW;AACrC,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,YAAY,QAAQ,oCAAmC;;;;AAOhE,IAAKC,iBAAAA,WAAAA,GAAAA,SAAAA,cAAAA;;;;;WAAAA;EAAAA,kBAAAA,CAAAA;AAOL,IAAIC,wBAAwB;AAE5B,IAAIC,mBAAmB;AACvB,IAAIC,mBAAqC;AAEzC,MAAMC,uBAAuBC,WAAWC,YAAY;AACpD,MAAMC,yBAAyBF,WAAWG,cAAc;AACxD,MAAMC,mBAAmBC,QAAQC,QAAQ;;AAIzC,SAASE;IACP,IAAIH,QAAQI,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,kFAAkF;QAClF,iEAAiE;QACjE;IACF,OAAO;;AAiBT;AAgEO,SAASS;IACd,IAAId,QAAQI,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIjB,mNAAAA,CACR,0FADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;AAsBT;AASO,SAASkC;IACd,IAAItB,QAAQI,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIjB,mNAAAA,CACR,mEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;AAUT;AAEA;;;GAGG,GACH,SAAS6B,wCAAwCF,SAAoB;IACnE,IAAIA,UAAUI,KAAK,KAAA,GAA6B;QAC9C,MAAM,OAAA,cAEL,CAFK,IAAI/B,mNAAAA,CACR,CAAC,6EAA6E,EAAEE,cAAc,CAACyB,UAAUI,KAAK,CAAC,CAAC,CAAC,CAAC,GAD9G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,8EAA8E;IAC9E,0CAA0C;IAC1C,wBAAwB;IACxB,EAAE;IACF,eAAe;IACf,iFAAiF;IACjF,gBAAgB;IAChB,2GAA2G;IAC3G,EAAE;IACF,yFAAyF;IACzF,8EAA8E;IAC9E,wEAAwE;IACxE,+DAA+D;IAC/D,6FAA6F;IAC7F,+EAA+E;IAE/EI,eAAe;QACb,2DAA2D;QAC3D,gFAAgF;QAChFxB,iBAAiB;YACf,gGAAgG;YAChG,uHAAuH;YACvH,wFAAwF;YACxF,2FAA2F;YAC3F,gFAAgF;YAChF,2EAA2E;YAE3E,IAAI;gBACF,IACEgB,UAAUI,KAAK,KAAA,KACf1B,qBAAqBsB,WACrB;oBACAT,SAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,wCAAwC,CAAC;oBAClD;gBACF;gBACA,IAAId,mBAAmB,GAAG;oBACxB,8EAA8E;oBAC9E,8FAA8F;oBAC9Fc,SAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,yBAAyB,EAAEd,iBAAiB,UAAU,CAAC;oBAChE,OAAOyB,wCAAwCF;gBACjD;gBAEA,+GAA+G;gBAC/G,qDAAqD;gBACrD,OAAOS,YAAYT;YACrB,EAAE,OAAOG,KAAK;gBACZ,sDAAsD;gBAEtD,6DAA6D;gBAC7D,kDAAkD;gBAClD,MAAMO,qBAAqBV;gBAC3B,IAAIU,mBAAmBN,KAAK,KAAA,GAA+B;oBACzD,MAAMD;gBACR;gBAEA,sEAAsE;gBACtE,iFAAiF;gBACjFK,eAAe;oBACbH,KACEL,WACA,OAAA,cAGC,CAHD,IAAI3B,mNAAAA,CACF,2DACA;wBAAEiC,OAAOH;oBAAI,IAFf,qBAAA;+BAAA;oCAAA;sCAAA;oBAGA;gBAEJ;YACF;QACF;IACF;AACF;AAEA,+FAA+F,GAC/F,SAASM,YAAYT,SAAoB;IACvC,IAAIA,UAAUI,KAAK,KAAA,GAA+B;QAChD;IACF;IAEAb,SAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,4BAA4B,CAAC;IAEtC,IAAIS,UAAUI,KAAK,KAAA,GAA6B;QAC9C,MAAM,OAAA,cAEL,CAFK,IAAI/B,mNAAAA,CACR,CAAC,qDAAqD,EAAEE,cAAc,CAACyB,UAAUI,KAAK,CAAC,CAAC,CAAC,CAAC,GADtF,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAJ,UAAUI,KAAK,GAAA;IAEf,MAAMO,YAAYC,wBAAwBZ;IAE1C,IAAIW,cAAc,MAAM;QACtBpB,SAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,0CAA0C,CAAC;QACpDsB,wBAAwBb;QACxB;IACF;IAEAT,SAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,uCAAuC,CAAC;IAEjD,MAAM,EAAEuB,eAAe,EAAEC,QAAQ,EAAEC,IAAI,EAAE,GAAGL;IAE5CG,eAAe,CAACG,UAAU,CAACN,SAAS,GAAG;IACvCO,eAAeP;IAEf,yBAAyB;IAEzB,yFAAyF;IACzF,6EAA6E;IAC7E,qFAAqF;IACrF,6HAA6H;IAC7H,0FAA0F;IAC1F,gGAAgG;IAChG,yFAAyF;IACzF,EAAE;IACF,yEAAyE;IACzE,0EAA0E;IAC1E,6FAA6F;IAC7F,EAAE;IACF,2FAA2F;IAC3F,kGAAkG;IAClG,8CAA8C;IAC9C,EAAE;IACF,6CAA6C;IAC7C,2GAA2G;IAC3G,uEAAuE;IACvE,yDAAyD;IACzD,wFAAwF;IACxF,wDAAwD;IACxD,EAAE;IACF,2FAA2F;IAC3F,wGAAwG;IACxG,wEAAwE;IAExE,IAAIQ,WAAW;IACf,IAAIC,cAAuBC;IAC3Bb,eAAe;QACb,IAAIW,UAAU;YACZ5B,SAAAA,OAAAA,KAAAA,IAAAA,MAAQ;YACR,MAAM6B;QACR;IACF;IAEA,IAAI;QACF,IAAIJ,SAAS,MAAM;YACjBD,SAASO,KAAK,CAAC,MAAMN;QACvB,OAAO;YACLD;QACF;IACF,EAAE,OAAOZ,KAAK;QACZ,kDAAkD;QAClDgB,WAAW;QACXC,cAAcjB;IAChB;IAEA,0EAA0E;IAC1E,kFAAkF;IAClF,mFAAmF;IACnFH,UAAUI,KAAK,GAAA;IACfF,wCAAwCF;AAC1C;AAEA,SAASY,wBAAwBZ,SAAoB;IACnD,gEAAgE;IAChE,kEAAkE;IAClE,8EAA8E;IAC9E,MAAM,EAAEuB,gBAAgB,EAAE,GAAGvB;IAE7B,IAAIwB,kBAA0C;IAC9C,IAAIC,uBAAuB,CAAC;IAC5B,IAAK,IAAIC,IAAI,GAAGA,IAAIH,iBAAiBI,MAAM,EAAED,IAAK;QAChD,MAAME,OAAOL,gBAAgB,CAACG,EAAE;QAChC,IAAI,CAACE,KAAKC,SAAS,EAAE;YACnBL,kBAAkBI;YAClBH,uBAAuBC;YACvB;QACF;IACF;IAEA,IAAIF,oBAAoB,MAAM;QAC5B,iCAAiC;QAEjC,+EAA+E;QAC/E,IAAID,iBAAiBI,MAAM,GAAG,GAAG;YAC/BJ,iBAAiBI,MAAM,GAAG;QAC5B;QAEA,OAAO;IACT;IAEA,6EAA6E;IAC7E,wGAAwG;IACxG,IAAIF,yBAAyB,GAAG;QAC9B,kCAAkC;QAClC,qFAAqF;QACrFF,iBAAiBO,KAAK;IACxB,OAAO;QACLP,iBAAiBQ,MAAM,CAAC,GAAGN,uBAAuB;IACpD;IAEA,OAAOD;AACT;AAEA,SAASvB;IACP,IAAIvB,qBAAqB,MAAM;QAC7B2B,KACE3B,kBACA,OAAA,cAEC,CAFD,IAAIL,mNAAAA,CACF,CAAC,oFAAoF,EAAEE,cAAc,CAACG,iBAAiB0B,KAAK,CAAC,CAAC,CAAC,CAAC,GADlI,qBAAA;mBAAA;wBAAA;0BAAA;QAEA;IAEJ;IACA5B,wBAAwB;IAExB,MAAMwB,YAAuB;QAC3BI,KAAK,EAAA;QACLmB,kBAAkB,EAAE;IACtB;IACA7C,mBAAmBsB;IAEnB,OAAOA;AACT;AAEA,SAASa,wBAAwBb,SAAoB;IACnD,IAAIA,UAAUI,KAAK,KAAA,GAA+B;QAChD;IACF;IAEA,4EAA4E;IAC5E,sEAAsE;IACtE,2DAA2D;IAC3D,IAAIJ,UAAUI,KAAK,KAAA,GAA6B;QAC9C,MAAM,OAAA,cAEL,CAFK,IAAI/B,mNAAAA,CACR,CAAC,sEAAsE,EAAEE,cAAc,CAACyB,UAAUI,KAAK,CAAC,CAAC,CAAC,CAAC,GADvG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEAJ,UAAUI,KAAK,GAAA;IAEf,IAAI1B,qBAAqBsB,WAAW;QAClCtB,mBAAmB;IACrB;AACF;AAEA,SAAS2B,KAAKL,SAAoB,EAAEgC,KAAY;IAC9C,6DAA6D;IAC7D,uFAAuF;IACvF,kDAAkD;IAElD,IAAItD,qBAAqBsB,WAAW;QAClCtB,mBAAmB;IACrB;IAEAsB,UAAUI,KAAK,GAAA;IAEf,kGAAkG;IAClG,4EAA4E;IAC5E,iFAAiF;IACjF,4EAA4E;IAC5E,kCAAkC;IAClC,KAAK,MAAMO,aAAaX,UAAUuB,gBAAgB,CAAE;QAClD,IAAIZ,UAAUkB,SAAS,EAAE;YACvB;QACF;QACAI,yCAAyCtB;IAC3C;IACAX,UAAUuB,gBAAgB,CAACI,MAAM,GAAG;IAEpC,4FAA4F;IAC5F,yFAAyF;IAEzF,MAAMK;AACR;AAEA,SAASC,yCAAyCtB,SAA0B;IAC1E,MAAM,EAAEI,QAAQ,EAAEC,IAAI,EAAEF,eAAe,EAAE,GAAGH;IAC5C,MAAMuB,SAASpB,eAAe,CAACG,UAAU,CAACiB,MAAM;IAEhDhB,eAAeP;IAEf,MAAMwB,kBACJnB,SAAS,OACLrC,qBAAqBoC,aAAaC,QAClCrC,qBAAqBoC;IAE3B,IAAI,CAACmB,QAAQ;QACXC,gBAAgBC,KAAK;IACvB;IAEA,+DAA+D;IAC/D,uEAAuE;IACvEC,sCAAsCvB,iBAAiBqB;AACzD;AAgBA,SAASjB,eAAeoB,iBAA4B;IAClD,MAAM3B,YAAY2B;IAClB3B,UAAUkB,SAAS,GAAG;IACtBlB,UAAUI,QAAQ,GAAG;IACrBJ,UAAUK,IAAI,GAAG;IACjBL,UAAUG,eAAe,GAAG;AAC9B;AAQA,SAAShB;IACP,IAAIpB,qBAAqB,MAAM;QAC7B,OAAOM,iBAAiBsC,KAAK,CAC3B,MACA,AACAiB,iEADiE;IAGrE;IAEA,IAAIA,UAAUZ,MAAM,KAAK,KAAK,OAAOY,SAAS,CAAC,EAAE,KAAK,YAAY;QAChE,wDAAwD;QACxD,qDAAqD;QACrDvD,iBAAiBsC,KAAK,CACpB,MACA,AACAiB,0EAD0E;QAI5E,uEAAuE;QACvElC,KACE3B,kBACA,OAAA,cAEC,CAFD,IAAIL,mNAAAA,CACF,0DADF,qBAAA;mBAAA;wBAAA;0BAAA;QAEA;IAEJ;IAEAkB,SAAAA,OAAAA,KAAAA,IAAAA,MACE,CAAC,wDAAwD,EAAEd,iBAAiB,CAAC,CAAC;IAGhF,MAAMsC,WAAoCwB,SAAS,CAAC,EAAE;IACtD,MAAMvB,OACJuB,UAAUZ,MAAM,GAAG,IAAIa,MAAMC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACJ,WAAW,KAAK;IAEpE9D,oBAAoB;IACpB,OAAOO,iBAAiB4D,2BAA2B7B,UAAUC;AAC/D;AAEA,SAAS4B,0BACP7B,QAAiC,EACjCC,IAAkB;IAElBvC,oBAAoB;IACpBc,SAAAA,OAAAA,KAAAA,IAAAA,MACE,CAAC,wDAAwD,EAAEd,iBAAiB,CAAC,CAAC;IAGhF,uFAAuF;IACvF,iFAAiF;IACjF,oFAAoF;IACpF,IAAI;QACF,IAAIuC,SAAS,MAAM;YACjBD,SAASO,KAAK,CAAC,MAAMN;QACvB,OAAO;YACLD;QACF;IACF,EAAE,OAAOZ,KAAK;QACZ,qEAAqE;QACrE,2DAA2D;QAC3D,yEAAyE;QACzE,+DAA+D;QAC/D,wEAAwE;QACxEK,eAAe;YACbjB,SAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,+DAA+D,CAAC;YACzE,MAAMY;QACR;IACF;AACF;AAOA,SAAST;IACP,IAAIhB,qBAAqB,MAAM;QAC7B,OAAOC,qBAAqB2C,KAAK,CAC/B,MACA,AACAiB,iEADiE;IAGrE;IAEA,IAAIA,UAAUZ,MAAM,KAAK,KAAK,OAAOY,SAAS,CAAC,EAAE,KAAK,YAAY;QAChE,4DAA4D;QAC5D,qDAAqD;QACrD5D,qBAAqB2C,KAAK,CACxB,MACA,AACAiB,0EAD0E;QAI5E,uEAAuE;QACvElC,KACE3B,kBACA,OAAA,cAAuE,CAAvE,IAAIL,mNAAAA,CAAe,sDAAnB,qBAAA;mBAAA;wBAAA;0BAAA;QAAsE;IAE1E;IAEA,MAAM0C,WAAoCwB,SAAS,CAAC,EAAE;IACtD,MAAMvB,OACJuB,UAAUZ,MAAM,GAAG,IAAIa,MAAMC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACJ,WAAW,KAAK;IAEpE,iFAAiF;IACjF,8EAA8E;IAC9E,MAAMM,+BAA2BvE,kOAAAA,EAAayC;IAE9C,MAAMD,kBAAkB,IAAIgC;IAE5B,MAAMnC,YAA6B;QACjCkB,WAAW;QACXd,UAAU8B;QACV7B;QACAF;IACF;IACApC,iBAAiB6C,gBAAgB,CAACwB,IAAI,CAACpC;IAEvCG,eAAe,CAACG,UAAU,CAACN,SAAS,GAAGA;IAEvC,OAAOG;AACT;AAEA,SAASjB,2BACPmD,KAAQ,EACRC,OAA4C;IAE5C,IAAIvE,qBAAqB,MAAM;QAC7B,MAAMwE,oBACJ,AACAvE,oBAAoB,CAACP,4CAD4C,kFAC5CA,CAAU+E,MAAM,CAAC;QACxC,OAAOD,kBAAkBF,OAAOC;IAClC;IAEA,OAAO,IAAIG,QAAW,CAACC,SAASC;QAC9B,6CAA6C;QAC7C,mDAAmD;QACnD,MAAMC,SAASN,WAAAA,OAAAA,KAAAA,IAAAA,QAASM,MAAM;QAC9B,IAAIA,UAAUA,OAAOC,OAAO,EAAE;YAC5B,OAAOF,OAAOC,OAAOE,MAAM;QAC7B;QAEA,MAAMC,YAAYhE,oBAAoB2D,SAASL;QAE/C,uFAAuF;QACvF,gCAAgC;QAChC,IAAIC,CAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASU,GAAG,MAAK,OAAO;YAC1BD,UAAUtB,KAAK;QACjB;QAEA,IAAImB,QAAQ;YACVA,OAAOK,gBAAgB,CACrB,SACA;gBACEjE,sBAAsB+D;gBACtBJ,OAAOC,OAAOE,MAAM;YACtB,GACA;gBAAEI,MAAM;YAAK;QAEjB;IACF;AACF;AAEAnE,mBAAmB,CAACtB,8HAAAA,CAAU+E,MAAM,CAAC,GAAGtD;AAExC,MAAMF,wBAAwB,CAC5BmB;IAEA,sEAAsE;IACtE,oEAAoE;IACpE,oEAAoE;IACpE,gFAAgF;IAChF,uDAAuD;IACvD,IACEtC,yBACAsC,mBACA,OAAOA,oBAAoB,YAC3BG,aAAaH,iBACb;;QACEA,eAAiC,CAACgD,OAAOC,OAAO,CAAC;IACrD,OAAO;QACLjF,uBAAuBgC;IACzB;AACF;AAEA,0DAA0D;AAE1D,MAAMG,YAA2B6C,OAAOE,GAAG,CAAC;AAe5C,SAAS3B,sCACPvB,eAA8B,EAC9BqB,eAAiC;IAEjCrB,eAAe,CAACG,UAAU,CAACiB,MAAM,GAAG;IACpCpB,eAAe,CAACG,UAAU,CAACN,SAAS,GAAG;IACvCG,eAAe,CAACG,UAAU,CAACkB,eAAe,GAAGA;AAC/C;AAKA,kFAAkF,GAClF,MAAMW;IAMJZ,SAAS;QACP,MAAM+B,YAAY,IAAI,CAAChD,UAAU;QACjC,IAAIgD,UAAUtD,SAAS,EAAE;YACvB,OAAOsD,UAAU/B,MAAM;QACzB,OAAO,IAAI+B,UAAU9B,eAAe,EAAE;YACpC,OAAO8B,UAAU9B,eAAe,CAACD,MAAM;QACzC,OAAO;YACL,0EAA0E;YAC1E,OAAO;QACT;IACF;IACAyB,MAAM;QACJ,MAAMM,YAAY,IAAI,CAAChD,UAAU;QACjC,IAAIgD,UAAUtD,SAAS,EAAE;YACvBsD,UAAU/B,MAAM,GAAG;QACrB,OAAO,IAAI+B,UAAU9B,eAAe,EAAE;YACpC8B,UAAU9B,eAAe,CAACwB,GAAG;QAC/B;QACA,OAAO,IAAI;IACb;IACAvB,QAAQ;QACN,MAAM6B,YAAY,IAAI,CAAChD,UAAU;QACjC,IAAIgD,UAAUtD,SAAS,EAAE;YACvBsD,UAAU/B,MAAM,GAAG;QACrB,OAAO,IAAI+B,UAAU9B,eAAe,EAAE;YACpC8B,UAAU9B,eAAe,CAACC,KAAK;QACjC;QACA,OAAO,IAAI;IACb;IAEA;;;;KAIG,GACH8B,eAAe,CAAC;IAEhB,CAACJ,OAAOC,OAAO,CAAC,GAAG;QACjB,0CAA0C;QAC1C,MAAME,YAAY,IAAI,CAAChD,UAAU;QACjC,IAAIgD,UAAUtD,SAAS,EAAE;YACvB,iCAAiC;YACjC,MAAMA,YAAYsD,UAAUtD,SAAS;YACrCsD,UAAUtD,SAAS,GAAG;YACtBO,eAAeP;QACjB,OAAO,IAAIsD,UAAU9B,eAAe,EAAE;YACpC8B,UAAU9B,eAAe,CAAC2B,OAAOC,OAAO,CAAC;QAC3C;IACF;;YArDA,CAAC9C,UAAU,GAA2B;YACpCN,WAAW;YACXuB,QAAQ;YACRC,iBAAiB;QACnB;;AAkDF;AAEA,6CAA6C;AAE7C,MAAM5C,QACJN,QAAQI,GAAG,CAAC8E,qBAAqB,KAAK,MAClC9C,YACA,CAAC,GAAGL;IACF,IAAI/B,QAAQI,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,IAAIjB,mNAAAA,CACR,4DADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;AAeT;AAEN,6CAA6C;AAE7Ce","ignoreList":[0]}},
    {"offset": {"line": 6733, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/server-utils.ts"],"sourcesContent":["import type { Rewrite } from '../lib/load-custom-routes'\nimport type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'\nimport type { NextConfig } from './config'\nimport type { BaseNextRequest } from './base-http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\n\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport { getPathMatch } from '../shared/lib/router/utils/path-match'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\nimport {\n  matchHas,\n  prepareDestination,\n} from '../shared/lib/router/utils/prepare-destination'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { normalizeRscURL } from '../shared/lib/router/utils/app-paths'\nimport {\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_INTERCEPTION_MARKER_PREFIX,\n  NEXT_QUERY_PARAM_PREFIX,\n} from '../lib/constants'\nimport { normalizeNextQueryParam } from './web/utils'\nimport type { IncomingHttpHeaders, IncomingMessage } from 'http'\nimport { decodeQueryPathParameter } from './lib/decode-query-path-parameter'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { parseReqUrl } from '../lib/url'\nimport { formatUrl } from '../shared/lib/router/utils/format-url'\n\nfunction filterInternalQuery(\n  query: Record<string, undefined | string | string[]>,\n  paramKeys: string[]\n) {\n  // this is used to pass query information in rewrites\n  // but should not be exposed in final query\n  delete query['nextInternalLocale']\n\n  for (const key in query) {\n    const isNextQueryPrefix =\n      key !== NEXT_QUERY_PARAM_PREFIX && key.startsWith(NEXT_QUERY_PARAM_PREFIX)\n\n    const isNextInterceptionMarkerPrefix =\n      key !== NEXT_INTERCEPTION_MARKER_PREFIX &&\n      key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)\n\n    if (\n      isNextQueryPrefix ||\n      isNextInterceptionMarkerPrefix ||\n      paramKeys.includes(key)\n    ) {\n      delete query[key]\n    }\n  }\n}\n\nexport function normalizeCdnUrl(\n  req: BaseNextRequest | IncomingMessage,\n  paramKeys: string[]\n) {\n  // make sure to normalize req.url from CDNs to strip dynamic and rewrite\n  // params from the query which are added during routing\n  const _parsedUrl = parseReqUrl(req.url!)\n\n  // we can't normalize if we can't parse\n  if (!_parsedUrl) {\n    return req.url\n  }\n  delete (_parsedUrl as any).search\n  filterInternalQuery(_parsedUrl.query, paramKeys)\n\n  req.url = formatUrl(_parsedUrl)\n}\n\nexport function interpolateDynamicPath(\n  pathname: string,\n  params: ParsedUrlQuery,\n  defaultRouteRegex?: ReturnType<typeof getNamedRouteRegex> | undefined\n) {\n  if (!defaultRouteRegex) return pathname\n\n  for (const param of Object.keys(defaultRouteRegex.groups)) {\n    const { optional, repeat } = defaultRouteRegex.groups[param]\n    let builtParam = `[${repeat ? '...' : ''}${param}]`\n\n    if (optional) {\n      builtParam = `[${builtParam}]`\n    }\n\n    let paramValue: string\n    const value = params[param]\n\n    if (Array.isArray(value)) {\n      paramValue = value.map((v) => v && encodeURIComponent(v)).join('/')\n    } else if (value) {\n      paramValue = encodeURIComponent(value)\n    } else {\n      paramValue = ''\n    }\n\n    if (paramValue || optional) {\n      pathname = pathname.replaceAll(builtParam, paramValue)\n    }\n  }\n\n  return pathname\n}\n\nexport function normalizeDynamicRouteParams(\n  query: ParsedUrlQuery,\n  defaultRouteRegex: ReturnType<typeof getNamedRouteRegex>,\n  defaultRouteMatches: ParsedUrlQuery,\n  ignoreMissingOptional: boolean\n) {\n  let hasValidParams = true\n  let params: ParsedUrlQuery = {}\n\n  for (const key of Object.keys(defaultRouteRegex.groups)) {\n    let value: string | string[] | undefined = query[key]\n\n    if (typeof value === 'string') {\n      value = normalizeRscURL(value)\n    } else if (Array.isArray(value)) {\n      value = value.map(normalizeRscURL)\n    }\n\n    // if the value matches the default value we can't rely\n    // on the parsed params, this is used to signal if we need\n    // to parse x-now-route-matches or not\n    const defaultValue = defaultRouteMatches![key]\n    const isOptional = defaultRouteRegex!.groups[key].optional\n\n    const isDefaultValue = Array.isArray(defaultValue)\n      ? defaultValue.some((defaultVal) => {\n          return Array.isArray(value)\n            ? value.some((val) => val.includes(defaultVal))\n            : value?.includes(defaultVal)\n        })\n      : value?.includes(defaultValue as string)\n\n    if (\n      isDefaultValue ||\n      (typeof value === 'undefined' && !(isOptional && ignoreMissingOptional))\n    ) {\n      return { params: {}, hasValidParams: false }\n    }\n\n    // non-provided optional values should be undefined so normalize\n    // them to undefined\n    if (\n      isOptional &&\n      (!value ||\n        (Array.isArray(value) &&\n          value.length === 1 &&\n          // fallback optional catch-all SSG pages have\n          // [[...paramName]] for the root path on Vercel\n          (value[0] === 'index' || value[0] === `[[...${key}]]`)) ||\n        value === 'index' ||\n        value === `[[...${key}]]`)\n    ) {\n      value = undefined\n      delete query[key]\n    }\n\n    // query values from the proxy aren't already split into arrays\n    // so make sure to normalize catch-all values\n    if (\n      value &&\n      typeof value === 'string' &&\n      defaultRouteRegex!.groups[key].repeat\n    ) {\n      value = value.split('/')\n    }\n\n    if (value) {\n      params[key] = value\n    }\n  }\n\n  return {\n    params,\n    hasValidParams,\n  }\n}\n\nexport function getServerUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic,\n  trailingSlash,\n  caseSensitive,\n}: {\n  page: string\n  i18n?: NextConfig['i18n']\n  basePath: string\n  rewrites: DeepReadonly<{\n    fallback?: ReadonlyArray<Rewrite>\n    afterFiles?: ReadonlyArray<Rewrite>\n    beforeFiles?: ReadonlyArray<Rewrite>\n  }>\n  pageIsDynamic: boolean\n  trailingSlash?: boolean\n  caseSensitive: boolean\n}) {\n  let defaultRouteRegex: ReturnType<typeof getNamedRouteRegex> | undefined\n  let dynamicRouteMatcher: RouteMatchFn | undefined\n  let defaultRouteMatches: ParsedUrlQuery | undefined\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = getNamedRouteRegex(page, {\n      prefixRouteKeys: false,\n    })\n    dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)\n    defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery\n  }\n\n  function handleRewrites(\n    req: BaseNextRequest | IncomingMessage,\n    parsedUrl: DeepReadonly<UrlWithParsedQuery>\n  ) {\n    // Here we deep clone the parsedUrl to avoid mutating the original. We also\n    // cast this to a mutable type so we can mutate it within this scope.\n    const rewrittenParsedUrl = structuredClone(parsedUrl) as UrlWithParsedQuery\n    const rewriteParams: Record<string, string> = {}\n    let fsPathname = rewrittenParsedUrl.pathname\n\n    const matchesPage = () => {\n      const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')\n      return (\n        fsPathnameNoSlash === removeTrailingSlash(page) ||\n        dynamicRouteMatcher?.(fsPathnameNoSlash)\n      )\n    }\n\n    const checkRewrite = (rewrite: DeepReadonly<Rewrite>): boolean => {\n      const matcher = getPathMatch(\n        rewrite.source + (trailingSlash ? '(/)?' : ''),\n        {\n          removeUnnamedParams: true,\n          strict: true,\n          sensitive: !!caseSensitive,\n        }\n      )\n\n      if (!rewrittenParsedUrl.pathname) return false\n\n      let params = matcher(rewrittenParsedUrl.pathname)\n\n      if ((rewrite.has || rewrite.missing) && params) {\n        const hasParams = matchHas(\n          req,\n          rewrittenParsedUrl.query,\n          rewrite.has as Rewrite['has'],\n          rewrite.missing as Rewrite['missing']\n        )\n\n        if (hasParams) {\n          Object.assign(params, hasParams)\n        } else {\n          params = false\n        }\n      }\n\n      if (params) {\n        const { parsedDestination, destQuery } = prepareDestination({\n          appendParamsToQuery: true,\n          destination: rewrite.destination,\n          params: params,\n          query: rewrittenParsedUrl.query,\n        })\n\n        // if the rewrite destination is external break rewrite chain\n        if (parsedDestination.protocol) {\n          return true\n        }\n\n        Object.assign(rewriteParams, destQuery, params)\n        Object.assign(rewrittenParsedUrl.query, parsedDestination.query)\n        delete (parsedDestination as any).query\n\n        Object.assign(rewrittenParsedUrl, parsedDestination)\n\n        fsPathname = rewrittenParsedUrl.pathname\n        if (!fsPathname) return false\n\n        if (basePath) {\n          fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'\n        }\n\n        if (i18n) {\n          const result = normalizeLocalePath(fsPathname, i18n.locales)\n          fsPathname = result.pathname\n          rewrittenParsedUrl.query.nextInternalLocale =\n            result.detectedLocale || params.nextInternalLocale\n        }\n\n        if (fsPathname === page) {\n          return true\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname)\n          if (dynamicParams) {\n            rewrittenParsedUrl.query = {\n              ...rewrittenParsedUrl.query,\n              ...dynamicParams,\n            }\n            return true\n          }\n        }\n      }\n\n      return false\n    }\n\n    for (const rewrite of rewrites.beforeFiles || []) {\n      checkRewrite(rewrite)\n    }\n\n    if (fsPathname !== page) {\n      let finished = false\n\n      for (const rewrite of rewrites.afterFiles || []) {\n        finished = checkRewrite(rewrite)\n        if (finished) break\n      }\n\n      if (!finished && !matchesPage()) {\n        for (const rewrite of rewrites.fallback || []) {\n          finished = checkRewrite(rewrite)\n          if (finished) break\n        }\n      }\n    }\n\n    return { rewriteParams, rewrittenParsedUrl }\n  }\n\n  function getParamsFromRouteMatches(routeMatchesHeader: string) {\n    // If we don't have a default route regex, we can't get params from route\n    // matches\n    if (!defaultRouteRegex) return null\n\n    const { groups, routeKeys } = defaultRouteRegex\n\n    const matcher = getRouteMatcher({\n      re: {\n        // Simulate a RegExp match from the \\`req.url\\` input\n        exec: (str: string) => {\n          // Normalize all the prefixed query params.\n          const obj: Record<string, string> = Object.fromEntries(\n            new URLSearchParams(str)\n          )\n          for (const [key, value] of Object.entries(obj)) {\n            const normalizedKey = normalizeNextQueryParam(key)\n            if (!normalizedKey) continue\n\n            obj[normalizedKey] = value\n            delete obj[key]\n          }\n\n          // Use all the named route keys.\n          const result = {} as RegExpExecArray\n          for (const keyName of Object.keys(routeKeys)) {\n            const paramName = routeKeys[keyName]\n\n            // If this param name is not a valid parameter name, then skip it.\n            if (!paramName) continue\n\n            const group = groups[paramName]\n            const value = obj[keyName]\n\n            // When we're missing a required param, we can't match the route.\n            if (!group.optional && !value) return null\n\n            result[group.pos] = value\n          }\n\n          return result\n        },\n      },\n      groups,\n    })\n\n    const routeMatches = matcher(routeMatchesHeader)\n    if (!routeMatches) return null\n\n    return routeMatches\n  }\n\n  function normalizeQueryParams(\n    query: Record<string, string | string[] | undefined>,\n    routeParamKeys: Set<string>\n  ) {\n    // this is used to pass query information in rewrites\n    // but should not be exposed in final query\n    delete query['nextInternalLocale']\n\n    for (const [key, value] of Object.entries(query)) {\n      const normalizedKey = normalizeNextQueryParam(key)\n      if (!normalizedKey) continue\n\n      // Remove the prefixed key from the query params because we want\n      // to consume it for the dynamic route matcher.\n      delete query[key]\n      routeParamKeys.add(normalizedKey)\n\n      if (typeof value === 'undefined') continue\n\n      query[normalizedKey] = Array.isArray(value)\n        ? value.map((v) => decodeQueryPathParameter(v))\n        : decodeQueryPathParameter(value)\n    }\n  }\n\n  return {\n    handleRewrites,\n    defaultRouteRegex,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    normalizeQueryParams,\n    getParamsFromRouteMatches,\n    /**\n     * Normalize dynamic route params.\n     *\n     * @param query - The query params to normalize.\n     * @param ignoreMissingOptional - Whether to ignore missing optional params.\n     * @returns The normalized params and whether they are valid.\n     */\n    normalizeDynamicRouteParams: (\n      query: ParsedUrlQuery,\n      ignoreMissingOptional: boolean\n    ) => {\n      if (!defaultRouteRegex || !defaultRouteMatches) {\n        return { params: {}, hasValidParams: false }\n      }\n\n      return normalizeDynamicRouteParams(\n        query,\n        defaultRouteRegex,\n        defaultRouteMatches,\n        ignoreMissingOptional\n      )\n    },\n\n    normalizeCdnUrl: (\n      req: BaseNextRequest | IncomingMessage,\n      paramKeys: string[]\n    ) => normalizeCdnUrl(req, paramKeys),\n\n    interpolateDynamicPath: (\n      pathname: string,\n      params: Record<string, undefined | string | string[]>\n    ) => interpolateDynamicPath(pathname, params, defaultRouteRegex),\n\n    filterInternalQuery: (query: ParsedUrlQuery, paramKeys: string[]) =>\n      filterInternalQuery(query, paramKeys),\n  }\n}\n\nexport function getPreviouslyRevalidatedTags(\n  headers: IncomingHttpHeaders,\n  previewModeId: string | undefined\n): string[] {\n  return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &&\n    headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId\n    ? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')\n    : []\n}\n"],"names":["normalizeLocalePath","getPathMatch","getNamedRouteRegex","getRouteMatcher","matchHas","prepareDestination","removeTrailingSlash","normalizeRscURL","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_INTERCEPTION_MARKER_PREFIX","NEXT_QUERY_PARAM_PREFIX","normalizeNextQueryParam","decodeQueryPathParameter","parseReqUrl","formatUrl","filterInternalQuery","query","paramKeys","key","isNextQueryPrefix","startsWith","isNextInterceptionMarkerPrefix","includes","normalizeCdnUrl","req","_parsedUrl","url","search","interpolateDynamicPath","pathname","params","defaultRouteRegex","param","Object","keys","groups","optional","repeat","builtParam","paramValue","value","Array","isArray","map","v","encodeURIComponent","join","replaceAll","normalizeDynamicRouteParams","defaultRouteMatches","ignoreMissingOptional","hasValidParams","defaultValue","isOptional","isDefaultValue","some","defaultVal","val","length","undefined","split","getServerUtils","page","i18n","basePath","rewrites","pageIsDynamic","trailingSlash","caseSensitive","dynamicRouteMatcher","prefixRouteKeys","handleRewrites","parsedUrl","rewrittenParsedUrl","structuredClone","rewriteParams","fsPathname","matchesPage","fsPathnameNoSlash","checkRewrite","rewrite","matcher","source","removeUnnamedParams","strict","sensitive","has","missing","hasParams","assign","parsedDestination","destQuery","appendParamsToQuery","destination","protocol","replace","RegExp","result","locales","nextInternalLocale","detectedLocale","dynamicParams","beforeFiles","finished","afterFiles","fallback","getParamsFromRouteMatches","routeMatchesHeader","routeKeys","re","exec","str","obj","fromEntries","URLSearchParams","entries","normalizedKey","keyName","paramName","group","pos","routeMatches","normalizeQueryParams","routeParamKeys","add","getPreviouslyRevalidatedTags","headers","previewModeId"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7048, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-modules/route-module.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'node:http'\nimport type {\n  InstrumentationOnRequestError,\n  RequestErrorContext,\n} from '../instrumentation/types'\nimport type { ParsedUrlQuery } from 'node:querystring'\nimport type { UrlWithParsedQuery } from 'node:url'\nimport type {\n  PrerenderManifest,\n  RequiredServerFilesManifest,\n} from '../../build'\nimport type { DevRoutesManifest } from '../lib/router-utils/setup-dev-bundler'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport {\n  BUILD_ID_FILE,\n  BUILD_MANIFEST,\n  CLIENT_REFERENCE_MANIFEST,\n  DYNAMIC_CSS_MANIFEST,\n  NEXT_FONT_MANIFEST,\n  PRERENDER_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n  ROUTES_MANIFEST,\n  SERVER_FILES_MANIFEST,\n  SERVER_REFERENCE_MANIFEST,\n  SUBRESOURCE_INTEGRITY_MANIFEST,\n} from '../../shared/lib/constants'\nimport { parseReqUrl } from '../../lib/url'\nimport {\n  normalizeLocalePath,\n  type PathLocale,\n} from '../../shared/lib/i18n/normalize-locale-path'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { getServerUtils } from '../server-utils'\nimport { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'\nimport { getHostname } from '../../shared/lib/get-hostname'\nimport { checkIsOnDemandRevalidate } from '../api-utils'\nimport type { PreviewData } from '../../types'\nimport type { BuildManifest } from '../get-page-files'\nimport type { ReactLoadableManifest } from '../load-components'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport {\n  addRequestMeta,\n  getRequestMeta,\n  type NextIncomingMessage,\n} from '../request-meta'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\nimport { isStaticMetadataRoute } from '../../lib/metadata/is-metadata-route'\nimport { IncrementalCache } from '../lib/incremental-cache'\nimport { initializeCacheHandlers, setCacheHandler } from '../use-cache/handlers'\nimport { interopDefault } from '../app-render/interop-default'\nimport { RouteKind } from '../route-kind'\nimport type { BaseNextRequest } from '../base-http'\nimport type { I18NConfig, NextConfigRuntime } from '../config-shared'\nimport ResponseCache, { type ResponseGenerator } from '../response-cache'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport {\n  RouterServerContextSymbol,\n  routerServerGlobal,\n  type RouterServerContext,\n} from '../lib/router-utils/router-server-context'\nimport { decodePathParams } from '../lib/router-utils/decode-path-params'\nimport { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash'\nimport { isInterceptionRouteRewrite } from '../../lib/generate-interception-routes-rewrites'\n\n/**\n * RouteModuleOptions is the options that are passed to the route module, other\n * route modules should extend this class to add specific options for their\n * route.\n */\nexport interface RouteModuleOptions<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  readonly definition: Readonly<D>\n  readonly userland: Readonly<U>\n  readonly distDir: string\n  readonly relativeProjectDir: string\n}\n\n/**\n * RouteHandlerContext is the base context for a route handler.\n */\nexport interface RouteModuleHandleContext {\n  /**\n   * Any matched parameters for the request. This is only defined for dynamic\n   * routes.\n   */\n  params: Record<string, string | string[] | undefined> | undefined\n}\n\nconst dynamicImportEsmDefault = (id: string) =>\n  import(/* webpackIgnore: true */ /* turbopackIgnore: true */ id).then(\n    (mod) => mod.default || mod\n  )\n\n/**\n * RouteModule is the base class for all route modules. This class should be\n * extended by all route modules.\n */\nexport abstract class RouteModule<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  /**\n   * The userland module. This is the module that is exported from the user's\n   * code. This is marked as readonly to ensure that the module is not mutated\n   * because the module (when compiled) only provides getters.\n   */\n  public readonly userland: Readonly<U>\n\n  /**\n   * The definition of the route.\n   */\n  public readonly definition: Readonly<D>\n\n  /**\n   * The shared modules that are exposed and required for the route module.\n   */\n  public static readonly sharedModules: any\n\n  public isDev: boolean\n  public distDir: string\n  public relativeProjectDir: string\n  public incrementCache?: IncrementalCache\n  public responseCache?: ResponseCache\n\n  constructor({\n    userland,\n    definition,\n    distDir,\n    relativeProjectDir,\n  }: RouteModuleOptions<D, U>) {\n    this.userland = userland\n    this.definition = definition\n    this.isDev = process.env.NODE_ENV === 'development'\n    this.distDir = distDir\n    this.relativeProjectDir = relativeProjectDir\n  }\n\n  public async instrumentationOnRequestError(\n    req: IncomingMessage | BaseNextRequest,\n    ...args: Parameters<InstrumentationOnRequestError>\n  ) {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      const { getEdgeInstrumentationModule } = await import('../web/globals')\n      const instrumentation = await getEdgeInstrumentationModule()\n\n      if (instrumentation) {\n        await instrumentation.onRequestError?.(...args)\n      }\n    } else {\n      const { join } = require('node:path') as typeof import('node:path')\n      const absoluteProjectDir = join(\n        /* turbopackIgnore: true */\n        process.cwd(),\n        getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n      )\n\n      const { instrumentationOnRequestError } = await import(\n        '../lib/router-utils/instrumentation-globals.external.js'\n      )\n\n      return instrumentationOnRequestError(\n        absoluteProjectDir,\n        this.distDir,\n        ...args\n      )\n    }\n  }\n\n  private loadManifests(\n    srcPage: string,\n    projectDir?: string\n  ): {\n    buildId: string\n    buildManifest: BuildManifest\n    fallbackBuildManifest: BuildManifest\n    routesManifest: DeepReadonly<DevRoutesManifest>\n    nextFontManifest: DeepReadonly<NextFontManifest>\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n    serverFilesManifest: DeepReadonly<RequiredServerFilesManifest> | undefined\n    reactLoadableManifest: DeepReadonly<ReactLoadableManifest>\n    subresourceIntegrityManifest: any\n    clientReferenceManifest: any\n    serverActionsManifest: any\n    dynamicCssManifest: any\n    interceptionRoutePatterns: RegExp[]\n  } {\n    let result\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      const { getEdgePreviewProps } =\n        require('../web/get-edge-preview-props') as typeof import('../web/get-edge-preview-props')\n\n      const maybeJSONParse = (str?: string) =>\n        str ? JSON.parse(str) : undefined\n\n      result = {\n        buildId: process.env.__NEXT_BUILD_ID || '',\n        buildManifest: self.__BUILD_MANIFEST as any,\n        fallbackBuildManifest: {} as any,\n        reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),\n        nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),\n        prerenderManifest: {\n          routes: {},\n          dynamicRoutes: {},\n          notFoundRoutes: [],\n          version: 4,\n          preview: getEdgePreviewProps(),\n        } as const,\n        routesManifest: {\n          version: 4,\n          caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),\n          basePath: process.env.__NEXT_BASE_PATH || '',\n          rewrites: (process.env.__NEXT_REWRITES as any) || {\n            beforeFiles: [],\n            afterFiles: [],\n            fallback: [],\n          },\n          redirects: [],\n          headers: [],\n          i18n:\n            (process.env.__NEXT_I18N_CONFIG as any as I18NConfig) || undefined,\n          skipProxyUrlNormalize: Boolean(\n            process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE\n          ),\n        },\n        serverFilesManifest: self.__SERVER_FILES_MANIFEST,\n        clientReferenceManifest: self.__RSC_MANIFEST?.[srcPage],\n        serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),\n        subresourceIntegrityManifest: maybeJSONParse(\n          self.__SUBRESOURCE_INTEGRITY_MANIFEST\n        ),\n        dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),\n        interceptionRoutePatterns: (\n          maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []\n        ).map((rewrite: any) => new RegExp(rewrite.regex)),\n      }\n    } else {\n      if (!projectDir) {\n        throw new Error('Invariant: projectDir is required for node runtime')\n      }\n      const { loadManifestFromRelativePath } =\n        require('../load-manifest.external') as typeof import('../load-manifest.external')\n      const normalizedPagePath = normalizePagePath(srcPage)\n\n      const router =\n        this.definition.kind === RouteKind.PAGES ||\n        this.definition.kind === RouteKind.PAGES_API\n          ? 'pages'\n          : 'app'\n\n      const [\n        routesManifest,\n        prerenderManifest,\n        buildManifest,\n        fallbackBuildManifest,\n        reactLoadableManifest,\n        nextFontManifest,\n        clientReferenceManifest,\n        serverActionsManifest,\n        subresourceIntegrityManifest,\n        serverFilesManifest,\n        buildId,\n        dynamicCssManifest,\n      ] = [\n        loadManifestFromRelativePath<DevRoutesManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: ROUTES_MANIFEST,\n          shouldCache: !this.isDev,\n        }),\n        loadManifestFromRelativePath<PrerenderManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: PRERENDER_MANIFEST,\n          shouldCache: !this.isDev,\n        }),\n        loadManifestFromRelativePath<BuildManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: BUILD_MANIFEST,\n          shouldCache: !this.isDev,\n        }),\n        srcPage === '/_error'\n          ? loadManifestFromRelativePath<BuildManifest>({\n              projectDir,\n              distDir: this.distDir,\n              manifest: `fallback-${BUILD_MANIFEST}`,\n              shouldCache: !this.isDev,\n              handleMissing: true,\n            })\n          : ({} as BuildManifest),\n        loadManifestFromRelativePath<ReactLoadableManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: process.env.TURBOPACK\n            ? `server/${router === 'app' ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`\n            : REACT_LOADABLE_MANIFEST,\n          handleMissing: true,\n          shouldCache: !this.isDev,\n        }),\n        loadManifestFromRelativePath<NextFontManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: `server/${NEXT_FONT_MANIFEST}.json`,\n          shouldCache: !this.isDev,\n        }),\n        router === 'app' && !isStaticMetadataRoute(srcPage)\n          ? loadManifestFromRelativePath({\n              distDir: this.distDir,\n              projectDir,\n              useEval: true,\n              handleMissing: true,\n              manifest: `server/app${srcPage.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST}.js`,\n              shouldCache: !this.isDev,\n            })\n          : undefined,\n        router === 'app'\n          ? loadManifestFromRelativePath<any>({\n              distDir: this.distDir,\n              projectDir,\n              manifest: `server/${SERVER_REFERENCE_MANIFEST}.json`,\n              handleMissing: true,\n              shouldCache: !this.isDev,\n            })\n          : {},\n        loadManifestFromRelativePath<Record<string, string>>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: `server/${SUBRESOURCE_INTEGRITY_MANIFEST}.json`,\n          handleMissing: true,\n          shouldCache: !this.isDev,\n        }),\n        this.isDev\n          ? undefined\n          : loadManifestFromRelativePath<RequiredServerFilesManifest>({\n              projectDir,\n              distDir: this.distDir,\n              manifest: `${SERVER_FILES_MANIFEST}.json`,\n            }),\n        this.isDev\n          ? 'development'\n          : loadManifestFromRelativePath<any>({\n              projectDir,\n              distDir: this.distDir,\n              manifest: BUILD_ID_FILE,\n              skipParse: true,\n            }),\n        loadManifestFromRelativePath<any>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: DYNAMIC_CSS_MANIFEST,\n          handleMissing: true,\n        }),\n      ]\n\n      result = {\n        buildId,\n        buildManifest,\n        fallbackBuildManifest,\n        routesManifest,\n        nextFontManifest,\n        prerenderManifest,\n        serverFilesManifest,\n        reactLoadableManifest,\n        clientReferenceManifest: (clientReferenceManifest as any)\n          ?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],\n        serverActionsManifest,\n        subresourceIntegrityManifest,\n        dynamicCssManifest,\n        interceptionRoutePatterns: routesManifest.rewrites.beforeFiles\n          .filter(isInterceptionRouteRewrite)\n          .map((rewrite) => new RegExp(rewrite.regex)),\n      }\n    }\n\n    return result\n  }\n\n  public async loadCustomCacheHandlers(\n    req: IncomingMessage | BaseNextRequest,\n    nextConfig: NextConfigRuntime\n  ) {\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      const { cacheMaxMemorySize, cacheHandlers } = nextConfig\n      if (!cacheHandlers) return\n\n      // If we've already initialized the cache handlers interface, don't do it\n      // again.\n      if (!initializeCacheHandlers(cacheMaxMemorySize)) return\n\n      for (const [kind, handler] of Object.entries(cacheHandlers)) {\n        if (!handler) continue\n\n        const { formatDynamicImportPath } =\n          require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')\n\n        const { join } = require('node:path') as typeof import('node:path')\n        const absoluteProjectDir = join(\n          /* turbopackIgnore: true */\n          process.cwd(),\n          getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n        )\n\n        setCacheHandler(\n          kind,\n          interopDefault(\n            await dynamicImportEsmDefault(\n              formatDynamicImportPath(\n                `${absoluteProjectDir}/${this.distDir}`,\n                handler\n              )\n            )\n          )\n        )\n      }\n    }\n  }\n\n  public async getIncrementalCache(\n    req: IncomingMessage | BaseNextRequest,\n    nextConfig: NextConfigRuntime,\n    prerenderManifest: DeepReadonly<PrerenderManifest>,\n    isMinimalMode: boolean\n  ): Promise<IncrementalCache> {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      return (globalThis as any).__incrementalCache\n    } else {\n      let CacheHandler: any\n      const { cacheHandler } = nextConfig\n\n      if (cacheHandler) {\n        const { formatDynamicImportPath } =\n          require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')\n\n        CacheHandler = interopDefault(\n          await dynamicImportEsmDefault(\n            formatDynamicImportPath(this.distDir, cacheHandler)\n          )\n        )\n      }\n      const { join } = require('node:path') as typeof import('node:path')\n      const projectDir = join(\n        /* turbopackIgnore: true */\n        process.cwd(),\n        getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n      )\n\n      await this.loadCustomCacheHandlers(req, nextConfig)\n\n      // incremental-cache is request specific\n      // although can have shared caches in module scope\n      // per-cache handler\n      const incrementalCache = new IncrementalCache({\n        fs: (\n          require('../lib/node-fs-methods') as typeof import('../lib/node-fs-methods')\n        ).nodeFs,\n        dev: this.isDev,\n        requestHeaders: req.headers,\n        allowedRevalidateHeaderKeys:\n          nextConfig.experimental.allowedRevalidateHeaderKeys,\n        minimalMode: isMinimalMode,\n        serverDistDir: `${projectDir}/${this.distDir}/server`,\n        fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,\n        maxMemoryCacheSize: nextConfig.cacheMaxMemorySize,\n        flushToDisk: !isMinimalMode && nextConfig.experimental.isrFlushToDisk,\n        getPrerenderManifest: () => prerenderManifest,\n        CurCacheHandler: CacheHandler,\n      })\n\n      // we need to expose this on globalThis as the app-render\n      // workStore grabs the incrementalCache from there\n      ;(globalThis as any).__incrementalCache = incrementalCache\n      return incrementalCache\n    }\n  }\n\n  public async onRequestError(\n    req: IncomingMessage | BaseNextRequest,\n    err: unknown,\n    errorContext: RequestErrorContext,\n    silenceLog: boolean,\n    routerServerContext?: RouterServerContext[string]\n  ) {\n    if (!silenceLog) {\n      if (routerServerContext?.logErrorWithOriginalStack) {\n        routerServerContext.logErrorWithOriginalStack(err, 'app-dir')\n      } else {\n        console.error(err)\n      }\n    }\n    await this.instrumentationOnRequestError(\n      req,\n      err,\n      {\n        path: req.url || '/',\n        headers: req.headers,\n        method: req.method || 'GET',\n      },\n      errorContext\n    )\n  }\n\n  /** A more lightweight version of `prepare()` for only retrieving the config on edge */\n  public getNextConfigEdge(req: NextIncomingMessage): {\n    nextConfig: NextConfigRuntime\n    deploymentId: string\n  } {\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      throw new Error(\n        'Invariant: getNextConfigEdge must only be called in edge runtime'\n      )\n    }\n\n    let serverFilesManifest = self.__SERVER_FILES_MANIFEST as any as\n      | RequiredServerFilesManifest\n      | undefined\n    const relativeProjectDir =\n      getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n    const routerServerContext =\n      routerServerGlobal[RouterServerContextSymbol]?.[relativeProjectDir]\n    const nextConfig =\n      routerServerContext?.nextConfig || serverFilesManifest?.config\n\n    if (!nextConfig) {\n      throw new Error(\"Invariant: nextConfig couldn't be loaded\")\n    }\n\n    let deploymentId\n    if (nextConfig.experimental?.runtimeServerDeploymentId) {\n      if (!process.env.NEXT_DEPLOYMENT_ID) {\n        throw new Error(\n          'process.env.NEXT_DEPLOYMENT_ID is missing but runtimeServerDeploymentId is enabled'\n        )\n      }\n      deploymentId = process.env.NEXT_DEPLOYMENT_ID\n    } else {\n      deploymentId = nextConfig.deploymentId || ''\n    }\n\n    return { nextConfig, deploymentId }\n  }\n\n  public async prepare(\n    req: IncomingMessage | BaseNextRequest,\n    res: ServerResponse | null,\n    {\n      srcPage,\n      multiZoneDraftMode,\n    }: {\n      srcPage: string\n      multiZoneDraftMode?: boolean\n    }\n  ): Promise<\n    | {\n        buildId: string\n        deploymentId: string\n        locale?: string\n        locales?: readonly string[]\n        defaultLocale?: string\n        query: ParsedUrlQuery\n        originalQuery: ParsedUrlQuery\n        originalPathname: string\n        params?: ParsedUrlQuery\n        parsedUrl: UrlWithParsedQuery\n        previewData: PreviewData\n        pageIsDynamic: boolean\n        isDraftMode: boolean\n        resolvedPathname: string\n        encodedResolvedPathname: string\n        isNextDataRequest: boolean\n        buildManifest: DeepReadonly<BuildManifest>\n        fallbackBuildManifest: DeepReadonly<BuildManifest>\n        nextFontManifest: DeepReadonly<NextFontManifest>\n        serverFilesManifest:\n          | DeepReadonly<RequiredServerFilesManifest>\n          | undefined\n        reactLoadableManifest: DeepReadonly<ReactLoadableManifest>\n        routesManifest: DeepReadonly<DevRoutesManifest>\n        prerenderManifest: DeepReadonly<PrerenderManifest>\n        // we can't pull in the client reference type or it causes issues with\n        // our pre-compiled types\n        clientReferenceManifest?: any\n        serverActionsManifest?: any\n        dynamicCssManifest?: any\n        subresourceIntegrityManifest?: DeepReadonly<Record<string, string>>\n        isOnDemandRevalidate: boolean\n        revalidateOnlyGenerated: boolean\n        nextConfig: NextConfigRuntime\n        routerServerContext?: RouterServerContext[string]\n        interceptionRoutePatterns?: any\n      }\n    | undefined\n  > {\n    let absoluteProjectDir: string | undefined\n\n    // edge runtime handles loading instrumentation at the edge adapter level\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      const { join, relative } =\n        require('node:path') as typeof import('node:path')\n\n      absoluteProjectDir = join(\n        /* turbopackIgnore: true */\n        process.cwd(),\n        getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n      )\n\n      const absoluteDistDir = getRequestMeta(req, 'distDir')\n\n      if (absoluteDistDir) {\n        this.distDir = relative(absoluteProjectDir, absoluteDistDir)\n      }\n      const { ensureInstrumentationRegistered } = await import(\n        '../lib/router-utils/instrumentation-globals.external.js'\n      )\n      // ensure instrumentation is registered and pass\n      // onRequestError below\n      ensureInstrumentationRegistered(absoluteProjectDir, this.distDir)\n    }\n    const manifests = await this.loadManifests(srcPage, absoluteProjectDir)\n    const { routesManifest, prerenderManifest, serverFilesManifest } = manifests\n\n    const { basePath, i18n, rewrites } = routesManifest\n\n    if (basePath) {\n      req.url = removePathPrefix(req.url || '/', basePath)\n    }\n\n    const parsedUrl = parseReqUrl(req.url || '/')\n    // if we couldn't parse the URL we can't continue\n    if (!parsedUrl) {\n      return\n    }\n    let isNextDataRequest = false\n\n    if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {\n      isNextDataRequest = true\n      parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/')\n    }\n    let originalPathname = parsedUrl.pathname || '/'\n    const originalQuery = { ...parsedUrl.query }\n    const pageIsDynamic = isDynamicRoute(srcPage)\n\n    let localeResult: PathLocale | undefined\n    let detectedLocale: string | undefined\n\n    if (i18n) {\n      localeResult = normalizeLocalePath(\n        parsedUrl.pathname || '/',\n        i18n.locales\n      )\n\n      if (localeResult.detectedLocale) {\n        req.url = `${localeResult.pathname}${parsedUrl.search}`\n        originalPathname = localeResult.pathname\n\n        if (!detectedLocale) {\n          detectedLocale = localeResult.detectedLocale\n        }\n      }\n    }\n\n    // Normalize the page path for route matching. The srcPage contains the\n    // internal page path (e.g., /app/[slug]/page), but route matchers expect\n    // the pathname format (e.g., /app/[slug]).\n    const normalizedSrcPage = normalizeAppPath(srcPage)\n\n    const serverUtils = getServerUtils({\n      page: normalizedSrcPage,\n      i18n,\n      basePath,\n      rewrites,\n      pageIsDynamic,\n      trailingSlash: process.env.__NEXT_TRAILING_SLASH as any as boolean,\n      caseSensitive: Boolean(routesManifest.caseSensitive),\n    })\n\n    const domainLocale = detectDomainLocale(\n      i18n?.domains,\n      getHostname(parsedUrl, req.headers),\n      detectedLocale\n    )\n    addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))\n\n    const defaultLocale = domainLocale?.defaultLocale || i18n?.defaultLocale\n\n    // Ensure parsedUrl.pathname includes locale before processing\n    // rewrites or they won't match correctly.\n    if (defaultLocale && !detectedLocale) {\n      parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`\n    }\n    const locale =\n      getRequestMeta(req, 'locale') || detectedLocale || defaultLocale\n\n    // we apply rewrites against cloned URL so that we don't\n    // modify the original with the rewrite destination\n    const { rewriteParams, rewrittenParsedUrl } = serverUtils.handleRewrites(\n      req,\n      parsedUrl\n    )\n    const rewriteParamKeys = Object.keys(rewriteParams)\n    Object.assign(parsedUrl.query, rewrittenParsedUrl.query)\n\n    // after processing rewrites we want to remove locale\n    // from parsedUrl pathname\n    if (i18n) {\n      parsedUrl.pathname = normalizeLocalePath(\n        parsedUrl.pathname || '/',\n        i18n.locales\n      ).pathname\n\n      rewrittenParsedUrl.pathname = normalizeLocalePath(\n        rewrittenParsedUrl.pathname || '/',\n        i18n.locales\n      ).pathname\n    }\n\n    let params: Record<string, undefined | string | string[]> | undefined =\n      getRequestMeta(req, 'params')\n\n    // attempt parsing from pathname\n    if (!params && serverUtils.dynamicRouteMatcher) {\n      const paramsMatch = serverUtils.dynamicRouteMatcher(\n        normalizeDataPath(\n          rewrittenParsedUrl?.pathname || parsedUrl.pathname || '/'\n        )\n      )\n      const paramsResult = serverUtils.normalizeDynamicRouteParams(\n        paramsMatch || {},\n        true\n      )\n\n      if (paramsResult.hasValidParams) {\n        params = paramsResult.params\n      }\n    }\n\n    // Local \"next start\" expects the routing parsed query values\n    // to not be present in the URL although when deployed proxies\n    // will add query values from resolving the routes to pass to function.\n\n    // TODO: do we want to change expectations for \"next start\"\n    // to include these query values in the URL which affects asPath\n    // but would match deployed behavior, e.g. a rewrite from middleware\n    // that adds a query param would be in asPath as query but locally\n    // it won't be in the asPath but still available in the query object\n    const query = getRequestMeta(req, 'query') || {\n      ...parsedUrl.query,\n    }\n\n    const routeParamKeys = new Set<string>()\n    const combinedParamKeys = []\n\n    // We don't include rewriteParamKeys in the combinedParamKeys\n    // for app router since the searchParams is populated from the\n    // URL so we don't want to strip the rewrite params from the URL\n    // so that searchParams can include them.\n    if (\n      this.definition.kind === RouteKind.PAGES ||\n      this.definition.kind === RouteKind.PAGES_API\n    ) {\n      for (const key of [\n        ...rewriteParamKeys,\n        ...Object.keys(serverUtils.defaultRouteMatches || {}),\n      ]) {\n        // We only want to filter rewrite param keys from the URL\n        // if they are matches from the URL e.g. the key/value matches\n        // before and after applying the rewrites /:path for /hello and\n        // { path: 'hello' } but not for { path: 'another' } and /hello\n        // TODO: we should prefix rewrite param keys the same as we do\n        // for dynamic routes so we can identify them properly\n        const originalValue = Array.isArray(originalQuery[key])\n          ? originalQuery[key].join('')\n          : originalQuery[key]\n\n        const queryValue = Array.isArray(query[key])\n          ? query[key].join('')\n          : query[key]\n\n        if (!(key in originalQuery) || originalValue === queryValue) {\n          combinedParamKeys.push(key)\n        }\n      }\n    }\n\n    serverUtils.normalizeCdnUrl(req, combinedParamKeys)\n    serverUtils.normalizeQueryParams(query, routeParamKeys)\n    serverUtils.filterInternalQuery(originalQuery, combinedParamKeys)\n\n    if (pageIsDynamic) {\n      const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)\n\n      const paramsResult = serverUtils.normalizeDynamicRouteParams(\n        params || {},\n        true\n      )\n\n      let paramsToInterpolate: ParsedUrlQuery\n\n      if (\n        // if both query and params are valid but one\n        // provided more information rely on that one\n        query &&\n        params &&\n        paramsResult.hasValidParams &&\n        queryResult.hasValidParams &&\n        Object.keys(paramsResult.params).length <\n          Object.keys(queryResult.params).length\n      ) {\n        paramsToInterpolate = queryResult.params\n        params = Object.assign(queryResult.params)\n      } else {\n        paramsToInterpolate =\n          paramsResult.hasValidParams && params\n            ? params\n            : queryResult.hasValidParams\n              ? query\n              : {}\n      }\n\n      req.url = serverUtils.interpolateDynamicPath(\n        req.url || '/',\n        paramsToInterpolate\n      )\n      parsedUrl.pathname = serverUtils.interpolateDynamicPath(\n        parsedUrl.pathname || '/',\n        paramsToInterpolate\n      )\n      originalPathname = serverUtils.interpolateDynamicPath(\n        originalPathname,\n        paramsToInterpolate\n      )\n\n      // try pulling from query if valid\n      if (!params) {\n        if (queryResult.hasValidParams) {\n          params = Object.assign({}, queryResult.params)\n\n          // If we pulled from query remove it so it's\n          // only in params\n          for (const key in serverUtils.defaultRouteMatches) {\n            delete query[key]\n          }\n        } else {\n          // use final params from URL matching\n          const paramsMatch = serverUtils.dynamicRouteMatcher?.(\n            normalizeDataPath(\n              localeResult?.pathname || parsedUrl.pathname || '/'\n            )\n          )\n          // we don't normalize these as they are allowed to be\n          // the literal slug matches here e.g. /blog/[slug]\n          // actually being requested\n          if (paramsMatch) {\n            params = Object.assign({}, paramsMatch)\n          }\n        }\n      }\n    }\n\n    // Remove any normalized params from the query if they\n    // weren't present as non-prefixed query key e.g.\n    // ?search=1&nxtPsearch=hello we don't delete search\n    for (const key of routeParamKeys) {\n      if (!(key in originalQuery)) {\n        delete query[key]\n      }\n    }\n\n    const { isOnDemandRevalidate, revalidateOnlyGenerated } =\n      checkIsOnDemandRevalidate(req, prerenderManifest.preview)\n\n    let isDraftMode = false\n    let previewData: PreviewData\n\n    // preview data relies on non-edge utils\n    if (process.env.NEXT_RUNTIME !== 'edge' && res) {\n      const { tryGetPreviewData } =\n        require('../api-utils/node/try-get-preview-data') as typeof import('../api-utils/node/try-get-preview-data')\n\n      previewData = tryGetPreviewData(\n        req,\n        res,\n        prerenderManifest.preview,\n        Boolean(multiZoneDraftMode)\n      )\n      isDraftMode = previewData !== false\n    }\n\n    const relativeProjectDir =\n      getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n\n    const routerServerContext =\n      routerServerGlobal[RouterServerContextSymbol]?.[relativeProjectDir]\n    const nextConfig =\n      routerServerContext?.nextConfig || serverFilesManifest?.config\n\n    if (!nextConfig) {\n      throw new Error(\"Invariant: nextConfig couldn't be loaded\")\n    }\n\n    let resolvedPathname = normalizedSrcPage\n    if (isDynamicRoute(resolvedPathname) && params) {\n      resolvedPathname = serverUtils.interpolateDynamicPath(\n        resolvedPathname,\n        params\n      )\n    }\n\n    if (resolvedPathname === '/index') {\n      resolvedPathname = '/'\n    }\n    const encodedResolvedPathname = resolvedPathname\n\n    // we decode for cache key/manifest usage encoded is\n    // for URL building\n    try {\n      resolvedPathname = decodePathParams(resolvedPathname)\n    } catch (_) {}\n\n    resolvedPathname = removeTrailingSlash(resolvedPathname)\n\n    let deploymentId\n    if (nextConfig.experimental?.runtimeServerDeploymentId) {\n      if (!process.env.NEXT_DEPLOYMENT_ID) {\n        throw new Error(\n          'process.env.NEXT_DEPLOYMENT_ID is missing but runtimeServerDeploymentId is enabled'\n        )\n      }\n      deploymentId = process.env.NEXT_DEPLOYMENT_ID\n    } else {\n      deploymentId = nextConfig.deploymentId || ''\n    }\n\n    return {\n      query,\n      originalQuery,\n      originalPathname,\n      params,\n      parsedUrl,\n      locale,\n      isNextDataRequest,\n      locales: i18n?.locales,\n      defaultLocale,\n      isDraftMode,\n      previewData,\n      pageIsDynamic,\n      resolvedPathname,\n      encodedResolvedPathname,\n      isOnDemandRevalidate,\n      revalidateOnlyGenerated,\n      ...manifests,\n      // loadManifest returns a readonly object, but we don't want to propagate that throughout the\n      // whole codebase (for now)\n      nextConfig:\n        nextConfig satisfies DeepReadonly<NextConfigRuntime> as NextConfigRuntime,\n      routerServerContext,\n      deploymentId,\n    }\n  }\n\n  public getResponseCache(req: IncomingMessage | BaseNextRequest) {\n    if (!this.responseCache) {\n      const minimalMode =\n        (Boolean(process.env.MINIMAL_MODE) ||\n          getRequestMeta(req, 'minimalMode')) ??\n        false\n      this.responseCache = new ResponseCache(minimalMode)\n    }\n    return this.responseCache\n  }\n\n  public async handleResponse({\n    req,\n    nextConfig,\n    cacheKey,\n    routeKind,\n    isFallback,\n    prerenderManifest,\n    isRoutePPREnabled,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    responseGenerator,\n    waitUntil,\n    isMinimalMode,\n  }: {\n    req: IncomingMessage | BaseNextRequest\n    nextConfig: NextConfigRuntime\n    cacheKey: string | null\n    routeKind: RouteKind\n    isFallback?: boolean\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n    isRoutePPREnabled?: boolean\n    isOnDemandRevalidate?: boolean\n    revalidateOnlyGenerated?: boolean\n    responseGenerator: ResponseGenerator\n    waitUntil?: (prom: Promise<any>) => void\n    isMinimalMode: boolean\n  }) {\n    const responseCache = this.getResponseCache(req)\n    const cacheEntry = await responseCache.get(cacheKey, responseGenerator, {\n      routeKind,\n      isFallback,\n      isRoutePPREnabled,\n      isOnDemandRevalidate,\n      isPrefetch: req.headers.purpose === 'prefetch',\n      // Use x-invocation-id header to scope the in-memory cache to a single\n      // revalidation request in minimal mode.\n      invocationID: req.headers['x-invocation-id'] as string | undefined,\n      incrementalCache: await this.getIncrementalCache(\n        req,\n        nextConfig,\n        prerenderManifest,\n        isMinimalMode\n      ),\n      waitUntil,\n    })\n\n    if (!cacheEntry) {\n      if (\n        cacheKey &&\n        // revalidate only generated can bail even if cacheKey is provided\n        !(isOnDemandRevalidate && revalidateOnlyGenerated)\n      ) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated')\n      }\n    }\n    return cacheEntry\n  }\n}\n"],"names":["BUILD_ID_FILE","BUILD_MANIFEST","CLIENT_REFERENCE_MANIFEST","DYNAMIC_CSS_MANIFEST","NEXT_FONT_MANIFEST","PRERENDER_MANIFEST","REACT_LOADABLE_MANIFEST","ROUTES_MANIFEST","SERVER_FILES_MANIFEST","SERVER_REFERENCE_MANIFEST","SUBRESOURCE_INTEGRITY_MANIFEST","parseReqUrl","normalizeLocalePath","isDynamicRoute","removePathPrefix","getServerUtils","detectDomainLocale","getHostname","checkIsOnDemandRevalidate","normalizeDataPath","pathHasPrefix","addRequestMeta","getRequestMeta","normalizePagePath","isStaticMetadataRoute","IncrementalCache","initializeCacheHandlers","setCacheHandler","interopDefault","RouteKind","ResponseCache","normalizeAppPath","RouterServerContextSymbol","routerServerGlobal","decodePathParams","removeTrailingSlash","isInterceptionRouteRewrite","dynamicImportEsmDefault","id","then","mod","default","RouteModule","constructor","userland","definition","distDir","relativeProjectDir","isDev","process","env","NODE_ENV","instrumentationOnRequestError","req","args","NEXT_RUNTIME","getEdgeInstrumentationModule","instrumentation","onRequestError","join","require","absoluteProjectDir","cwd","loadManifests","srcPage","projectDir","result","self","getEdgePreviewProps","maybeJSONParse","str","JSON","parse","undefined","buildId","__NEXT_BUILD_ID","buildManifest","__BUILD_MANIFEST","fallbackBuildManifest","reactLoadableManifest","__REACT_LOADABLE_MANIFEST","nextFontManifest","__NEXT_FONT_MANIFEST","prerenderManifest","routes","dynamicRoutes","notFoundRoutes","version","preview","routesManifest","caseSensitive","Boolean","__NEXT_CASE_SENSITIVE_ROUTES","basePath","__NEXT_BASE_PATH","rewrites","__NEXT_REWRITES","beforeFiles","afterFiles","fallback","redirects","headers","i18n","__NEXT_I18N_CONFIG","skipProxyUrlNormalize","__NEXT_NO_MIDDLEWARE_URL_NORMALIZE","serverFilesManifest","__SERVER_FILES_MANIFEST","clientReferenceManifest","__RSC_MANIFEST","serverActionsManifest","__RSC_SERVER_MANIFEST","subresourceIntegrityManifest","__SUBRESOURCE_INTEGRITY_MANIFEST","dynamicCssManifest","__DYNAMIC_CSS_MANIFEST","interceptionRoutePatterns","__INTERCEPTION_ROUTE_REWRITE_MANIFEST","map","rewrite","RegExp","regex","Error","loadManifestFromRelativePath","normalizedPagePath","router","kind","PAGES","PAGES_API","manifest","shouldCache","handleMissing","TURBOPACK","useEval","replace","skipParse","filter","loadCustomCacheHandlers","nextConfig","cacheMaxMemorySize","cacheHandlers","handler","Object","entries","formatDynamicImportPath","getIncrementalCache","isMinimalMode","globalThis","__incrementalCache","CacheHandler","cacheHandler","incrementalCache","fs","nodeFs","dev","requestHeaders","allowedRevalidateHeaderKeys","experimental","minimalMode","serverDistDir","fetchCacheKeyPrefix","maxMemoryCacheSize","flushToDisk","isrFlushToDisk","getPrerenderManifest","CurCacheHandler","err","errorContext","silenceLog","routerServerContext","logErrorWithOriginalStack","console","error","path","url","method","getNextConfigEdge","config","deploymentId","runtimeServerDeploymentId","NEXT_DEPLOYMENT_ID","prepare","res","multiZoneDraftMode","relative","absoluteDistDir","ensureInstrumentationRegistered","manifests","parsedUrl","isNextDataRequest","pathname","originalPathname","originalQuery","query","pageIsDynamic","localeResult","detectedLocale","locales","search","normalizedSrcPage","serverUtils","page","trailingSlash","__NEXT_TRAILING_SLASH","domainLocale","domains","defaultLocale","locale","rewriteParams","rewrittenParsedUrl","handleRewrites","rewriteParamKeys","keys","assign","params","dynamicRouteMatcher","paramsMatch","paramsResult","normalizeDynamicRouteParams","hasValidParams","routeParamKeys","Set","combinedParamKeys","key","defaultRouteMatches","originalValue","Array","isArray","queryValue","push","normalizeCdnUrl","normalizeQueryParams","filterInternalQuery","queryResult","paramsToInterpolate","length","interpolateDynamicPath","isOnDemandRevalidate","revalidateOnlyGenerated","isDraftMode","previewData","tryGetPreviewData","resolvedPathname","encodedResolvedPathname","_","getResponseCache","responseCache","MINIMAL_MODE","handleResponse","cacheKey","routeKind","isFallback","isRoutePPREnabled","responseGenerator","waitUntil","cacheEntry","get","isPrefetch","purpose","invocationID"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7500, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-modules/app-page/vendored/contexts/entrypoints.ts"],"sourcesContent":["export * as HeadManagerContext from '../../../../../shared/lib/head-manager-context.shared-runtime'\nexport * as ServerInsertedHtml from '../../../../../shared/lib/server-inserted-html.shared-runtime'\nexport * as AppRouterContext from '../../../../../shared/lib/app-router-context.shared-runtime'\nexport * as HooksClientContext from '../../../../../shared/lib/hooks-client-context.shared-runtime'\nexport * as RouterContext from '../../../../../shared/lib/router-context.shared-runtime'\nexport * as ImageConfigContext from '../../../../../shared/lib/image-config-context.shared-runtime'\n"],"names":["HeadManagerContext","ServerInsertedHtml","AppRouterContext","HooksClientContext","RouterContext","ImageConfigContext"],"mappings":";AAAA,OAAO,KAAKA,kBAAkB,MAAM,gEAA+D;AACnG,OAAO,KAAKC,kBAAkB,MAAM,gEAA+D;AACnG,OAAO,KAAKC,gBAAgB,MAAM,8DAA6D;AAC/F,OAAO,KAAKC,kBAAkB,MAAM,gEAA+D;AACnG,OAAO,KAAKC,aAAa,MAAM,0DAAyD;AACxF,OAAO,KAAKC,kBAAkB,MAAM,gEAA+D","ignoreList":[0]}},
    {"offset": {"line": 7542, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-modules/app-page/helpers/prerender-manifest-matcher.ts"],"sourcesContent":["import type {\n  DynamicPrerenderManifestRoute,\n  PrerenderManifest,\n} from '../../../../build'\nimport type { DeepReadonly } from '../../../../shared/lib/deep-readonly'\nimport {\n  getRouteMatcher,\n  type RouteMatchFn,\n} from '../../../../shared/lib/router/utils/route-matcher'\nimport { getRouteRegex } from '../../../../shared/lib/router/utils/route-regex'\n\n/**\n * A matcher for a dynamic route.\n */\ntype Matcher = {\n  /**\n   * The matcher for the dynamic route. This is lazily created when the matcher\n   * is first used.\n   */\n  matcher?: RouteMatchFn\n\n  /**\n   * The source of the dynamic route.\n   */\n  source: string\n\n  /**\n   * The route that matches the source.\n   */\n  route: DeepReadonly<DynamicPrerenderManifestRoute>\n}\n\n/**\n * A matcher for the prerender manifest.\n *\n * This class is used to match the pathname to the dynamic route.\n */\nexport class PrerenderManifestMatcher {\n  private readonly matchers: Array<Matcher>\n  constructor(\n    pathname: string,\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n  ) {\n    this.matchers = Object.entries(prerenderManifest.dynamicRoutes)\n      .filter(([source, route]) => {\n        // If the pathname is a fallback source route, or the source route is\n        // the same as the pathname, then we should include it in the matchers.\n        return route.fallbackSourceRoute === pathname || source === pathname\n      })\n      .map(([source, route]) => ({ source, route }))\n  }\n\n  /**\n   * Match the pathname to the dynamic route. If no match is found, an error is\n   * thrown.\n   *\n   * @param pathname - The pathname to match.\n   * @returns The dynamic route that matches the pathname.\n   */\n  public match(\n    pathname: string\n  ): DeepReadonly<DynamicPrerenderManifestRoute> | null {\n    // Iterate over the matchers. They're already in the correct order of\n    // specificity as they were inserted into the prerender manifest that way\n    // and iterating over them with Object.entries guarantees that.\n    for (const matcher of this.matchers) {\n      // Lazily create the matcher, this is only done once per matcher.\n      if (!matcher.matcher) {\n        matcher.matcher = getRouteMatcher(getRouteRegex(matcher.source))\n      }\n\n      const match = matcher.matcher(pathname)\n      if (match) {\n        return matcher.route\n      }\n    }\n\n    return null\n  }\n}\n"],"names":["getRouteMatcher","getRouteRegex","PrerenderManifestMatcher","constructor","pathname","prerenderManifest","matchers","Object","entries","dynamicRoutes","filter","source","route","fallbackSourceRoute","map","match","matcher"],"mappings":";;;;AAKA,SACEA,eAAe,QAEV,oDAAmD;AAC1D,SAASC,aAAa,QAAQ,kDAAiD;;;AA4BxE,MAAMC;IAEXC,YACEC,QAAgB,EAChBC,iBAAkD,CAClD;QACA,IAAI,CAACC,QAAQ,GAAGC,OAAOC,OAAO,CAACH,kBAAkBI,aAAa,EAC3DC,MAAM,CAAC,CAAC,CAACC,QAAQC,MAAM;YACtB,qEAAqE;YACrE,uEAAuE;YACvE,OAAOA,MAAMC,mBAAmB,KAAKT,YAAYO,WAAWP;QAC9D,GACCU,GAAG,CAAC,CAAC,CAACH,QAAQC,MAAM,GAAM,CAAA;gBAAED;gBAAQC;YAAM,CAAA;IAC/C;IAEA;;;;;;GAMC,GACMG,MACLX,QAAgB,EACoC;QACpD,qEAAqE;QACrE,yEAAyE;QACzE,+DAA+D;QAC/D,KAAK,MAAMY,WAAW,IAAI,CAACV,QAAQ,CAAE;YACnC,iEAAiE;YACjE,IAAI,CAACU,QAAQA,OAAO,EAAE;gBACpBA,QAAQA,OAAO,OAAGhB,qOAAAA,MAAgBC,iOAAAA,EAAce,QAAQL,MAAM;YAChE;YAEA,MAAMI,QAAQC,QAAQA,OAAO,CAACZ;YAC9B,IAAIW,OAAO;gBACT,OAAOC,QAAQJ,KAAK;YACtB;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 7588, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-modules/app-page/module.ts"],"sourcesContent":["import type { AppPageRouteDefinition } from '../../route-definitions/app-page-route-definition'\nimport type RenderResult from '../../render-result'\nimport type { RenderOpts } from '../../app-render/types'\nimport type { NextParsedUrlQuery } from '../../request-meta'\nimport type { LoaderTree } from '../../lib/app-dir-module'\nimport type { PrerenderManifest } from '../../../build'\n\nimport {\n  renderToHTMLOrFlight,\n  type AppSharedContext,\n} from '../../app-render/app-render'\nimport {\n  RouteModule,\n  type RouteModuleOptions,\n  type RouteModuleHandleContext,\n} from '../route-module'\nimport * as vendoredContexts from './vendored/contexts/entrypoints'\nimport type { BaseNextRequest, BaseNextResponse } from '../../base-http'\nimport type { ServerComponentsHmrCache } from '../../response-cache'\nimport type { OpaqueFallbackRouteParams } from '../../request/fallback-params'\nimport { PrerenderManifestMatcher } from './helpers/prerender-manifest-matcher'\nimport type { DeepReadonly } from '../../../shared/lib/deep-readonly'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n} from '../../../client/components/app-router-headers'\nimport { isInterceptionRouteAppPath } from '../../../shared/lib/router/utils/interception-routes'\n\nlet vendoredReactRSC\nlet vendoredReactSSR\n\n// the vendored Reacts are loaded from their original source in the edge runtime\nif (process.env.NEXT_RUNTIME !== 'edge') {\n  vendoredReactRSC =\n    require('./vendored/rsc/entrypoints') as typeof import('./vendored/rsc/entrypoints')\n  vendoredReactSSR =\n    require('./vendored/ssr/entrypoints') as typeof import('./vendored/ssr/entrypoints')\n\n  // In Node environments we need to access the correct React instance from external modules such\n  // as global patches. We register the loaded React instances here.\n  const { registerServerReact, registerClientReact } =\n    require('../../runtime-reacts.external') as typeof import('../../runtime-reacts.external')\n  registerServerReact(vendoredReactRSC.React)\n  registerClientReact(vendoredReactSSR.React)\n}\n\n/**\n * The AppPageModule is the type of the module exported by the bundled app page\n * module.\n */\nexport type AppPageModule = typeof import('../../../build/templates/app-page')\n\ntype AppPageUserlandModule = {\n  /**\n   * The tree created in next-app-loader that holds component segments and modules\n   */\n  loaderTree: LoaderTree\n}\n\nexport interface AppPageRouteHandlerContext extends RouteModuleHandleContext {\n  page: string\n  query: NextParsedUrlQuery\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n  renderOpts: RenderOpts\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  sharedContext: AppSharedContext\n}\n\nexport type AppPageRouteModuleOptions = RouteModuleOptions<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n>\n\nexport class AppPageRouteModule extends RouteModule<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n> {\n  private matchers = new WeakMap<\n    DeepReadonly<PrerenderManifest>,\n    PrerenderManifestMatcher\n  >()\n  public match(\n    pathname: string,\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n  ) {\n    // Lazily create the matcher based on the provided prerender manifest.\n    let matcher = this.matchers.get(prerenderManifest)\n    if (!matcher) {\n      matcher = new PrerenderManifestMatcher(\n        this.definition.pathname,\n        prerenderManifest\n      )\n      this.matchers.set(prerenderManifest, matcher)\n    }\n\n    // Match the pathname to the dynamic route.\n    return matcher.match(pathname)\n  }\n\n  public render(\n    req: BaseNextRequest,\n    res: BaseNextResponse,\n    context: AppPageRouteHandlerContext\n  ): Promise<RenderResult> {\n    return renderToHTMLOrFlight(\n      req,\n      res,\n      context.page,\n      context.query,\n      context.fallbackRouteParams,\n      context.renderOpts,\n      context.serverComponentsHmrCache,\n      context.sharedContext\n    )\n  }\n\n  private pathCouldBeIntercepted(\n    resolvedPathname: string,\n    interceptionRoutePatterns: RegExp[]\n  ): boolean {\n    return (\n      isInterceptionRouteAppPath(resolvedPathname) ||\n      interceptionRoutePatterns.some((regexp) => {\n        return regexp.test(resolvedPathname)\n      })\n    )\n  }\n\n  public getVaryHeader(\n    resolvedPathname: string,\n    interceptionRoutePatterns: RegExp[]\n  ): string {\n    const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`\n\n    if (\n      this.pathCouldBeIntercepted(resolvedPathname, interceptionRoutePatterns)\n    ) {\n      // Interception route responses can vary based on the `Next-URL` header.\n      // We use the Vary header to signal this behavior to the client to properly cache the response.\n      return `${baseVaryHeader}, ${NEXT_URL}`\n    } else {\n      // We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.\n      // We also set this header for pages to avoid caching issues when navigating between pages and app.\n      return baseVaryHeader\n    }\n  }\n}\n\nconst vendored = {\n  'react-rsc': vendoredReactRSC,\n  'react-ssr': vendoredReactSSR,\n  contexts: vendoredContexts,\n}\n\nexport { renderToHTMLOrFlight, vendored }\n\nexport default AppPageRouteModule\n"],"names":["renderToHTMLOrFlight","RouteModule","vendoredContexts","PrerenderManifestMatcher","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_HEADER","isInterceptionRouteAppPath","vendoredReactRSC","vendoredReactSSR","process","env","NEXT_RUNTIME","require","registerServerReact","registerClientReact","React","AppPageRouteModule","match","pathname","prerenderManifest","matcher","matchers","get","definition","set","render","req","res","context","page","query","fallbackRouteParams","renderOpts","serverComponentsHmrCache","sharedContext","pathCouldBeIntercepted","resolvedPathname","interceptionRoutePatterns","some","regexp","test","getVaryHeader","baseVaryHeader","WeakMap","vendored","contexts"],"mappings":";;;;;;;;AAOA,SACEA,oBAAoB,QAEf,8BAA6B;AACpC,SACEC,WAAW,QAGN,kBAAiB;;AACxB,YAAYC,sBAAsB,kCAAiC;AAInE,SAASC,wBAAwB,QAAQ,uCAAsC;AAE/E,SACEC,2BAA2B,EAC3BC,mCAAmC,EACnCC,6BAA6B,EAC7BC,QAAQ,EACRC,UAAU,QACL,gDAA+C;AACtD,SAASC,0BAA0B,QAAQ,uDAAsD;;;;;;;AAEjG,IAAIC;AACJ,IAAIC;AAEJ,gFAAgF;AAChF,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;AAyClC,MAAMK,2BAA2BlB,0NAAAA;IAQ/BmB,MACLC,QAAgB,EAChBC,iBAAkD,EAClD;QACA,sEAAsE;QACtE,IAAIC,UAAU,IAAI,CAACC,QAAQ,CAACC,GAAG,CAACH;QAChC,IAAI,CAACC,SAAS;YACZA,UAAU,IAAIpB,kRAAAA,CACZ,IAAI,CAACuB,UAAU,CAACL,QAAQ,EACxBC;YAEF,IAAI,CAACE,QAAQ,CAACG,GAAG,CAACL,mBAAmBC;QACvC;QAEA,2CAA2C;QAC3C,OAAOA,QAAQH,KAAK,CAACC;IACvB;IAEOO,OACLC,GAAoB,EACpBC,GAAqB,EACrBC,OAAmC,EACZ;QACvB,WAAO/B,8NAAAA,EACL6B,KACAC,KACAC,QAAQC,IAAI,EACZD,QAAQE,KAAK,EACbF,QAAQG,mBAAmB,EAC3BH,QAAQI,UAAU,EAClBJ,QAAQK,wBAAwB,EAChCL,QAAQM,aAAa;IAEzB;IAEQC,uBACNC,gBAAwB,EACxBC,yBAAmC,EAC1B;QACT,WACE/B,sPAAAA,EAA2B8B,qBAC3BC,0BAA0BC,IAAI,CAAC,CAACC;YAC9B,OAAOA,OAAOC,IAAI,CAACJ;QACrB;IAEJ;IAEOK,cACLL,gBAAwB,EACxBC,yBAAmC,EAC3B;QACR,MAAMK,iBAAiB,GAAGrC,4NAAAA,CAAW,EAAE,EAAEF,+OAAAA,CAA8B,EAAE,EAAEF,6OAAAA,CAA4B,EAAE,EAAEC,qPAAAA,EAAqC;QAEhJ,IACE,IAAI,CAACiC,sBAAsB,CAACC,kBAAkBC,4BAC9C;YACA,wEAAwE;YACxE,+FAA+F;YAC/F,OAAO,GAAGK,eAAe,EAAE,EAAEtC,0NAAAA,EAAU;QACzC,OAAO;YACL,yHAAyH;YACzH,mGAAmG;YACnG,OAAOsC;QACT;IACF;;QAxEK,KAAA,IAAA,OAAA,IAAA,CAIGrB,QAAAA,GAAW,IAAIsB;;AAqEzB;AAEA,MAAMC,WAAW;IACf,aAAarC;IACb,aAAaC;IACbqC,UAAU9C;AACZ;;uCAIeiB,mBAAkB","ignoreList":[0]}},
    {"offset": {"line": 7676, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;IACvCC,OAAOC,OAAO,GAAGC,QAAQ;AAC3B,OAAO","ignoreList":[0]}},
    {"offset": {"line": 7685, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/route-modules/checks.ts"],"sourcesContent":["import type { AppRouteRouteModule } from './app-route/module'\nimport type { AppPageRouteModule } from './app-page/module'\nimport type { PagesRouteModule } from './pages/module'\nimport type { PagesAPIRouteModule } from './pages-api/module'\n\nimport type { RouteModule } from './route-module'\n\nimport { RouteKind } from '../route-kind'\n\nexport function isAppRouteRouteModule(\n  routeModule: RouteModule\n): routeModule is AppRouteRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_ROUTE\n}\n\nexport function isAppPageRouteModule(\n  routeModule: RouteModule\n): routeModule is AppPageRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_PAGE\n}\n\nexport function isPagesRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES\n}\n\nexport function isPagesAPIRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesAPIRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES_API\n}\n"],"names":["RouteKind","isAppRouteRouteModule","routeModule","definition","kind","APP_ROUTE","isAppPageRouteModule","APP_PAGE","isPagesRouteModule","PAGES","isPagesAPIRouteModule","PAGES_API"],"mappings":";;;;;;;;;;AAOA,SAASA,SAAS,QAAQ,gBAAe;;AAElC,SAASC,sBACdC,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,kMAAAA,CAAUK,SAAS;AAC5D;AAEO,SAASC,qBACdJ,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,kMAAAA,CAAUO,QAAQ;AAC3D;AAEO,SAASC,mBACdN,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,kMAAAA,CAAUS,KAAK;AACxD;AAEO,SAASC,sBACdR,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,kMAAAA,CAAUW,SAAS;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 7716, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/request/fallback-params.ts"],"sourcesContent":["import { resolveRouteParamsFromTree } from '../../build/static-paths/utils'\nimport type { FallbackRouteParam } from '../../build/static-paths/types'\nimport type { DynamicParamTypesShort } from '../../shared/lib/app-router-types'\nimport { dynamicParamTypes } from '../app-render/get-short-dynamic-param-type'\nimport type AppPageRouteModule from '../route-modules/app-page/module'\nimport { parseAppRoute } from '../../shared/lib/router/routes/app'\nimport { extractPathnameRouteParamSegmentsFromLoaderTree } from '../../build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree'\n\nexport type OpaqueFallbackRouteParamValue = [\n  /**\n   * The search value of the fallback route param. This is the opaque key\n   * that will be used to replace the dynamic param in the postponed state.\n   */\n  searchValue: string,\n\n  /**\n   * The dynamic param type of the fallback route param. This is the type of\n   * the dynamic param that will be used to replace the dynamic param in the\n   * postponed state.\n   */\n  dynamicParamType: DynamicParamTypesShort,\n]\n\n/**\n * An opaque fallback route params object. This is used to store the fallback\n * route params in a way that is not easily accessible to the client.\n */\nexport type OpaqueFallbackRouteParams = ReadonlyMap<\n  string,\n  OpaqueFallbackRouteParamValue\n>\n\n/**\n * The entries of the opaque fallback route params object.\n *\n * @param key the key of the fallback route param\n * @param value the value of the fallback route param\n */\nexport type OpaqueFallbackRouteParamEntries =\n  ReturnType<OpaqueFallbackRouteParams['entries']> extends MapIterator<\n    [infer K, infer V]\n  >\n    ? ReadonlyArray<[K, V]>\n    : never\n\n/**\n * Creates an opaque fallback route params object from the fallback route params.\n *\n * @param fallbackRouteParams the fallback route params\n * @returns the opaque fallback route params\n */\nexport function createOpaqueFallbackRouteParams(\n  fallbackRouteParams: readonly FallbackRouteParam[]\n): OpaqueFallbackRouteParams | null {\n  // If there are no fallback route params, we can return early.\n  if (fallbackRouteParams.length === 0) return null\n\n  // As we're creating unique keys for each of the dynamic route params, we only\n  // need to generate a unique ID once per request because each of the keys will\n  // be also be unique.\n  const uniqueID = Math.random().toString(16).slice(2)\n\n  const keys = new Map<string, OpaqueFallbackRouteParamValue>()\n\n  // Generate a unique key for the fallback route param, if this key is found\n  // in the static output, it represents a bug in cache components.\n  for (const { paramName, paramType } of fallbackRouteParams) {\n    keys.set(paramName, [\n      `%%drp:${paramName}:${uniqueID}%%`,\n      dynamicParamTypes[paramType],\n    ])\n  }\n\n  return keys\n}\n\n/**\n * Gets the fallback route params for a given page. This is an expensive\n * operation because it requires parsing the loader tree to extract the fallback\n * route params.\n *\n * @param page the page\n * @param routeModule the route module\n * @returns the opaque fallback route params\n */\nexport function getFallbackRouteParams(\n  page: string,\n  routeModule: AppPageRouteModule\n) {\n  const route = parseAppRoute(page, true)\n\n  // Extract the pathname-contributing segments from the loader tree. This\n  // mirrors the logic in buildAppStaticPaths where we determine which segments\n  // actually contribute to the pathname.\n  const { pathnameRouteParamSegments, params } =\n    extractPathnameRouteParamSegmentsFromLoaderTree(\n      routeModule.userland.loaderTree,\n      route\n    )\n\n  // Create fallback route params for the pathname segments.\n  const fallbackRouteParams: FallbackRouteParam[] =\n    pathnameRouteParamSegments.map(({ paramName, paramType }) => ({\n      paramName,\n      paramType,\n    }))\n\n  // Resolve route params from the loader tree. This mutates the\n  // fallbackRouteParams array to add any route params that are\n  // unknown at request time.\n  //\n  // The page parameter contains placeholders like [slug], which helps\n  // resolveRouteParamsFromTree determine which params are unknown.\n  resolveRouteParamsFromTree(\n    routeModule.userland.loaderTree,\n    params, // Static params extracted from the page\n    route, // The page pattern with placeholders\n    fallbackRouteParams // Will be mutated to add route params\n  )\n\n  // Convert the fallback route params to an opaque format that can be safely\n  // used in the postponed state without exposing implementation details.\n  return createOpaqueFallbackRouteParams(fallbackRouteParams)\n}\n"],"names":["resolveRouteParamsFromTree","dynamicParamTypes","parseAppRoute","extractPathnameRouteParamSegmentsFromLoaderTree","createOpaqueFallbackRouteParams","fallbackRouteParams","length","uniqueID","Math","random","toString","slice","keys","Map","paramName","paramType","set","getFallbackRouteParams","page","routeModule","route","pathnameRouteParamSegments","params","userland","loaderTree","map"],"mappings":";;;;;;AAAA,SAASA,0BAA0B,QAAQ,iCAAgC;AAG3E,SAASC,iBAAiB,QAAQ,6CAA4C;AAE9E,SAASC,aAAa,QAAQ,qCAAoC;AAClE,SAASC,+CAA+C,QAAQ,sFAAqF;;;;;AA6C9I,SAASC,gCACdC,mBAAkD;IAElD,8DAA8D;IAC9D,IAAIA,oBAAoBC,MAAM,KAAK,GAAG,OAAO;IAE7C,8EAA8E;IAC9E,8EAA8E;IAC9E,qBAAqB;IACrB,MAAMC,WAAWC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,KAAK,CAAC;IAElD,MAAMC,OAAO,IAAIC;IAEjB,2EAA2E;IAC3E,iEAAiE;IACjE,KAAK,MAAM,EAAEC,SAAS,EAAEC,SAAS,EAAE,IAAIV,oBAAqB;QAC1DO,KAAKI,GAAG,CAACF,WAAW;YAClB,CAAC,MAAM,EAAEA,UAAU,CAAC,EAAEP,SAAS,EAAE,CAAC;YAClCN,sPAAiB,CAACc,UAAU;SAC7B;IACH;IAEA,OAAOH;AACT;AAWO,SAASK,uBACdC,IAAY,EACZC,WAA+B;IAE/B,MAAMC,YAAQlB,uNAAAA,EAAcgB,MAAM;IAElC,wEAAwE;IACxE,6EAA6E;IAC7E,uCAAuC;IACvC,MAAM,EAAEG,0BAA0B,EAAEC,MAAM,EAAE,OAC1CnB,+TAAAA,EACEgB,YAAYI,QAAQ,CAACC,UAAU,EAC/BJ;IAGJ,0DAA0D;IAC1D,MAAMf,sBACJgB,2BAA2BI,GAAG,CAAC,CAAC,EAAEX,SAAS,EAAEC,SAAS,EAAE,GAAM,CAAA;YAC5DD;YACAC;QACF,CAAA;IAEF,8DAA8D;IAC9D,6DAA6D;IAC7D,2BAA2B;IAC3B,EAAE;IACF,oEAAoE;IACpE,iEAAiE;QACjEf,6NAAAA,EACEmB,YAAYI,QAAQ,CAACC,UAAU,EAC/BF,QACAF,OACAf,oBAAoB,sCAAsC;;IAG5D,2EAA2E;IAC3E,uEAAuE;IACvE,OAAOD,gCAAgCC;AACzC","ignoreList":[0]}},
    {"offset": {"line": 7775, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/request/utils.ts"],"sourcesContent":["import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n"],"names":["StaticGenBailoutError","afterTaskAsyncStorage","throwWithStaticGenerationBailoutErrorWithDynamicError","route","expression","throwForSearchParamsAccessInUseCache","workStore","constructorOpt","error","Error","captureStackTrace","invalidDynamicUsageError","isRequestAPICallableInsideAfter","afterTaskStore","getStore","rootTaskSpawnPhase"],"mappings":";;;;;;;;AAAA,SAASA,qBAAqB,QAAQ,oDAAmD;;AACzF,SAASC,qBAAqB,QAAQ,kDAAiD;;;AAGhF,SAASC,sDACdC,KAAa,EACbC,UAAkB;IAElB,MAAM,OAAA,cAEL,CAFK,IAAIJ,8OAAAA,CACR,CAAC,MAAM,EAAEG,MAAM,4EAA4E,EAAEC,WAAW,0HAA0H,CAAC,GAD/N,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASC,qCACdC,SAAoB,EACpBC,cAAwB;IAExB,MAAMC,QAAQ,OAAA,cAEb,CAFa,IAAIC,MAChB,CAAC,MAAM,EAAEH,UAAUH,KAAK,CAAC,2XAA2X,CAAC,GADzY,qBAAA;eAAA;oBAAA;sBAAA;IAEd;IAEAM,MAAMC,iBAAiB,CAACF,OAAOD;IAC/BD,UAAUK,wBAAwB,KAAKH;IAEvC,MAAMA;AACR;AAEO,SAASI;IACd,MAAMC,iBAAiBZ,4UAAAA,CAAsBa,QAAQ;IACrD,OAAOD,CAAAA,kBAAAA,OAAAA,KAAAA,IAAAA,eAAgBE,kBAAkB,MAAK;AAChD","ignoreList":[0]}},
    {"offset": {"line": 7813, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/request/search-params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  annotateDynamicAccess,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n  type PrerenderStoreModernRuntime,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in cache contexts.'\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerSearchParamsForServerPage should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderSearchParams(\n          underlyingSearchParams,\n          workUnitStore\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        // We're prerendering in a mode that aborts (cacheComponents) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          '`searchParams`'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n        return Promise.resolve({})\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nfunction createStaticPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n      // We are in a cacheComponents (PPR or otherwise) prerender\n      return makeHangingSearchParams(workStore, prerenderStore)\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // We are in a legacy static generation and need to interrupt the\n      // prerender when search params are accessed.\n      return makeErroringSearchParams(workStore, prerenderStore)\n    default:\n      return prerenderStore satisfies never\n  }\n}\n\nfunction createRuntimePrerenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<SearchParams> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedSearchParams(underlyingSearchParams)\n  )\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      // Semantically we only need the dev tracking when running in `next dev`\n      // but since you would never use next dev with production NODE_ENV we use this\n      // as a proxy so we can statically exclude this code from production builds.\n      return makeUntrackedSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore,\n        requestStore\n      )\n    } else {\n      return makeUntrackedSearchParams(underlyingSearchParams)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeHangingSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (typeof prop === 'string' && prop === 'then') {\n        const expression =\n          '`await searchParams`, `searchParams.then`, or similar'\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no cacheComponents)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get: function get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, get)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (requestStore.asyncApiPromises) {\n    // Do not cache the resulting promise. If we do, we'll only show the first \"awaited at\"\n    // across all segments that receive searchParams.\n    return makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n  } else {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n    if (cachedSearchParams) {\n      return cachedSearchParams\n    }\n    const promise = makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n    CachedSearchParams.set(requestStore, promise)\n    return promise\n  }\n}\n\nfunction makeUntrackedSearchParamsWithDevWarningsImpl(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  const promiseInitialized = { current: false }\n  const proxiedUnderlying = instrumentSearchParamsObjectWithDevWarnings(\n    underlyingSearchParams,\n    workStore,\n    promiseInitialized\n  )\n\n  let promise: Promise<SearchParams>\n  if (requestStore.asyncApiPromises) {\n    // We wrap each instance of searchParams in a `new Promise()`.\n    // This is important when all awaits are in third party which would otherwise\n    // track all the way to the internal params.\n    const sharedSearchParamsParent =\n      requestStore.asyncApiPromises.sharedSearchParamsParent\n    promise = new Promise((resolve, reject) => {\n      sharedSearchParamsParent.then(() => resolve(proxiedUnderlying), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'searchParams'\n  } else {\n    promise = makeDevtoolsIOAwarePromise(\n      proxiedUnderlying,\n      requestStore,\n      RenderStage.Runtime\n    )\n  }\n  promise.then(\n    () => {\n      promiseInitialized.current = true\n    },\n    // If we're in staged rendering, this promise will reject if the render\n    // is aborted before it can reach the runtime stage.\n    // In that case, we have to prevent an unhandled rejection from the promise\n    // created by this `.then()` call.\n    // This does not affect the `promiseInitialized` logic above,\n    // because `proxiedUnderlying` will not be used to resolve the promise,\n    // so there's no risk of any of its properties being accessed and triggering\n    // an undesireable warning.\n    ignoreReject\n  )\n\n  return instrumentSearchParamsPromiseWithDevWarnings(\n    underlyingSearchParams,\n    promise,\n    workStore\n  )\n}\n\nfunction ignoreReject() {}\n\nfunction instrumentSearchParamsObjectWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  promiseInitialized: { current: boolean }\n) {\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  return new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized.current) {\n        if (workStore.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (workStore.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (workStore.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nfunction instrumentSearchParamsPromiseWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  promise: Promise<SearchParams>,\n  workStore: WorkStore\n) {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && workStore.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n"],"names":["ReflectAdapter","throwToInterruptStaticGeneration","postponeWithTracking","annotateDynamicAccess","delayUntilRuntimeStage","workUnitAsyncStorage","throwInvariantForMissingStore","InvariantError","makeDevtoolsIOAwarePromise","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","describeStringPropertyAccess","describeHasCheckingStringProperty","wellKnownProperties","throwWithStaticGenerationBailoutErrorWithDynamicError","throwForSearchParamsAccessInUseCache","RenderStage","createSearchParamsFromClient","underlyingSearchParams","workStore","workUnitStore","getStore","type","createStaticPrerenderSearchParams","createRenderSearchParams","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","createRuntimePrerenderSearchParams","createPrerenderSearchParamsForClientPage","forceStatic","Promise","resolve","renderSignal","route","prerenderStore","makeHangingSearchParams","makeErroringSearchParams","makeUntrackedSearchParams","requestStore","process","env","NODE_ENV","makeUntrackedSearchParamsWithDevWarnings","CachedSearchParams","WeakMap","CachedSearchParamsForUseCache","cachedSearchParams","get","promise","proxiedPromise","Proxy","target","prop","receiver","Object","hasOwn","expression","set","dynamicShouldError","dynamicTracking","makeErroringSearchParamsForUseCache","has","asyncApiPromises","makeUntrackedSearchParamsWithDevWarningsImpl","promiseInitialized","current","proxiedUnderlying","instrumentSearchParamsObjectWithDevWarnings","sharedSearchParamsParent","reject","then","displayName","Runtime","ignoreReject","instrumentSearchParamsPromiseWithDevWarnings","Reflect","ownKeys","proxiedProperties","Set","keys","forEach","add","warnForSyncAccess","value","delete","createSearchAccessError","prefix","Error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8233, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/request/params.ts"],"sourcesContent":["import {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { OpaqueFallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type StaticPrerenderStoreModern,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type PrerenderStoreModernRuntime,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForRoute should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForServerSegment should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params\n): Promise<Params> {\n  const workStore = workAsyncStorage.getStore()\n  if (!workStore) {\n    throw new InvariantError(\n      'Missing workStore in createPrerenderParamsForClientSegment'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams) {\n          for (let key in underlyingParams) {\n            if (fallbackParams.has(key)) {\n              // This params object has one or more fallback params, so we need\n              // to consider the awaiting of this params object \"dynamic\". Since\n              // we are in cacheComponents mode we encode this as a promise that never\n              // resolves.\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                '`params`'\n              )\n            }\n          }\n        }\n        break\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderParamsForClientSegment should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'prerender-runtime':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createStaticPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<Params> {\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            // This params object has one or more fallback params, so we need\n            // to consider the awaiting of this params object \"dynamic\". Since\n            // we are in cacheComponents mode we encode this as a promise that never\n            // resolves.\n            return makeHangingParams(\n              underlyingParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            return makeErroringParams(\n              underlyingParams,\n              fallbackParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRuntimePrerenderParams(\n  underlyingParams: Params,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<Params> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedParams(underlyingParams)\n  )\n}\n\nfunction createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRenderParamsInDev(\n  underlyingParams: Params,\n  devFallbackParams: OpaqueFallbackRouteParams | null | undefined,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  let hasFallbackParams = false\n  if (devFallbackParams) {\n    for (let key in underlyingParams) {\n      if (devFallbackParams.has(key)) {\n        hasFallbackParams = true\n        break\n      }\n    }\n  }\n\n  return makeDynamicallyTrackedParamsWithDevWarnings(\n    underlyingParams,\n    hasFallbackParams,\n    workStore,\n    requestStore\n  )\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(\n      prerenderStore.renderSignal,\n      workStore.route,\n      '`params`'\n    ),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringParams(\n  underlyingParams: Params,\n  fallbackParams: OpaqueFallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  if (requestStore.asyncApiPromises && hasFallbackParams) {\n    // We wrap each instance of params in a `new Promise()`, because deduping\n    // them across requests doesn't work anyway and this let us show each\n    // await a different set of values. This is important when all awaits\n    // are in third party which would otherwise track all the way to the\n    // internal params.\n    const sharedParamsParent = requestStore.asyncApiPromises.sharedParamsParent\n    const promise: Promise<Params> = new Promise((resolve, reject) => {\n      sharedParamsParent.then(() => resolve(underlyingParams), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'params'\n    return instrumentParamsPromiseWithDevWarnings(\n      underlyingParams,\n      promise,\n      workStore\n    )\n  }\n\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(\n        underlyingParams,\n        requestStore,\n        RenderStage.Runtime\n      )\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedPromise = instrumentParamsPromiseWithDevWarnings(\n    underlyingParams,\n    promise,\n    workStore\n  )\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction instrumentParamsPromiseWithDevWarnings(\n  underlyingParams: Params,\n  promise: Promise<Params>,\n  workStore: WorkStore\n): Promise<Params> {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n"],"names":["workAsyncStorage","ReflectAdapter","throwToInterruptStaticGeneration","postponeWithTracking","delayUntilRuntimeStage","workUnitAsyncStorage","throwInvariantForMissingStore","InvariantError","describeStringPropertyAccess","wellKnownProperties","makeDevtoolsIOAwarePromise","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","dynamicAccessAsyncStorage","RenderStage","createParamsFromClient","underlyingParams","workStore","workUnitStore","getStore","type","createStaticPrerenderParams","process","env","NODE_ENV","devFallbackParams","createRenderParamsInDev","createRenderParamsInProd","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","createRuntimePrerenderParams","createPrerenderParamsForClientSegment","fallbackParams","fallbackRouteParams","key","has","renderSignal","route","Promise","resolve","prerenderStore","makeHangingParams","makeErroringParams","makeUntrackedParams","requestStore","hasFallbackParams","makeDynamicallyTrackedParamsWithDevWarnings","CachedParams","WeakMap","fallbackParamsProxyHandler","get","target","prop","receiver","originalMethod","args","store","abortController","abort","Error","Proxy","apply","cachedParams","promise","set","augmentedUnderlying","Object","keys","forEach","defineProperty","expression","dynamicTracking","enumerable","asyncApiPromises","sharedParamsParent","reject","then","displayName","instrumentParamsPromiseWithDevWarnings","Runtime","proxiedPromise","proxiedProperties","Set","add","warnForSyncAccess","value","delete","ownKeys","Reflect","createParamsAccessError","prefix"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8637, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/request/pathname.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  type DynamicTrackingState,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  throwInvariantForMissingStore,\n  workUnitAsyncStorage,\n  type StaticPrerenderStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport function createServerPathnameForMetadata(\n  underlyingPathname: string,\n  workStore: WorkStore\n): Promise<string> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy': {\n        return createPrerenderPathname(\n          underlyingPathname,\n          workStore,\n          workUnitStore\n        )\n      }\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerPathnameForMetadata should not be called in cache contexts.'\n        )\n\n      case 'prerender-runtime':\n        return delayUntilRuntimeStage(\n          workUnitStore,\n          createRenderPathname(underlyingPathname)\n        )\n      case 'request':\n        return createRenderPathname(underlyingPathname)\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nfunction createPrerenderPathname(\n  underlyingPathname: string,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<string> {\n  switch (prerenderStore.type) {\n    case 'prerender-client':\n      throw new InvariantError(\n        'createPrerenderPathname was called inside a client component scope.'\n      )\n    case 'prerender': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams && fallbackParams.size > 0) {\n        return makeHangingPromise<string>(\n          prerenderStore.renderSignal,\n          workStore.route,\n          '`pathname`'\n        )\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams && fallbackParams.size > 0) {\n        return makeErroringPathname(workStore, prerenderStore.dynamicTracking)\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return Promise.resolve(underlyingPathname)\n}\n\nfunction makeErroringPathname<T>(\n  workStore: WorkStore,\n  dynamicTracking: null | DynamicTrackingState\n): Promise<T> {\n  let reject: null | ((reason: unknown) => void) = null\n  const promise = new Promise<T>((_, re) => {\n    reject = re\n  })\n\n  const originalThen = promise.then.bind(promise)\n\n  // We instrument .then so that we can generate a tracking event only if you actually\n  // await this promise, not just that it is created.\n  promise.then = (onfulfilled, onrejected) => {\n    if (reject) {\n      try {\n        postponeWithTracking(\n          workStore.route,\n          'metadata relative url resolving',\n          dynamicTracking\n        )\n      } catch (error) {\n        reject(error)\n        reject = null\n      }\n    }\n    return originalThen(onfulfilled, onrejected)\n  }\n\n  // We wrap in a noop proxy to trick the runtime into thinking it\n  // isn't a native promise (it's not really). This is so that awaiting\n  // the promise will call the `then` property triggering the lazy postpone\n  return new Proxy(promise, {})\n}\n\nfunction createRenderPathname(underlyingPathname: string): Promise<string> {\n  return Promise.resolve(underlyingPathname)\n}\n"],"names":["delayUntilRuntimeStage","postponeWithTracking","throwInvariantForMissingStore","workUnitAsyncStorage","makeHangingPromise","InvariantError","createServerPathnameForMetadata","underlyingPathname","workStore","workUnitStore","getStore","type","createPrerenderPathname","createRenderPathname","prerenderStore","fallbackParams","fallbackRouteParams","size","renderSignal","route","makeErroringPathname","dynamicTracking","Promise","resolve","reject","promise","_","re","originalThen","then","bind","onfulfilled","onrejected","error","Proxy"],"mappings":";;;;AAEA,SACEA,sBAAsB,EACtBC,oBAAoB,QAEf,kCAAiC;;AAExC,SACEC,6BAA6B,EAC7BC,oBAAoB,QAEf,iDAAgD;AACvD,SAASC,kBAAkB,QAAQ,6BAA4B;AAC/D,SAASC,cAAc,QAAQ,mCAAkC;;;;;AAE1D,SAASC,gCACdC,kBAA0B,EAC1BC,SAAoB;IAEpB,MAAMC,gBAAgBN,wUAAAA,CAAqBO,QAAQ;IACnD,IAAID,eAAe;QACjB,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBAAoB;oBACvB,OAAOC,wBACLL,oBACAC,WACAC;gBAEJ;YACA,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAM,OAAA,cAEL,CAFK,IAAIJ,mNAAAA,CACR,4EADI,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YAEF,KAAK;gBACH,WAAOL,uOAAAA,EACLS,eACAI,qBAAqBN;YAEzB,KAAK;gBACH,OAAOM,qBAAqBN;YAC9B;gBACEE;QACJ;IACF;QACAP,sRAAAA;AACF;AAEA,SAASU,wBACPL,kBAA0B,EAC1BC,SAAoB,EACpBM,cAAoC;IAEpC,OAAQA,eAAeH,IAAI;QACzB,KAAK;YACH,MAAM,OAAA,cAEL,CAFK,IAAIN,mNAAAA,CACR,wEADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF,KAAK;YAAa;gBAChB,MAAMU,iBAAiBD,eAAeE,mBAAmB;gBACzD,IAAID,kBAAkBA,eAAeE,IAAI,GAAG,GAAG;oBAC7C,WAAOb,2NAAAA,EACLU,eAAeI,YAAY,EAC3BV,UAAUW,KAAK,EACf;gBAEJ;gBACA;YACF;QACA,KAAK;YAAiB;gBACpB,MAAMJ,iBAAiBD,eAAeE,mBAAmB;gBACzD,IAAID,kBAAkBA,eAAeE,IAAI,GAAG,GAAG;oBAC7C,OAAOG,qBAAqBZ,WAAWM,eAAeO,eAAe;gBACvE;gBACA;YACF;QACA,KAAK;YACH;QACF;YACEP;IACJ;IAEA,qFAAqF;IACrF,OAAOQ,QAAQC,OAAO,CAAChB;AACzB;AAEA,SAASa,qBACPZ,SAAoB,EACpBa,eAA4C;IAE5C,IAAIG,SAA6C;IACjD,MAAMC,UAAU,IAAIH,QAAW,CAACI,GAAGC;QACjCH,SAASG;IACX;IAEA,MAAMC,eAAeH,QAAQI,IAAI,CAACC,IAAI,CAACL;IAEvC,oFAAoF;IACpF,mDAAmD;IACnDA,QAAQI,IAAI,GAAG,CAACE,aAAaC;QAC3B,IAAIR,QAAQ;YACV,IAAI;oBACFvB,qOAAAA,EACEO,UAAUW,KAAK,EACf,mCACAE;YAEJ,EAAE,OAAOY,OAAO;gBACdT,OAAOS;gBACPT,SAAS;YACX;QACF;QACA,OAAOI,aAAaG,aAAaC;IACnC;IAEA,gEAAgE;IAChE,qEAAqE;IACrE,yEAAyE;IACzE,OAAO,IAAIE,MAAMT,SAAS,CAAC;AAC7B;AAEA,SAASZ,qBAAqBN,kBAA0B;IACtD,OAAOe,QAAQC,OAAO,CAAChB;AACzB","ignoreList":[0]}},
    {"offset": {"line": 8742, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/send-payload.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport type RenderResult from './render-result'\nimport type { CacheControl } from './lib/cache-control'\n\nimport { isResSent } from '../shared/lib/utils'\nimport { generateETag } from './lib/etag'\nimport fresh from 'next/dist/compiled/fresh'\nimport { getCacheControlHeader } from './lib/cache-control'\nimport { HTML_CONTENT_TYPE_HEADER } from '../lib/constants'\n\nexport function sendEtagResponse(\n  req: IncomingMessage,\n  res: ServerResponse,\n  etag: string | undefined\n): boolean {\n  if (etag) {\n    /**\n     * The server generating a 304 response MUST generate any of the\n     * following header fields that would have been sent in a 200 (OK)\n     * response to the same request: Cache-Control, Content-Location, Date,\n     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1\n     */\n    res.setHeader('ETag', etag)\n  }\n\n  if (fresh(req.headers, { etag })) {\n    res.statusCode = 304\n    res.end()\n    return true\n  }\n\n  return false\n}\n\nexport async function sendRenderResult({\n  req,\n  res,\n  result,\n  generateEtags,\n  poweredByHeader,\n  cacheControl,\n}: {\n  req: IncomingMessage\n  res: ServerResponse\n  result: RenderResult\n  generateEtags: boolean\n  poweredByHeader: boolean\n  cacheControl: CacheControl | undefined\n}): Promise<void> {\n  if (isResSent(res)) {\n    return\n  }\n\n  if (poweredByHeader && result.contentType === HTML_CONTENT_TYPE_HEADER) {\n    res.setHeader('X-Powered-By', 'Next.js')\n  }\n\n  // If cache control is already set on the response we don't\n  // override it to allow users to customize it via next.config\n  if (cacheControl && !res.getHeader('Cache-Control')) {\n    res.setHeader('Cache-Control', getCacheControlHeader(cacheControl))\n  }\n\n  const payload = result.isDynamic ? null : result.toUnchunkedString()\n\n  if (generateEtags && payload !== null) {\n    const etag = generateETag(payload)\n    if (sendEtagResponse(req, res, etag)) {\n      return\n    }\n  }\n\n  if (!res.getHeader('Content-Type') && result.contentType) {\n    res.setHeader('Content-Type', result.contentType)\n  }\n\n  if (payload) {\n    res.setHeader('Content-Length', Buffer.byteLength(payload))\n  }\n\n  if (req.method === 'HEAD') {\n    res.end(null)\n    return\n  }\n\n  if (payload !== null) {\n    res.end(payload)\n    return\n  }\n\n  // Pipe the render result to the response after we get a writer for it.\n  await result.pipeToNodeResponse(res)\n}\n"],"names":["isResSent","generateETag","fresh","getCacheControlHeader","HTML_CONTENT_TYPE_HEADER","sendEtagResponse","req","res","etag","setHeader","headers","statusCode","end","sendRenderResult","result","generateEtags","poweredByHeader","cacheControl","contentType","getHeader","payload","isDynamic","toUnchunkedString","Buffer","byteLength","method","pipeToNodeResponse"],"mappings":";;;;;;AA6EoCuB;AAzEpC,SAASvB,SAAS,QAAQ,sBAAqB;AAC/C,SAASC,YAAY,QAAQ,aAAY;AACzC,OAAOC,WAAW,2BAA0B;AAC5C,SAASC,qBAAqB,QAAQ,sBAAqB;AAC3D,SAASC,wBAAwB,QAAQ,mBAAkB;;;;;;AAEpD,SAASC,iBACdC,GAAoB,EACpBC,GAAmB,EACnBC,IAAwB;IAExB,IAAIA,MAAM;QACR;;;;;KAKC,GACDD,IAAIE,SAAS,CAAC,QAAQD;IACxB;IAEA,QAAIN,4LAAAA,EAAMI,IAAII,OAAO,EAAE;QAAEF;IAAK,IAAI;QAChCD,IAAII,UAAU,GAAG;QACjBJ,IAAIK,GAAG;QACP,OAAO;IACT;IAEA,OAAO;AACT;AAEO,eAAeC,iBAAiB,EACrCP,GAAG,EACHC,GAAG,EACHO,MAAM,EACNC,aAAa,EACbC,eAAe,EACfC,YAAY,EAQb;IACC,QAAIjB,iMAAAA,EAAUO,MAAM;QAClB;IACF;IAEA,IAAIS,mBAAmBF,OAAOI,WAAW,KAAKd,0MAAAA,EAA0B;QACtEG,IAAIE,SAAS,CAAC,gBAAgB;IAChC;IAEA,2DAA2D;IAC3D,6DAA6D;IAC7D,IAAIQ,gBAAgB,CAACV,IAAIY,SAAS,CAAC,kBAAkB;QACnDZ,IAAIE,SAAS,CAAC,qBAAiBN,wNAAAA,EAAsBc;IACvD;IAEA,MAAMG,UAAUN,OAAOO,SAAS,GAAG,OAAOP,OAAOQ,iBAAiB;IAElE,IAAIP,iBAAiBK,YAAY,MAAM;QACrC,MAAMZ,WAAOP,mMAAAA,EAAamB;QAC1B,IAAIf,iBAAiBC,KAAKC,KAAKC,OAAO;YACpC;QACF;IACF;IAEA,IAAI,CAACD,IAAIY,SAAS,CAAC,mBAAmBL,OAAOI,WAAW,EAAE;QACxDX,IAAIE,SAAS,CAAC,gBAAgBK,OAAOI,WAAW;IAClD;IAEA,IAAIE,SAAS;QACXb,IAAIE,SAAS,CAAC,iJAAkBc,CAAOC,UAAU,CAACJ;IACpD;IAEA,IAAId,IAAImB,MAAM,KAAK,QAAQ;QACzBlB,IAAIK,GAAG,CAAC;QACR;IACF;IAEA,IAAIQ,YAAY,MAAM;QACpBb,IAAIK,GAAG,CAACQ;QACR;IACF;IAEA,uEAAuE;IACvE,MAAMN,OAAOY,kBAAkB,CAACnB;AAClC","ignoreList":[0]}},
    {"offset": {"line": 8817, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["import type { NonStaticRenderStage } from './app-render/staged-rendering'\nimport type { RequestStore } from './app-render/work-unit-async-storage.external'\n\nexport function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(\n  underlying: T,\n  requestStore: RequestStore,\n  stage: NonStaticRenderStage\n): Promise<T> {\n  if (requestStore.stagedRendering) {\n    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n    return requestStore.stagedRendering.delayUntilStage(\n      stage,\n      undefined,\n      underlying\n    )\n  }\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n"],"names":["isHangingPromiseRejectionError","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","route","expression","abortListenersBySignal","WeakMap","makeHangingPromise","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","bind","currentListeners","get","push","listeners","set","addEventListener","i","length","once","catch","ignoreReject","makeDevtoolsIOAwarePromise","underlying","requestStore","stage","stagedRendering","delayUntilStage","undefined","resolve","setTimeout"],"mappings":";;;;;;;;AAGO,SAASA,+BACdC,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YACkBC,KAAa,EACbC,UAAkB,CAClC;QACA,KAAK,CACH,CAAC,qBAAqB,EAAEA,WAAW,qGAAqG,EAAEA,WAAW,8KAA8K,EAAED,MAAM,EAAE,CAAC,GAAA,IAAA,CAJhUA,KAAAA,GAAAA,OAAAA,IAAAA,CACAC,UAAAA,GAAAA,YAAAA,IAAAA,CAJFN,MAAAA,GAASC;IASzB;AACF;AAGA,MAAMM,yBAAyB,IAAIC;AAS5B,SAASC,mBACdC,MAAmB,EACnBL,KAAa,EACbC,UAAkB;IAElB,IAAII,OAAOC,OAAO,EAAE;QAClB,OAAOC,QAAQC,MAAM,CAAC,IAAIX,6BAA6BG,OAAOC;IAChE,OAAO;QACL,MAAMQ,iBAAiB,IAAIF,QAAW,CAACG,GAAGF;YACxC,MAAMG,iBAAiBH,OAAOI,IAAI,CAChC,MACA,IAAIf,6BAA6BG,OAAOC;YAE1C,IAAIY,mBAAmBX,uBAAuBY,GAAG,CAACT;YAClD,IAAIQ,kBAAkB;gBACpBA,iBAAiBE,IAAI,CAACJ;YACxB,OAAO;gBACL,MAAMK,YAAY;oBAACL;iBAAe;gBAClCT,uBAAuBe,GAAG,CAACZ,QAAQW;gBACnCX,OAAOa,gBAAgB,CACrB,SACA;oBACE,IAAK,IAAIC,IAAI,GAAGA,IAAIH,UAAUI,MAAM,EAAED,IAAK;wBACzCH,SAAS,CAACG,EAAE;oBACd;gBACF,GACA;oBAAEE,MAAM;gBAAK;YAEjB;QACF;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzFZ,eAAea,KAAK,CAACC;QACrB,OAAOd;IACT;AACF;AAEA,SAASc,gBAAgB;AAElB,SAASC,2BACdC,UAAa,EACbC,YAA0B,EAC1BC,KAA2B;IAE3B,IAAID,aAAaE,eAAe,EAAE;QAChC,iFAAiF;QACjF,OAAOF,aAAaE,eAAe,CAACC,eAAe,CACjDF,OACAG,WACAL;IAEJ;IACA,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAIlB,QAAW,CAACwB;QACrB,sFAAsF;QACtFC,WAAW;YACTD,QAAQN;QACV,GAAG;IACL;AACF","ignoreList":[0]}},
    {"offset": {"line": 8887, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/SB/Lumen/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts"],"sourcesContent":["import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n"],"names":["React","errorRef","current","cache","fn","logErrorOrWarn","process","env","__NEXT_CACHE_COMPONENTS","console","error","warn","flushCurrentErrorIfNew","key","createDedupedByCallsiteServerErrorLoggerDev","getMessage","logDedupedError","args","message","NODE_ENV","callStackFrames","Error","stack","split","undefined","length"],"mappings":";;;;AAAA,YAAYA,WAAW,QAAO;;AAE9B,MAAMC,WAAsC;IAAEC,SAAS;AAAK;AAE5D,iFAAiF;AACjF,MAAMC,QACJ,OAAOH,MAAMG,uMAAK,KAAK,aACnBH,MAAMG,uMAAK,GACX,CAACC,KAA+BA;AAEtC,2EAA2E;AAC3E,qEAAqE;AACrE,gBAAgB;AAChB,MAAMC,iBAAiBC,QAAQC,GAAG,CAACC,uBAAuB,GACtDC,QAAQC,KAAK,aACbD,QAAQE,IAAI;AAEhB,2CAA2C;AAC3C,wGAAwG;AACxG,MAAMC,yBAAyBT,MAC7B,AACA,CAACU,yEADyE;IAExE,IAAI;QACFR,eAAeJ,SAASC,OAAO;IACjC,SAAU;QACRD,SAASC,OAAO,GAAG;IACrB;AACF;AAcK,SAASY,4CACdC,UAAoC;IAEpC,OAAO,SAASC,gBAAgB,GAAGC,IAAU;QAC3C,MAAMC,UAAUH,cAAcE;QAE9B,IAAIX,QAAQC,GAAG,CAACY,QAAQ,KAAK,WAAc;gBACjB;YAAxB,MAAMC,kBAAAA,CAAkB,SAAA,IAAIC,QAAQC,KAAK,KAAA,OAAA,KAAA,IAAjB,OAAmBC,KAAK,CAAC;YACjD,IAAIH,oBAAoBI,aAAaJ,gBAAgBK,MAAM,GAAG,GAAG;gBAC/DpB,eAAea;YACjB,OAAO;gBACL,SAAS;gBACT,oBAAoB;gBACpB,uCAAuC;gBACvC,wBAAwB;gBACxB,iEAAiE;gBACjE,MAAML,MAAMO,eAAe,CAAC,EAAE;gBAC9BnB,SAASC,OAAO,GAAGgB;gBACnBN,uBAAuBC;YACzB;QACF,OAAO;;IAGT;AACF","ignoreList":[0]}}]
}