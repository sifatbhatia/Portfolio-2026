{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/shared/lib/utils/warn-once.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/types.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/cache-key.ts","turbopack:///[project]/node_modules/next/src/shared/lib/app-router-types.ts","turbopack:///[project]/node_modules/next/src/client/components/match-segments.ts","turbopack:///[project]/node_modules/next/dist/compiled/react-dom/cjs/react-dom.production.js","turbopack:///[project]/node_modules/next/dist/compiled/react-dom/index.js","turbopack:///[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.edge.production.js","turbopack:///[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.edge.js","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","turbopack:///[project]/node_modules/next/src/shared/lib/is-thenable.ts","turbopack:///[project]/node_modules/next/src/client/components/use-action-queue.ts","turbopack:///[project]/node_modules/next/dist/esm/client/app-find-source-map-url.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-call-server.js","turbopack:///[project]/node_modules/next/dist/esm/client/route-params.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/segment-cache/segment-value-encoding.js","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","turbopack:///[project]/node_modules/next/dist/esm/client/flight-data-helpers.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-build-id.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/cache-busting-search-param.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/hash.js","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/deployment-id.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/segment-cache/vary-path.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/segment-cache/lru.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/segment-cache/cache-map.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/interception-routes.ts","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/compute-changed-path.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/handle-mutable.js","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts","turbopack:///[project]/node_modules/next/dist/esm/client/components/segment-cache/navigation.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/navigate-reducer.js","turbopack:///[project]/node_modules/next/src/shared/lib/promise-with-resolvers.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/cache.ts","turbopack:///[project]/node_modules/next/dist/esm/client/components/segment-cache/scheduler.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/links.js"],"sourcesContent":["let warnOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const warnings = new Set<string>()\n  warnOnce = (msg: string) => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\nexport { warnOnce }\n","/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */\n\nimport type React from 'react'\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\nexport type ChildSegmentMap = Map<string, CacheNode>\n\n/**\n * Cache node used in app-router / layout-router.\n */\n\nexport type CacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty. When it is\n   * null, it represents missing data, and rendering should suspend.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  /**\n   * The timestamp of the navigation that last updated the CacheNode's data. If\n   * a CacheNode is reused from a previous navigation, this value is not\n   * updated. Used to track the staleness of the data.\n   */\n  navigatedAt: number\n}\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted-(..)(..)'\n  | 'catchall-intercepted-(.)'\n  | 'catchall-intercepted-(..)'\n  | 'catchall-intercepted-(...)'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted-(..)(..)'\n  | 'dynamic-intercepted-(.)'\n  | 'dynamic-intercepted-(..)'\n  | 'dynamic-intercepted-(...)'\n\nexport type DynamicParamTypesShort =\n  | 'c'\n  | 'ci(..)(..)'\n  | 'ci(.)'\n  | 'ci(..)'\n  | 'ci(...)'\n  | 'oc'\n  | 'd'\n  | 'di(..)(..)'\n  | 'di(.)'\n  | 'di(..)'\n  | 'di(...)'\n\nexport type Segment =\n  | string\n  | [\n      // Param name\n      paramName: string,\n      // Param cache key (almost the same as the value, but arrays are\n      // concatenated into strings)\n      // TODO: We should change this to just be the value. Currently we convert\n      // it back to a value when passing to useParams. It only needs to be\n      // a string when converted to a a cache key, but that doesn't mean we\n      // need to store it as that representation.\n      paramCacheKey: string,\n      // Dynamic param type\n      dynamicParamType: DynamicParamTypesShort,\n    ]\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation — inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   * - \"metadata-only\" instructs the server to skip rendering the segments and\n   *   only send the head data.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case — during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?:\n    | 'refetch'\n    | 'refresh'\n    | 'inside-shared-layout'\n    | 'metadata-only'\n    | null,\n  isRootLayout?: boolean,\n  /**\n   * Only present when responding to a tree prefetch request. Indicates whether\n   * there is a loading boundary somewhere in the tree. The client cache uses\n   * this to determine if it can skip the data prefetch request.\n   */\n  hasLoadingBoundary?: HasLoadingBoundary,\n]\n\nexport const enum HasLoadingBoundary {\n  // There is a loading boundary in this particular segment\n  SegmentHasLoadingBoundary = 1,\n  // There is a loading boundary somewhere in the subtree (but not in\n  // this segment)\n  SubtreeHasLoadingBoundary = 2,\n  // There is no loading boundary in this segment or any of its descendants\n  SubtreeHasNoLoadingBoundary = 3,\n}\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  /** TODO: this doesn't feel like it belongs here, because it's only used during build, in `collectSegmentData` */\n  hasRuntimePrefetch: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** initialRenderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n  rp?: [boolean, number]\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n","import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","/**\n * @license React\n * react-dom.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"next/dist/compiled/react\");\nfunction formatProdErrorMessage(code) {\n  var url = \"https://react.dev/errors/\" + code;\n  if (1 < arguments.length) {\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    \"Minified React error #\" +\n    code +\n    \"; visit \" +\n    url +\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\n  );\n}\nfunction noop() {}\nvar Internals = {\n    d: {\n      f: noop,\n      r: function () {\n        throw Error(formatProdErrorMessage(522));\n      },\n      D: noop,\n      C: noop,\n      L: noop,\n      m: noop,\n      X: noop,\n      S: noop,\n      M: noop\n    },\n    p: 0,\n    findDOMNode: null\n  },\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n  REACT_OPTIMISTIC_KEY = Symbol.for(\"react.optimistic_key\");\nfunction createPortal$1(children, containerInfo, implementation) {\n  var key =\n    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key:\n      null == key\n        ? null\n        : key === REACT_OPTIMISTIC_KEY\n          ? REACT_OPTIMISTIC_KEY\n          : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\nvar ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\nfunction getCrossOriginStringAs(as, input) {\n  if (\"font\" === as) return \"\";\n  if (\"string\" === typeof input)\n    return \"use-credentials\" === input ? input : \"\";\n}\nexports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  Internals;\nexports.createPortal = function (children, container) {\n  var key =\n    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n  if (\n    !container ||\n    (1 !== container.nodeType &&\n      9 !== container.nodeType &&\n      11 !== container.nodeType)\n  )\n    throw Error(formatProdErrorMessage(299));\n  return createPortal$1(children, container, null, key);\n};\nexports.flushSync = function (fn) {\n  var previousTransition = ReactSharedInternals.T,\n    previousUpdatePriority = Internals.p;\n  try {\n    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();\n  } finally {\n    (ReactSharedInternals.T = previousTransition),\n      (Internals.p = previousUpdatePriority),\n      Internals.d.f();\n  }\n};\nexports.preconnect = function (href, options) {\n  \"string\" === typeof href &&\n    (options\n      ? ((options = options.crossOrigin),\n        (options =\n          \"string\" === typeof options\n            ? \"use-credentials\" === options\n              ? options\n              : \"\"\n            : void 0))\n      : (options = null),\n    Internals.d.C(href, options));\n};\nexports.prefetchDNS = function (href) {\n  \"string\" === typeof href && Internals.d.D(href);\n};\nexports.preinit = function (href, options) {\n  if (\"string\" === typeof href && options && \"string\" === typeof options.as) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\n      integrity =\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\n      fetchPriority =\n        \"string\" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0;\n    \"style\" === as\n      ? Internals.d.S(\n          href,\n          \"string\" === typeof options.precedence ? options.precedence : void 0,\n          {\n            crossOrigin: crossOrigin,\n            integrity: integrity,\n            fetchPriority: fetchPriority\n          }\n        )\n      : \"script\" === as &&\n        Internals.d.X(href, {\n          crossOrigin: crossOrigin,\n          integrity: integrity,\n          fetchPriority: fetchPriority,\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n        });\n  }\n};\nexports.preinitModule = function (href, options) {\n  if (\"string\" === typeof href)\n    if (\"object\" === typeof options && null !== options) {\n      if (null == options.as || \"script\" === options.as) {\n        var crossOrigin = getCrossOriginStringAs(\n          options.as,\n          options.crossOrigin\n        );\n        Internals.d.M(href, {\n          crossOrigin: crossOrigin,\n          integrity:\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n        });\n      }\n    } else null == options && Internals.d.M(href);\n};\nexports.preload = function (href, options) {\n  if (\n    \"string\" === typeof href &&\n    \"object\" === typeof options &&\n    null !== options &&\n    \"string\" === typeof options.as\n  ) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\n    Internals.d.L(href, as, {\n      crossOrigin: crossOrigin,\n      integrity:\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\n      nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\n      type: \"string\" === typeof options.type ? options.type : void 0,\n      fetchPriority:\n        \"string\" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0,\n      referrerPolicy:\n        \"string\" === typeof options.referrerPolicy\n          ? options.referrerPolicy\n          : void 0,\n      imageSrcSet:\n        \"string\" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,\n      imageSizes:\n        \"string\" === typeof options.imageSizes ? options.imageSizes : void 0,\n      media: \"string\" === typeof options.media ? options.media : void 0\n    });\n  }\n};\nexports.preloadModule = function (href, options) {\n  if (\"string\" === typeof href)\n    if (options) {\n      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);\n      Internals.d.m(href, {\n        as:\n          \"string\" === typeof options.as && \"script\" !== options.as\n            ? options.as\n            : void 0,\n        crossOrigin: crossOrigin,\n        integrity:\n          \"string\" === typeof options.integrity ? options.integrity : void 0\n      });\n    } else Internals.d.m(href);\n};\nexports.requestFormReset = function (form) {\n  Internals.d.r(form);\n};\nexports.unstable_batchedUpdates = function (fn, a) {\n  return fn(a);\n};\nexports.useFormState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useFormState(action, initialState, permalink);\n};\nexports.useFormStatus = function () {\n  return ReactSharedInternals.H.useHostTransitionStatus();\n};\nexports.version = \"19.3.0-canary-f93b9fd4-20251217\";\n","'use strict';\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = require('./cjs/react-dom.production.js');\n} else {\n  module.exports = require('./cjs/react-dom.development.js');\n}\n","/**\n * @license React\n * react-server-dom-turbopack-client.edge.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar ReactDOM = require(\"react-dom\"),\n  decoderOptions = { stream: !0 },\n  hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction resolveClientReference(bundlerConfig, metadata) {\n  if (bundlerConfig) {\n    var moduleExports = bundlerConfig[metadata[0]];\n    if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))\n      moduleExports = bundlerConfig.name;\n    else {\n      bundlerConfig = moduleExports && moduleExports[\"*\"];\n      if (!bundlerConfig)\n        throw Error(\n          'Could not find the module \"' +\n            metadata[0] +\n            '\" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'\n        );\n      moduleExports = metadata[2];\n    }\n    return 4 === metadata.length\n      ? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, 1]\n      : [bundlerConfig.id, bundlerConfig.chunks, moduleExports];\n  }\n  return metadata;\n}\nfunction resolveServerReference(bundlerConfig, id) {\n  var name = \"\",\n    resolvedModuleData = bundlerConfig[id];\n  if (resolvedModuleData) name = resolvedModuleData.name;\n  else {\n    var idx = id.lastIndexOf(\"#\");\n    -1 !== idx &&\n      ((name = id.slice(idx + 1)),\n      (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));\n    if (!resolvedModuleData)\n      throw Error(\n        'Could not find the module \"' +\n          id +\n          '\" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'\n      );\n  }\n  return resolvedModuleData.async\n    ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]\n    : [resolvedModuleData.id, resolvedModuleData.chunks, name];\n}\nfunction requireAsyncModule(id) {\n  var promise = globalThis.__next_require__(id);\n  if (\"function\" !== typeof promise.then || \"fulfilled\" === promise.status)\n    return null;\n  promise.then(\n    function (value) {\n      promise.status = \"fulfilled\";\n      promise.value = value;\n    },\n    function (reason) {\n      promise.status = \"rejected\";\n      promise.reason = reason;\n    }\n  );\n  return promise;\n}\nvar instrumentedChunks = new WeakSet(),\n  loadedChunks = new WeakSet();\nfunction ignoreReject() {}\nfunction preloadModule(metadata) {\n  for (var chunks = metadata[1], promises = [], i = 0; i < chunks.length; i++) {\n    var thenable = globalThis.__next_chunk_load__(chunks[i]);\n    loadedChunks.has(thenable) || promises.push(thenable);\n    if (!instrumentedChunks.has(thenable)) {\n      var resolve = loadedChunks.add.bind(loadedChunks, thenable);\n      thenable.then(resolve, ignoreReject);\n      instrumentedChunks.add(thenable);\n    }\n  }\n  return 4 === metadata.length\n    ? 0 === promises.length\n      ? requireAsyncModule(metadata[0])\n      : Promise.all(promises).then(function () {\n          return requireAsyncModule(metadata[0]);\n        })\n    : 0 < promises.length\n      ? Promise.all(promises)\n      : null;\n}\nfunction requireModule(metadata) {\n  var moduleExports = globalThis.__next_require__(metadata[0]);\n  if (4 === metadata.length && \"function\" === typeof moduleExports.then)\n    if (\"fulfilled\" === moduleExports.status)\n      moduleExports = moduleExports.value;\n    else throw moduleExports.reason;\n  if (\"*\" === metadata[2]) return moduleExports;\n  if (\"\" === metadata[2])\n    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n  if (hasOwnProperty.call(moduleExports, metadata[2]))\n    return moduleExports[metadata[2]];\n}\nfunction prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n  if (null !== moduleLoading)\n    for (var i = 0; i < chunks.length; i++) {\n      var nonce = nonce$jscomp$0,\n        JSCompiler_temp_const = ReactDOMSharedInternals.d,\n        JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.X,\n        JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];\n      var JSCompiler_inline_result = moduleLoading.crossOrigin;\n      JSCompiler_inline_result =\n        \"string\" === typeof JSCompiler_inline_result\n          ? \"use-credentials\" === JSCompiler_inline_result\n            ? JSCompiler_inline_result\n            : \"\"\n          : void 0;\n      JSCompiler_temp_const$jscomp$0.call(\n        JSCompiler_temp_const,\n        JSCompiler_temp_const$jscomp$1,\n        { crossOrigin: JSCompiler_inline_result, nonce: nonce }\n      );\n    }\n}\nvar ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ASYNC_ITERATOR = Symbol.asyncIterator,\n  isArrayImpl = Array.isArray,\n  getPrototypeOf = Object.getPrototypeOf,\n  ObjectPrototype = Object.prototype,\n  knownServerReferences = new WeakMap();\nfunction serializeNumber(number) {\n  return Number.isFinite(number)\n    ? 0 === number && -Infinity === 1 / number\n      ? \"$-0\"\n      : number\n    : Infinity === number\n      ? \"$Infinity\"\n      : -Infinity === number\n        ? \"$-Infinity\"\n        : \"$NaN\";\n}\nfunction processReply(\n  root,\n  formFieldPrefix,\n  temporaryReferences,\n  resolve,\n  reject\n) {\n  function serializeTypedArray(tag, typedArray) {\n    typedArray = new Blob([\n      new Uint8Array(\n        typedArray.buffer,\n        typedArray.byteOffset,\n        typedArray.byteLength\n      )\n    ]);\n    var blobId = nextPartId++;\n    null === formData && (formData = new FormData());\n    formData.append(formFieldPrefix + blobId, typedArray);\n    return \"$\" + tag + blobId.toString(16);\n  }\n  function serializeBinaryReader(reader) {\n    function progress(entry) {\n      entry.done\n        ? ((entry = nextPartId++),\n          data.append(formFieldPrefix + entry, new Blob(buffer)),\n          data.append(\n            formFieldPrefix + streamId,\n            '\"$o' + entry.toString(16) + '\"'\n          ),\n          data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data))\n        : (buffer.push(entry.value),\n          reader.read(new Uint8Array(1024)).then(progress, reject));\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++,\n      buffer = [];\n    reader.read(new Uint8Array(1024)).then(progress, reject);\n    return \"$r\" + streamId.toString(16);\n  }\n  function serializeReader(reader) {\n    function progress(entry) {\n      if (entry.done)\n        data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data);\n      else\n        try {\n          var partJSON = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON);\n          reader.read().then(progress, reject);\n        } catch (x) {\n          reject(x);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    reader.read().then(progress, reject);\n    return \"$R\" + streamId.toString(16);\n  }\n  function serializeReadableStream(stream) {\n    try {\n      var binaryReader = stream.getReader({ mode: \"byob\" });\n    } catch (x) {\n      return serializeReader(stream.getReader());\n    }\n    return serializeBinaryReader(binaryReader);\n  }\n  function serializeAsyncIterable(iterable, iterator) {\n    function progress(entry) {\n      if (entry.done) {\n        if (void 0 === entry.value)\n          data.append(formFieldPrefix + streamId, \"C\");\n        else\n          try {\n            var partJSON = JSON.stringify(entry.value, resolveToJSON);\n            data.append(formFieldPrefix + streamId, \"C\" + partJSON);\n          } catch (x) {\n            reject(x);\n            return;\n          }\n        pendingParts--;\n        0 === pendingParts && resolve(data);\n      } else\n        try {\n          var partJSON$21 = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON$21);\n          iterator.next().then(progress, reject);\n        } catch (x$22) {\n          reject(x$22);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    iterable = iterable === iterator;\n    iterator.next().then(progress, reject);\n    return \"$\" + (iterable ? \"x\" : \"X\") + streamId.toString(16);\n  }\n  function resolveToJSON(key, value) {\n    if (null === value) return null;\n    if (\"object\" === typeof value) {\n      switch (value.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          if (void 0 !== temporaryReferences && -1 === key.indexOf(\":\")) {\n            var parentReference = writtenObjects.get(this);\n            if (void 0 !== parentReference)\n              return (\n                temporaryReferences.set(parentReference + \":\" + key, value),\n                \"$T\"\n              );\n          }\n          throw Error(\n            \"React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n          );\n        case REACT_LAZY_TYPE:\n          parentReference = value._payload;\n          var init = value._init;\n          null === formData && (formData = new FormData());\n          pendingParts++;\n          try {\n            var resolvedModel = init(parentReference),\n              lazyId = nextPartId++,\n              partJSON = serializeModel(resolvedModel, lazyId);\n            formData.append(formFieldPrefix + lazyId, partJSON);\n            return \"$\" + lazyId.toString(16);\n          } catch (x) {\n            if (\n              \"object\" === typeof x &&\n              null !== x &&\n              \"function\" === typeof x.then\n            ) {\n              pendingParts++;\n              var lazyId$23 = nextPartId++;\n              parentReference = function () {\n                try {\n                  var partJSON$24 = serializeModel(value, lazyId$23),\n                    data$25 = formData;\n                  data$25.append(formFieldPrefix + lazyId$23, partJSON$24);\n                  pendingParts--;\n                  0 === pendingParts && resolve(data$25);\n                } catch (reason) {\n                  reject(reason);\n                }\n              };\n              x.then(parentReference, parentReference);\n              return \"$\" + lazyId$23.toString(16);\n            }\n            reject(x);\n            return null;\n          } finally {\n            pendingParts--;\n          }\n      }\n      parentReference = writtenObjects.get(value);\n      if (\"function\" === typeof value.then) {\n        if (void 0 !== parentReference)\n          if (modelRoot === value) modelRoot = null;\n          else return parentReference;\n        null === formData && (formData = new FormData());\n        pendingParts++;\n        var promiseId = nextPartId++;\n        key = \"$@\" + promiseId.toString(16);\n        writtenObjects.set(value, key);\n        value.then(function (partValue) {\n          try {\n            var previousReference = writtenObjects.get(partValue);\n            var partJSON$27 =\n              void 0 !== previousReference\n                ? JSON.stringify(previousReference)\n                : serializeModel(partValue, promiseId);\n            partValue = formData;\n            partValue.append(formFieldPrefix + promiseId, partJSON$27);\n            pendingParts--;\n            0 === pendingParts && resolve(partValue);\n          } catch (reason) {\n            reject(reason);\n          }\n        }, reject);\n        return key;\n      }\n      if (void 0 !== parentReference)\n        if (modelRoot === value) modelRoot = null;\n        else return parentReference;\n      else\n        -1 === key.indexOf(\":\") &&\n          ((parentReference = writtenObjects.get(this)),\n          void 0 !== parentReference &&\n            ((key = parentReference + \":\" + key),\n            writtenObjects.set(value, key),\n            void 0 !== temporaryReferences &&\n              temporaryReferences.set(key, value)));\n      if (isArrayImpl(value)) return value;\n      if (value instanceof FormData) {\n        null === formData && (formData = new FormData());\n        var data$31 = formData;\n        key = nextPartId++;\n        var prefix = formFieldPrefix + key + \"_\";\n        value.forEach(function (originalValue, originalKey) {\n          data$31.append(prefix + originalKey, originalValue);\n        });\n        return \"$K\" + key.toString(16);\n      }\n      if (value instanceof Map)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$Q\" + key.toString(16)\n        );\n      if (value instanceof Set)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$W\" + key.toString(16)\n        );\n      if (value instanceof ArrayBuffer)\n        return (\n          (key = new Blob([value])),\n          (parentReference = nextPartId++),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + parentReference, key),\n          \"$A\" + parentReference.toString(16)\n        );\n      if (value instanceof Int8Array) return serializeTypedArray(\"O\", value);\n      if (value instanceof Uint8Array) return serializeTypedArray(\"o\", value);\n      if (value instanceof Uint8ClampedArray)\n        return serializeTypedArray(\"U\", value);\n      if (value instanceof Int16Array) return serializeTypedArray(\"S\", value);\n      if (value instanceof Uint16Array) return serializeTypedArray(\"s\", value);\n      if (value instanceof Int32Array) return serializeTypedArray(\"L\", value);\n      if (value instanceof Uint32Array) return serializeTypedArray(\"l\", value);\n      if (value instanceof Float32Array) return serializeTypedArray(\"G\", value);\n      if (value instanceof Float64Array) return serializeTypedArray(\"g\", value);\n      if (value instanceof BigInt64Array)\n        return serializeTypedArray(\"M\", value);\n      if (value instanceof BigUint64Array)\n        return serializeTypedArray(\"m\", value);\n      if (value instanceof DataView) return serializeTypedArray(\"V\", value);\n      if (\"function\" === typeof Blob && value instanceof Blob)\n        return (\n          null === formData && (formData = new FormData()),\n          (key = nextPartId++),\n          formData.append(formFieldPrefix + key, value),\n          \"$B\" + key.toString(16)\n        );\n      if ((key = getIteratorFn(value)))\n        return (\n          (parentReference = key.call(value)),\n          parentReference === value\n            ? ((key = nextPartId++),\n              (parentReference = serializeModel(\n                Array.from(parentReference),\n                key\n              )),\n              null === formData && (formData = new FormData()),\n              formData.append(formFieldPrefix + key, parentReference),\n              \"$i\" + key.toString(16))\n            : Array.from(parentReference)\n        );\n      if (\n        \"function\" === typeof ReadableStream &&\n        value instanceof ReadableStream\n      )\n        return serializeReadableStream(value);\n      key = value[ASYNC_ITERATOR];\n      if (\"function\" === typeof key)\n        return serializeAsyncIterable(value, key.call(value));\n      key = getPrototypeOf(value);\n      if (\n        key !== ObjectPrototype &&\n        (null === key || null !== getPrototypeOf(key))\n      ) {\n        if (void 0 === temporaryReferences)\n          throw Error(\n            \"Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.\"\n          );\n        return \"$T\";\n      }\n      return value;\n    }\n    if (\"string\" === typeof value) {\n      if (\"Z\" === value[value.length - 1] && this[key] instanceof Date)\n        return \"$D\" + value;\n      key = \"$\" === value[0] ? \"$\" + value : value;\n      return key;\n    }\n    if (\"boolean\" === typeof value) return value;\n    if (\"number\" === typeof value) return serializeNumber(value);\n    if (\"undefined\" === typeof value) return \"$undefined\";\n    if (\"function\" === typeof value) {\n      parentReference = knownServerReferences.get(value);\n      if (void 0 !== parentReference) {\n        key = writtenObjects.get(value);\n        if (void 0 !== key) return key;\n        key = JSON.stringify(\n          { id: parentReference.id, bound: parentReference.bound },\n          resolveToJSON\n        );\n        null === formData && (formData = new FormData());\n        parentReference = nextPartId++;\n        formData.set(formFieldPrefix + parentReference, key);\n        key = \"$h\" + parentReference.toString(16);\n        writtenObjects.set(value, key);\n        return key;\n      }\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.\"\n      );\n    }\n    if (\"symbol\" === typeof value) {\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n      );\n    }\n    if (\"bigint\" === typeof value) return \"$n\" + value.toString(10);\n    throw Error(\n      \"Type \" +\n        typeof value +\n        \" is not supported as an argument to a Server Function.\"\n    );\n  }\n  function serializeModel(model, id) {\n    \"object\" === typeof model &&\n      null !== model &&\n      ((id = \"$\" + id.toString(16)),\n      writtenObjects.set(model, id),\n      void 0 !== temporaryReferences && temporaryReferences.set(id, model));\n    modelRoot = model;\n    return JSON.stringify(model, resolveToJSON);\n  }\n  var nextPartId = 1,\n    pendingParts = 0,\n    formData = null,\n    writtenObjects = new WeakMap(),\n    modelRoot = root,\n    json = serializeModel(root, 0);\n  null === formData\n    ? resolve(json)\n    : (formData.set(formFieldPrefix + \"0\", json),\n      0 === pendingParts && resolve(formData));\n  return function () {\n    0 < pendingParts &&\n      ((pendingParts = 0),\n      null === formData ? resolve(json) : resolve(formData));\n  };\n}\nvar boundCache = new WeakMap();\nfunction encodeFormData(reference) {\n  var resolve,\n    reject,\n    thenable = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n  processReply(\n    reference,\n    \"\",\n    void 0,\n    function (body) {\n      if (\"string\" === typeof body) {\n        var data = new FormData();\n        data.append(\"0\", body);\n        body = data;\n      }\n      thenable.status = \"fulfilled\";\n      thenable.value = body;\n      resolve(body);\n    },\n    function (e) {\n      thenable.status = \"rejected\";\n      thenable.reason = e;\n      reject(e);\n    }\n  );\n  return thenable;\n}\nfunction defaultEncodeFormAction(identifierPrefix) {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure)\n    throw Error(\n      \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n    );\n  var data = null;\n  if (null !== referenceClosure.bound) {\n    data = boundCache.get(referenceClosure);\n    data ||\n      ((data = encodeFormData({\n        id: referenceClosure.id,\n        bound: referenceClosure.bound\n      })),\n      boundCache.set(referenceClosure, data));\n    if (\"rejected\" === data.status) throw data.reason;\n    if (\"fulfilled\" !== data.status) throw data;\n    referenceClosure = data.value;\n    var prefixedData = new FormData();\n    referenceClosure.forEach(function (value, key) {\n      prefixedData.append(\"$ACTION_\" + identifierPrefix + \":\" + key, value);\n    });\n    data = prefixedData;\n    referenceClosure = \"$ACTION_REF_\" + identifierPrefix;\n  } else referenceClosure = \"$ACTION_ID_\" + referenceClosure.id;\n  return {\n    name: referenceClosure,\n    method: \"POST\",\n    encType: \"multipart/form-data\",\n    data: data\n  };\n}\nfunction isSignatureEqual(referenceId, numberOfBoundArgs) {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure)\n    throw Error(\n      \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n    );\n  if (referenceClosure.id !== referenceId) return !1;\n  var boundPromise = referenceClosure.bound;\n  if (null === boundPromise) return 0 === numberOfBoundArgs;\n  switch (boundPromise.status) {\n    case \"fulfilled\":\n      return boundPromise.value.length === numberOfBoundArgs;\n    case \"pending\":\n      throw boundPromise;\n    case \"rejected\":\n      throw boundPromise.reason;\n    default:\n      throw (\n        (\"string\" !== typeof boundPromise.status &&\n          ((boundPromise.status = \"pending\"),\n          boundPromise.then(\n            function (boundArgs) {\n              boundPromise.status = \"fulfilled\";\n              boundPromise.value = boundArgs;\n            },\n            function (error) {\n              boundPromise.status = \"rejected\";\n              boundPromise.reason = error;\n            }\n          )),\n        boundPromise)\n      );\n  }\n}\nfunction registerBoundServerReference(reference, id, bound, encodeFormAction) {\n  knownServerReferences.has(reference) ||\n    (knownServerReferences.set(reference, {\n      id: id,\n      originalBind: reference.bind,\n      bound: bound\n    }),\n    Object.defineProperties(reference, {\n      $$FORM_ACTION: {\n        value:\n          void 0 === encodeFormAction\n            ? defaultEncodeFormAction\n            : function () {\n                var referenceClosure = knownServerReferences.get(this);\n                if (!referenceClosure)\n                  throw Error(\n                    \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n                  );\n                var boundPromise = referenceClosure.bound;\n                null === boundPromise && (boundPromise = Promise.resolve([]));\n                return encodeFormAction(referenceClosure.id, boundPromise);\n              }\n      },\n      $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },\n      bind: { value: bind }\n    }));\n}\nvar FunctionBind = Function.prototype.bind,\n  ArraySlice = Array.prototype.slice;\nfunction bind() {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure) return FunctionBind.apply(this, arguments);\n  var newFn = referenceClosure.originalBind.apply(this, arguments),\n    args = ArraySlice.call(arguments, 1),\n    boundPromise = null;\n  boundPromise =\n    null !== referenceClosure.bound\n      ? Promise.resolve(referenceClosure.bound).then(function (boundArgs) {\n          return boundArgs.concat(args);\n        })\n      : Promise.resolve(args);\n  knownServerReferences.set(newFn, {\n    id: referenceClosure.id,\n    originalBind: newFn.bind,\n    bound: boundPromise\n  });\n  Object.defineProperties(newFn, {\n    $$FORM_ACTION: { value: this.$$FORM_ACTION },\n    $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },\n    bind: { value: bind }\n  });\n  return newFn;\n}\nfunction createBoundServerReference(metaData, callServer, encodeFormAction) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return bound\n      ? \"fulfilled\" === bound.status\n        ? callServer(id, bound.value.concat(args))\n        : Promise.resolve(bound).then(function (boundArgs) {\n            return callServer(id, boundArgs.concat(args));\n          })\n      : callServer(id, args);\n  }\n  var id = metaData.id,\n    bound = metaData.bound;\n  registerBoundServerReference(action, id, bound, encodeFormAction);\n  return action;\n}\nfunction createServerReference$1(id, callServer, encodeFormAction) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return callServer(id, args);\n  }\n  registerBoundServerReference(action, id, null, encodeFormAction);\n  return action;\n}\nfunction ReactPromise(status, value, reason) {\n  this.status = status;\n  this.value = value;\n  this.reason = reason;\n}\nReactPromise.prototype = Object.create(Promise.prototype);\nReactPromise.prototype.then = function (resolve, reject) {\n  switch (this.status) {\n    case \"resolved_model\":\n      initializeModelChunk(this);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(this);\n  }\n  switch (this.status) {\n    case \"fulfilled\":\n      \"function\" === typeof resolve && resolve(this.value);\n      break;\n    case \"pending\":\n    case \"blocked\":\n      \"function\" === typeof resolve &&\n        (null === this.value && (this.value = []), this.value.push(resolve));\n      \"function\" === typeof reject &&\n        (null === this.reason && (this.reason = []), this.reason.push(reject));\n      break;\n    case \"halted\":\n      break;\n    default:\n      \"function\" === typeof reject && reject(this.reason);\n  }\n};\nfunction readChunk(chunk) {\n  switch (chunk.status) {\n    case \"resolved_model\":\n      initializeModelChunk(chunk);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(chunk);\n  }\n  switch (chunk.status) {\n    case \"fulfilled\":\n      return chunk.value;\n    case \"pending\":\n    case \"blocked\":\n    case \"halted\":\n      throw chunk;\n    default:\n      throw chunk.reason;\n  }\n}\nfunction wakeChunk(response, listeners, value, chunk) {\n  for (var i = 0; i < listeners.length; i++) {\n    var listener = listeners[i];\n    \"function\" === typeof listener\n      ? listener(value)\n      : fulfillReference(response, listener, value, chunk);\n  }\n}\nfunction rejectChunk(response, listeners, error) {\n  for (var i = 0; i < listeners.length; i++) {\n    var listener = listeners[i];\n    \"function\" === typeof listener\n      ? listener(error)\n      : rejectReference(response, listener.handler, error);\n  }\n}\nfunction resolveBlockedCycle(resolvedChunk, reference) {\n  var referencedChunk = reference.handler.chunk;\n  if (null === referencedChunk) return null;\n  if (referencedChunk === resolvedChunk) return reference.handler;\n  reference = referencedChunk.value;\n  if (null !== reference)\n    for (\n      referencedChunk = 0;\n      referencedChunk < reference.length;\n      referencedChunk++\n    ) {\n      var listener = reference[referencedChunk];\n      if (\n        \"function\" !== typeof listener &&\n        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n        null !== listener)\n      )\n        return listener;\n    }\n  return null;\n}\nfunction wakeChunkIfInitialized(\n  response,\n  chunk,\n  resolveListeners,\n  rejectListeners\n) {\n  switch (chunk.status) {\n    case \"fulfilled\":\n      wakeChunk(response, resolveListeners, chunk.value, chunk);\n      break;\n    case \"blocked\":\n      for (var i = 0; i < resolveListeners.length; i++) {\n        var listener = resolveListeners[i];\n        if (\"function\" !== typeof listener) {\n          var cyclicHandler = resolveBlockedCycle(chunk, listener);\n          if (null !== cyclicHandler)\n            switch (\n              (fulfillReference(response, listener, cyclicHandler.value, chunk),\n              resolveListeners.splice(i, 1),\n              i--,\n              null !== rejectListeners &&\n                ((listener = rejectListeners.indexOf(listener)),\n                -1 !== listener && rejectListeners.splice(listener, 1)),\n              chunk.status)\n            ) {\n              case \"fulfilled\":\n                wakeChunk(response, resolveListeners, chunk.value, chunk);\n                return;\n              case \"rejected\":\n                null !== rejectListeners &&\n                  rejectChunk(response, rejectListeners, chunk.reason);\n                return;\n            }\n        }\n      }\n    case \"pending\":\n      if (chunk.value)\n        for (response = 0; response < resolveListeners.length; response++)\n          chunk.value.push(resolveListeners[response]);\n      else chunk.value = resolveListeners;\n      if (chunk.reason) {\n        if (rejectListeners)\n          for (\n            resolveListeners = 0;\n            resolveListeners < rejectListeners.length;\n            resolveListeners++\n          )\n            chunk.reason.push(rejectListeners[resolveListeners]);\n      } else chunk.reason = rejectListeners;\n      break;\n    case \"rejected\":\n      rejectListeners && rejectChunk(response, rejectListeners, chunk.reason);\n  }\n}\nfunction triggerErrorOnChunk(response, chunk, error) {\n  if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n    chunk.reason.error(error);\n  else {\n    var listeners = chunk.reason;\n    chunk.status = \"rejected\";\n    chunk.reason = error;\n    null !== listeners && rejectChunk(response, listeners, error);\n  }\n}\nfunction createResolvedIteratorResultChunk(response, value, done) {\n  return new ReactPromise(\n    \"resolved_model\",\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n    response\n  );\n}\nfunction resolveIteratorResultChunk(response, chunk, value, done) {\n  resolveModelChunk(\n    response,\n    chunk,\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\"\n  );\n}\nfunction resolveModelChunk(response, chunk, value) {\n  if (\"pending\" !== chunk.status) chunk.reason.enqueueModel(value);\n  else {\n    var resolveListeners = chunk.value,\n      rejectListeners = chunk.reason;\n    chunk.status = \"resolved_model\";\n    chunk.value = value;\n    chunk.reason = response;\n    null !== resolveListeners &&\n      (initializeModelChunk(chunk),\n      wakeChunkIfInitialized(\n        response,\n        chunk,\n        resolveListeners,\n        rejectListeners\n      ));\n  }\n}\nfunction resolveModuleChunk(response, chunk, value) {\n  if (\"pending\" === chunk.status || \"blocked\" === chunk.status) {\n    var resolveListeners = chunk.value,\n      rejectListeners = chunk.reason;\n    chunk.status = \"resolved_module\";\n    chunk.value = value;\n    chunk.reason = null;\n    null !== resolveListeners &&\n      (initializeModuleChunk(chunk),\n      wakeChunkIfInitialized(\n        response,\n        chunk,\n        resolveListeners,\n        rejectListeners\n      ));\n  }\n}\nvar initializingHandler = null;\nfunction initializeModelChunk(chunk) {\n  var prevHandler = initializingHandler;\n  initializingHandler = null;\n  var resolvedModel = chunk.value,\n    response = chunk.reason;\n  chunk.status = \"blocked\";\n  chunk.value = null;\n  chunk.reason = null;\n  try {\n    var value = JSON.parse(resolvedModel, response._fromJSON),\n      resolveListeners = chunk.value;\n    if (null !== resolveListeners)\n      for (\n        chunk.value = null, chunk.reason = null, resolvedModel = 0;\n        resolvedModel < resolveListeners.length;\n        resolvedModel++\n      ) {\n        var listener = resolveListeners[resolvedModel];\n        \"function\" === typeof listener\n          ? listener(value)\n          : fulfillReference(response, listener, value, chunk);\n      }\n    if (null !== initializingHandler) {\n      if (initializingHandler.errored) throw initializingHandler.reason;\n      if (0 < initializingHandler.deps) {\n        initializingHandler.value = value;\n        initializingHandler.chunk = chunk;\n        return;\n      }\n    }\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  } finally {\n    initializingHandler = prevHandler;\n  }\n}\nfunction initializeModuleChunk(chunk) {\n  try {\n    var value = requireModule(chunk.value);\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  }\n}\nfunction reportGlobalError(weakResponse, error) {\n  weakResponse._closed = !0;\n  weakResponse._closedReason = error;\n  weakResponse._chunks.forEach(function (chunk) {\n    \"pending\" === chunk.status\n      ? triggerErrorOnChunk(weakResponse, chunk, error)\n      : \"fulfilled\" === chunk.status &&\n        null !== chunk.reason &&\n        chunk.reason.error(error);\n  });\n}\nfunction createLazyChunkWrapper(chunk) {\n  return { $$typeof: REACT_LAZY_TYPE, _payload: chunk, _init: readChunk };\n}\nfunction getChunk(response, id) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk ||\n    ((chunk = response._closed\n      ? new ReactPromise(\"rejected\", null, response._closedReason)\n      : new ReactPromise(\"pending\", null, null)),\n    chunks.set(id, chunk));\n  return chunk;\n}\nfunction fulfillReference(response, reference, value) {\n  var handler = reference.handler,\n    parentObject = reference.parentObject,\n    key = reference.key,\n    map = reference.map,\n    path = reference.path;\n  try {\n    for (var i = 1; i < path.length; i++) {\n      for (\n        ;\n        \"object\" === typeof value &&\n        null !== value &&\n        value.$$typeof === REACT_LAZY_TYPE;\n\n      ) {\n        var referencedChunk = value._payload;\n        if (referencedChunk === handler.chunk) value = handler.value;\n        else {\n          switch (referencedChunk.status) {\n            case \"resolved_model\":\n              initializeModelChunk(referencedChunk);\n              break;\n            case \"resolved_module\":\n              initializeModuleChunk(referencedChunk);\n          }\n          switch (referencedChunk.status) {\n            case \"fulfilled\":\n              value = referencedChunk.value;\n              continue;\n            case \"blocked\":\n              var cyclicHandler = resolveBlockedCycle(\n                referencedChunk,\n                reference\n              );\n              if (null !== cyclicHandler) {\n                value = cyclicHandler.value;\n                continue;\n              }\n            case \"pending\":\n              path.splice(0, i - 1);\n              null === referencedChunk.value\n                ? (referencedChunk.value = [reference])\n                : referencedChunk.value.push(reference);\n              null === referencedChunk.reason\n                ? (referencedChunk.reason = [reference])\n                : referencedChunk.reason.push(reference);\n              return;\n            case \"halted\":\n              return;\n            default:\n              rejectReference(\n                response,\n                reference.handler,\n                referencedChunk.reason\n              );\n              return;\n          }\n        }\n      }\n      var name = path[i];\n      if (\n        \"object\" === typeof value &&\n        null !== value &&\n        hasOwnProperty.call(value, name)\n      )\n        value = value[name];\n      else throw Error(\"Invalid reference.\");\n    }\n    for (\n      ;\n      \"object\" === typeof value &&\n      null !== value &&\n      value.$$typeof === REACT_LAZY_TYPE;\n\n    ) {\n      var referencedChunk$44 = value._payload;\n      if (referencedChunk$44 === handler.chunk) value = handler.value;\n      else {\n        switch (referencedChunk$44.status) {\n          case \"resolved_model\":\n            initializeModelChunk(referencedChunk$44);\n            break;\n          case \"resolved_module\":\n            initializeModuleChunk(referencedChunk$44);\n        }\n        switch (referencedChunk$44.status) {\n          case \"fulfilled\":\n            value = referencedChunk$44.value;\n            continue;\n        }\n        break;\n      }\n    }\n    var mappedValue = map(response, value, parentObject, key);\n    \"__proto__\" !== key && (parentObject[key] = mappedValue);\n    \"\" === key && null === handler.value && (handler.value = mappedValue);\n    if (\n      parentObject[0] === REACT_ELEMENT_TYPE &&\n      \"object\" === typeof handler.value &&\n      null !== handler.value &&\n      handler.value.$$typeof === REACT_ELEMENT_TYPE\n    ) {\n      var element = handler.value;\n      switch (key) {\n        case \"3\":\n          element.props = mappedValue;\n      }\n    }\n  } catch (error) {\n    rejectReference(response, reference.handler, error);\n    return;\n  }\n  handler.deps--;\n  0 === handler.deps &&\n    ((reference = handler.chunk),\n    null !== reference &&\n      \"blocked\" === reference.status &&\n      ((value = reference.value),\n      (reference.status = \"fulfilled\"),\n      (reference.value = handler.value),\n      (reference.reason = handler.reason),\n      null !== value && wakeChunk(response, value, handler.value, reference)));\n}\nfunction rejectReference(response, handler, error) {\n  handler.errored ||\n    ((handler.errored = !0),\n    (handler.value = null),\n    (handler.reason = error),\n    (handler = handler.chunk),\n    null !== handler &&\n      \"blocked\" === handler.status &&\n      triggerErrorOnChunk(response, handler, error));\n}\nfunction waitForReference(\n  referencedChunk,\n  parentObject,\n  key,\n  response,\n  map,\n  path\n) {\n  initializingHandler\n    ? ((response = initializingHandler), response.deps++)\n    : (response = initializingHandler =\n        {\n          parent: null,\n          chunk: null,\n          value: null,\n          reason: null,\n          deps: 1,\n          errored: !1\n        });\n  parentObject = {\n    handler: response,\n    parentObject: parentObject,\n    key: key,\n    map: map,\n    path: path\n  };\n  null === referencedChunk.value\n    ? (referencedChunk.value = [parentObject])\n    : referencedChunk.value.push(parentObject);\n  null === referencedChunk.reason\n    ? (referencedChunk.reason = [parentObject])\n    : referencedChunk.reason.push(parentObject);\n  return null;\n}\nfunction loadServerReference(response, metaData, parentObject, key) {\n  if (!response._serverReferenceConfig)\n    return createBoundServerReference(\n      metaData,\n      response._callServer,\n      response._encodeFormAction\n    );\n  var serverReference = resolveServerReference(\n      response._serverReferenceConfig,\n      metaData.id\n    ),\n    promise = preloadModule(serverReference);\n  if (promise)\n    metaData.bound && (promise = Promise.all([promise, metaData.bound]));\n  else if (metaData.bound) promise = Promise.resolve(metaData.bound);\n  else\n    return (\n      (promise = requireModule(serverReference)),\n      registerBoundServerReference(\n        promise,\n        metaData.id,\n        metaData.bound,\n        response._encodeFormAction\n      ),\n      promise\n    );\n  if (initializingHandler) {\n    var handler = initializingHandler;\n    handler.deps++;\n  } else\n    handler = initializingHandler = {\n      parent: null,\n      chunk: null,\n      value: null,\n      reason: null,\n      deps: 1,\n      errored: !1\n    };\n  promise.then(\n    function () {\n      var resolvedValue = requireModule(serverReference);\n      if (metaData.bound) {\n        var boundArgs = metaData.bound.value.slice(0);\n        boundArgs.unshift(null);\n        resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);\n      }\n      registerBoundServerReference(\n        resolvedValue,\n        metaData.id,\n        metaData.bound,\n        response._encodeFormAction\n      );\n      \"__proto__\" !== key && (parentObject[key] = resolvedValue);\n      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n      if (\n        parentObject[0] === REACT_ELEMENT_TYPE &&\n        \"object\" === typeof handler.value &&\n        null !== handler.value &&\n        handler.value.$$typeof === REACT_ELEMENT_TYPE\n      )\n        switch (((boundArgs = handler.value), key)) {\n          case \"3\":\n            boundArgs.props = resolvedValue;\n        }\n      handler.deps--;\n      0 === handler.deps &&\n        ((resolvedValue = handler.chunk),\n        null !== resolvedValue &&\n          \"blocked\" === resolvedValue.status &&\n          ((boundArgs = resolvedValue.value),\n          (resolvedValue.status = \"fulfilled\"),\n          (resolvedValue.value = handler.value),\n          (resolvedValue.reason = null),\n          null !== boundArgs &&\n            wakeChunk(response, boundArgs, handler.value, resolvedValue)));\n    },\n    function (error) {\n      if (!handler.errored) {\n        handler.errored = !0;\n        handler.value = null;\n        handler.reason = error;\n        var chunk = handler.chunk;\n        null !== chunk &&\n          \"blocked\" === chunk.status &&\n          triggerErrorOnChunk(response, chunk, error);\n      }\n    }\n  );\n  return null;\n}\nfunction getOutlinedModel(response, reference, parentObject, key, map) {\n  reference = reference.split(\":\");\n  var id = parseInt(reference[0], 16);\n  id = getChunk(response, id);\n  switch (id.status) {\n    case \"resolved_model\":\n      initializeModelChunk(id);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(id);\n  }\n  switch (id.status) {\n    case \"fulfilled\":\n      id = id.value;\n      for (var i = 1; i < reference.length; i++) {\n        for (\n          ;\n          \"object\" === typeof id &&\n          null !== id &&\n          id.$$typeof === REACT_LAZY_TYPE;\n\n        ) {\n          id = id._payload;\n          switch (id.status) {\n            case \"resolved_model\":\n              initializeModelChunk(id);\n              break;\n            case \"resolved_module\":\n              initializeModuleChunk(id);\n          }\n          switch (id.status) {\n            case \"fulfilled\":\n              id = id.value;\n              break;\n            case \"blocked\":\n            case \"pending\":\n              return waitForReference(\n                id,\n                parentObject,\n                key,\n                response,\n                map,\n                reference.slice(i - 1)\n              );\n            case \"halted\":\n              return (\n                initializingHandler\n                  ? ((response = initializingHandler), response.deps++)\n                  : (initializingHandler = {\n                      parent: null,\n                      chunk: null,\n                      value: null,\n                      reason: null,\n                      deps: 1,\n                      errored: !1\n                    }),\n                null\n              );\n            default:\n              return (\n                initializingHandler\n                  ? ((initializingHandler.errored = !0),\n                    (initializingHandler.value = null),\n                    (initializingHandler.reason = id.reason))\n                  : (initializingHandler = {\n                      parent: null,\n                      chunk: null,\n                      value: null,\n                      reason: id.reason,\n                      deps: 0,\n                      errored: !0\n                    }),\n                null\n              );\n          }\n        }\n        id = id[reference[i]];\n      }\n      for (\n        ;\n        \"object\" === typeof id &&\n        null !== id &&\n        id.$$typeof === REACT_LAZY_TYPE;\n\n      ) {\n        reference = id._payload;\n        switch (reference.status) {\n          case \"resolved_model\":\n            initializeModelChunk(reference);\n            break;\n          case \"resolved_module\":\n            initializeModuleChunk(reference);\n        }\n        switch (reference.status) {\n          case \"fulfilled\":\n            id = reference.value;\n            continue;\n        }\n        break;\n      }\n      return map(response, id, parentObject, key);\n    case \"pending\":\n    case \"blocked\":\n      return waitForReference(id, parentObject, key, response, map, reference);\n    case \"halted\":\n      return (\n        initializingHandler\n          ? ((response = initializingHandler), response.deps++)\n          : (initializingHandler = {\n              parent: null,\n              chunk: null,\n              value: null,\n              reason: null,\n              deps: 1,\n              errored: !1\n            }),\n        null\n      );\n    default:\n      return (\n        initializingHandler\n          ? ((initializingHandler.errored = !0),\n            (initializingHandler.value = null),\n            (initializingHandler.reason = id.reason))\n          : (initializingHandler = {\n              parent: null,\n              chunk: null,\n              value: null,\n              reason: id.reason,\n              deps: 0,\n              errored: !0\n            }),\n        null\n      );\n  }\n}\nfunction createMap(response, model) {\n  return new Map(model);\n}\nfunction createSet(response, model) {\n  return new Set(model);\n}\nfunction createBlob(response, model) {\n  return new Blob(model.slice(1), { type: model[0] });\n}\nfunction createFormData(response, model) {\n  response = new FormData();\n  for (var i = 0; i < model.length; i++)\n    response.append(model[i][0], model[i][1]);\n  return response;\n}\nfunction extractIterator(response, model) {\n  return model[Symbol.iterator]();\n}\nfunction createModel(response, model) {\n  return model;\n}\nfunction parseModelString(response, parentObject, key, value) {\n  if (\"$\" === value[0]) {\n    if (\"$\" === value)\n      return (\n        null !== initializingHandler &&\n          \"0\" === key &&\n          (initializingHandler = {\n            parent: initializingHandler,\n            chunk: null,\n            value: null,\n            reason: null,\n            deps: 0,\n            errored: !1\n          }),\n        REACT_ELEMENT_TYPE\n      );\n    switch (value[1]) {\n      case \"$\":\n        return value.slice(1);\n      case \"L\":\n        return (\n          (parentObject = parseInt(value.slice(2), 16)),\n          (response = getChunk(response, parentObject)),\n          createLazyChunkWrapper(response)\n        );\n      case \"@\":\n        return (\n          (parentObject = parseInt(value.slice(2), 16)),\n          getChunk(response, parentObject)\n        );\n      case \"S\":\n        return Symbol.for(value.slice(2));\n      case \"h\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(\n            response,\n            value,\n            parentObject,\n            key,\n            loadServerReference\n          )\n        );\n      case \"T\":\n        parentObject = \"$\" + value.slice(2);\n        response = response._tempRefs;\n        if (null == response)\n          throw Error(\n            \"Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.\"\n          );\n        return response.get(parentObject);\n      case \"Q\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createMap)\n        );\n      case \"W\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createSet)\n        );\n      case \"B\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createBlob)\n        );\n      case \"K\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createFormData)\n        );\n      case \"Z\":\n        return resolveErrorProd();\n      case \"i\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, extractIterator)\n        );\n      case \"I\":\n        return Infinity;\n      case \"-\":\n        return \"$-0\" === value ? -0 : -Infinity;\n      case \"N\":\n        return NaN;\n      case \"u\":\n        return;\n      case \"D\":\n        return new Date(Date.parse(value.slice(2)));\n      case \"n\":\n        return BigInt(value.slice(2));\n      default:\n        return (\n          (value = value.slice(1)),\n          getOutlinedModel(response, value, parentObject, key, createModel)\n        );\n    }\n  }\n  return value;\n}\nfunction missingCall() {\n  throw Error(\n    'Trying to call a function from \"use server\" but the callServer option was not implemented in your router runtime.'\n  );\n}\nfunction ResponseInstance(\n  bundlerConfig,\n  serverReferenceConfig,\n  moduleLoading,\n  callServer,\n  encodeFormAction,\n  nonce,\n  temporaryReferences\n) {\n  var chunks = new Map();\n  this._bundlerConfig = bundlerConfig;\n  this._serverReferenceConfig = serverReferenceConfig;\n  this._moduleLoading = moduleLoading;\n  this._callServer = void 0 !== callServer ? callServer : missingCall;\n  this._encodeFormAction = encodeFormAction;\n  this._nonce = nonce;\n  this._chunks = chunks;\n  this._stringDecoder = new TextDecoder();\n  this._fromJSON = null;\n  this._closed = !1;\n  this._closedReason = null;\n  this._tempRefs = temporaryReferences;\n  this._fromJSON = createFromJSONCallback(this);\n}\nfunction resolveBuffer(response, id, buffer) {\n  response = response._chunks;\n  var chunk = response.get(id);\n  chunk && \"pending\" !== chunk.status\n    ? chunk.reason.enqueueValue(buffer)\n    : ((buffer = new ReactPromise(\"fulfilled\", buffer, null)),\n      response.set(id, buffer));\n}\nfunction resolveModule(response, id, model) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  model = JSON.parse(model, response._fromJSON);\n  var clientReference = resolveClientReference(response._bundlerConfig, model);\n  prepareDestinationWithChunks(\n    response._moduleLoading,\n    model[1],\n    response._nonce\n  );\n  if ((model = preloadModule(clientReference))) {\n    if (chunk) {\n      var blockedChunk = chunk;\n      blockedChunk.status = \"blocked\";\n    } else\n      (blockedChunk = new ReactPromise(\"blocked\", null, null)),\n        chunks.set(id, blockedChunk);\n    model.then(\n      function () {\n        return resolveModuleChunk(response, blockedChunk, clientReference);\n      },\n      function (error) {\n        return triggerErrorOnChunk(response, blockedChunk, error);\n      }\n    );\n  } else\n    chunk\n      ? resolveModuleChunk(response, chunk, clientReference)\n      : ((chunk = new ReactPromise(\"resolved_module\", clientReference, null)),\n        chunks.set(id, chunk));\n}\nfunction resolveStream(response, id, stream, controller) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk\n    ? \"pending\" === chunk.status &&\n      ((id = chunk.value),\n      (chunk.status = \"fulfilled\"),\n      (chunk.value = stream),\n      (chunk.reason = controller),\n      null !== id && wakeChunk(response, id, chunk.value, chunk))\n    : ((response = new ReactPromise(\"fulfilled\", stream, controller)),\n      chunks.set(id, response));\n}\nfunction startReadableStream(response, id, type) {\n  var controller = null,\n    closed = !1;\n  type = new ReadableStream({\n    type: type,\n    start: function (c) {\n      controller = c;\n    }\n  });\n  var previousBlockedChunk = null;\n  resolveStream(response, id, type, {\n    enqueueValue: function (value) {\n      null === previousBlockedChunk\n        ? controller.enqueue(value)\n        : previousBlockedChunk.then(function () {\n            controller.enqueue(value);\n          });\n    },\n    enqueueModel: function (json) {\n      if (null === previousBlockedChunk) {\n        var chunk = new ReactPromise(\"resolved_model\", json, response);\n        initializeModelChunk(chunk);\n        \"fulfilled\" === chunk.status\n          ? controller.enqueue(chunk.value)\n          : (chunk.then(\n              function (v) {\n                return controller.enqueue(v);\n              },\n              function (e) {\n                return controller.error(e);\n              }\n            ),\n            (previousBlockedChunk = chunk));\n      } else {\n        chunk = previousBlockedChunk;\n        var chunk$55 = new ReactPromise(\"pending\", null, null);\n        chunk$55.then(\n          function (v) {\n            return controller.enqueue(v);\n          },\n          function (e) {\n            return controller.error(e);\n          }\n        );\n        previousBlockedChunk = chunk$55;\n        chunk.then(function () {\n          previousBlockedChunk === chunk$55 && (previousBlockedChunk = null);\n          resolveModelChunk(response, chunk$55, json);\n        });\n      }\n    },\n    close: function () {\n      if (!closed)\n        if (((closed = !0), null === previousBlockedChunk)) controller.close();\n        else {\n          var blockedChunk = previousBlockedChunk;\n          previousBlockedChunk = null;\n          blockedChunk.then(function () {\n            return controller.close();\n          });\n        }\n    },\n    error: function (error) {\n      if (!closed)\n        if (((closed = !0), null === previousBlockedChunk))\n          controller.error(error);\n        else {\n          var blockedChunk = previousBlockedChunk;\n          previousBlockedChunk = null;\n          blockedChunk.then(function () {\n            return controller.error(error);\n          });\n        }\n    }\n  });\n}\nfunction asyncIterator() {\n  return this;\n}\nfunction createIterator(next) {\n  next = { next: next };\n  next[ASYNC_ITERATOR] = asyncIterator;\n  return next;\n}\nfunction startAsyncIterable(response, id, iterator) {\n  var buffer = [],\n    closed = !1,\n    nextWriteIndex = 0,\n    iterable = {};\n  iterable[ASYNC_ITERATOR] = function () {\n    var nextReadIndex = 0;\n    return createIterator(function (arg) {\n      if (void 0 !== arg)\n        throw Error(\n          \"Values cannot be passed to next() of AsyncIterables passed to Client Components.\"\n        );\n      if (nextReadIndex === buffer.length) {\n        if (closed)\n          return new ReactPromise(\n            \"fulfilled\",\n            { done: !0, value: void 0 },\n            null\n          );\n        buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n      }\n      return buffer[nextReadIndex++];\n    });\n  };\n  resolveStream(\n    response,\n    id,\n    iterator ? iterable[ASYNC_ITERATOR]() : iterable,\n    {\n      enqueueValue: function (value) {\n        if (nextWriteIndex === buffer.length)\n          buffer[nextWriteIndex] = new ReactPromise(\n            \"fulfilled\",\n            { done: !1, value: value },\n            null\n          );\n        else {\n          var chunk = buffer[nextWriteIndex],\n            resolveListeners = chunk.value,\n            rejectListeners = chunk.reason;\n          chunk.status = \"fulfilled\";\n          chunk.value = { done: !1, value: value };\n          chunk.reason = null;\n          null !== resolveListeners &&\n            wakeChunkIfInitialized(\n              response,\n              chunk,\n              resolveListeners,\n              rejectListeners\n            );\n        }\n        nextWriteIndex++;\n      },\n      enqueueModel: function (value) {\n        nextWriteIndex === buffer.length\n          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n              response,\n              value,\n              !1\n            ))\n          : resolveIteratorResultChunk(\n              response,\n              buffer[nextWriteIndex],\n              value,\n              !1\n            );\n        nextWriteIndex++;\n      },\n      close: function (value) {\n        if (!closed)\n          for (\n            closed = !0,\n              nextWriteIndex === buffer.length\n                ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n                    response,\n                    value,\n                    !0\n                  ))\n                : resolveIteratorResultChunk(\n                    response,\n                    buffer[nextWriteIndex],\n                    value,\n                    !0\n                  ),\n              nextWriteIndex++;\n            nextWriteIndex < buffer.length;\n\n          )\n            resolveIteratorResultChunk(\n              response,\n              buffer[nextWriteIndex++],\n              '\"$undefined\"',\n              !0\n            );\n      },\n      error: function (error) {\n        if (!closed)\n          for (\n            closed = !0,\n              nextWriteIndex === buffer.length &&\n                (buffer[nextWriteIndex] = new ReactPromise(\n                  \"pending\",\n                  null,\n                  null\n                ));\n            nextWriteIndex < buffer.length;\n\n          )\n            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n      }\n    }\n  );\n}\nfunction resolveErrorProd() {\n  var error = Error(\n    \"An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.\"\n  );\n  error.stack = \"Error: \" + error.message;\n  return error;\n}\nfunction mergeBuffer(buffer, lastChunk) {\n  for (var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)\n    byteLength += buffer[i].byteLength;\n  byteLength = new Uint8Array(byteLength);\n  for (var i$56 = (i = 0); i$56 < l; i$56++) {\n    var chunk = buffer[i$56];\n    byteLength.set(chunk, i);\n    i += chunk.byteLength;\n  }\n  byteLength.set(lastChunk, i);\n  return byteLength;\n}\nfunction resolveTypedArray(\n  response,\n  id,\n  buffer,\n  lastChunk,\n  constructor,\n  bytesPerElement\n) {\n  buffer =\n    0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement\n      ? lastChunk\n      : mergeBuffer(buffer, lastChunk);\n  constructor = new constructor(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength / bytesPerElement\n  );\n  resolveBuffer(response, id, constructor);\n}\nfunction processFullBinaryRow(response, streamState, id, tag, buffer, chunk) {\n  switch (tag) {\n    case 65:\n      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);\n      return;\n    case 79:\n      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);\n      return;\n    case 111:\n      resolveBuffer(\n        response,\n        id,\n        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)\n      );\n      return;\n    case 85:\n      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);\n      return;\n    case 83:\n      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);\n      return;\n    case 115:\n      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);\n      return;\n    case 76:\n      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);\n      return;\n    case 108:\n      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);\n      return;\n    case 71:\n      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);\n      return;\n    case 103:\n      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);\n      return;\n    case 77:\n      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);\n      return;\n    case 109:\n      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);\n      return;\n    case 86:\n      resolveTypedArray(response, id, buffer, chunk, DataView, 1);\n      return;\n  }\n  streamState = response._stringDecoder;\n  for (var row = \"\", i = 0; i < buffer.length; i++)\n    row += streamState.decode(buffer[i], decoderOptions);\n  buffer = row += streamState.decode(chunk);\n  switch (tag) {\n    case 73:\n      resolveModule(response, id, buffer);\n      break;\n    case 72:\n      id = buffer[0];\n      buffer = buffer.slice(1);\n      response = JSON.parse(buffer, response._fromJSON);\n      buffer = ReactDOMSharedInternals.d;\n      switch (id) {\n        case \"D\":\n          buffer.D(response);\n          break;\n        case \"C\":\n          \"string\" === typeof response\n            ? buffer.C(response)\n            : buffer.C(response[0], response[1]);\n          break;\n        case \"L\":\n          id = response[0];\n          tag = response[1];\n          3 === response.length\n            ? buffer.L(id, tag, response[2])\n            : buffer.L(id, tag);\n          break;\n        case \"m\":\n          \"string\" === typeof response\n            ? buffer.m(response)\n            : buffer.m(response[0], response[1]);\n          break;\n        case \"X\":\n          \"string\" === typeof response\n            ? buffer.X(response)\n            : buffer.X(response[0], response[1]);\n          break;\n        case \"S\":\n          \"string\" === typeof response\n            ? buffer.S(response)\n            : buffer.S(\n                response[0],\n                0 === response[1] ? void 0 : response[1],\n                3 === response.length ? response[2] : void 0\n              );\n          break;\n        case \"M\":\n          \"string\" === typeof response\n            ? buffer.M(response)\n            : buffer.M(response[0], response[1]);\n      }\n      break;\n    case 69:\n      tag = response._chunks;\n      chunk = tag.get(id);\n      buffer = JSON.parse(buffer);\n      streamState = resolveErrorProd();\n      streamState.digest = buffer.digest;\n      chunk\n        ? triggerErrorOnChunk(response, chunk, streamState)\n        : ((response = new ReactPromise(\"rejected\", null, streamState)),\n          tag.set(id, response));\n      break;\n    case 84:\n      response = response._chunks;\n      (tag = response.get(id)) && \"pending\" !== tag.status\n        ? tag.reason.enqueueValue(buffer)\n        : ((buffer = new ReactPromise(\"fulfilled\", buffer, null)),\n          response.set(id, buffer));\n      break;\n    case 78:\n    case 68:\n    case 74:\n    case 87:\n      throw Error(\n        \"Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.\"\n      );\n    case 82:\n      startReadableStream(response, id, void 0);\n      break;\n    case 114:\n      startReadableStream(response, id, \"bytes\");\n      break;\n    case 88:\n      startAsyncIterable(response, id, !1);\n      break;\n    case 120:\n      startAsyncIterable(response, id, !0);\n      break;\n    case 67:\n      (id = response._chunks.get(id)) &&\n        \"fulfilled\" === id.status &&\n        id.reason.close(\"\" === buffer ? '\"$undefined\"' : buffer);\n      break;\n    default:\n      (tag = response._chunks),\n        (chunk = tag.get(id))\n          ? resolveModelChunk(response, chunk, buffer)\n          : ((response = new ReactPromise(\"resolved_model\", buffer, response)),\n            tag.set(id, response));\n  }\n}\nfunction createFromJSONCallback(response) {\n  return function (key, value) {\n    if (\"__proto__\" !== key) {\n      if (\"string\" === typeof value)\n        return parseModelString(response, this, key, value);\n      if (\"object\" === typeof value && null !== value) {\n        if (value[0] === REACT_ELEMENT_TYPE) {\n          if (\n            ((key = {\n              $$typeof: REACT_ELEMENT_TYPE,\n              type: value[1],\n              key: value[2],\n              ref: null,\n              props: value[3]\n            }),\n            null !== initializingHandler)\n          )\n            if (\n              ((value = initializingHandler),\n              (initializingHandler = value.parent),\n              value.errored)\n            )\n              (key = new ReactPromise(\"rejected\", null, value.reason)),\n                (key = createLazyChunkWrapper(key));\n            else if (0 < value.deps) {\n              var blockedChunk = new ReactPromise(\"blocked\", null, null);\n              value.value = key;\n              value.chunk = blockedChunk;\n              key = createLazyChunkWrapper(blockedChunk);\n            }\n        } else key = value;\n        return key;\n      }\n      return value;\n    }\n  };\n}\nfunction close(weakResponse) {\n  reportGlobalError(weakResponse, Error(\"Connection closed.\"));\n}\nfunction noServerCall() {\n  throw Error(\n    \"Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.\"\n  );\n}\nfunction createResponseFromOptions(options) {\n  return new ResponseInstance(\n    options.serverConsumerManifest.moduleMap,\n    options.serverConsumerManifest.serverModuleMap,\n    options.serverConsumerManifest.moduleLoading,\n    noServerCall,\n    options.encodeFormAction,\n    \"string\" === typeof options.nonce ? options.nonce : void 0,\n    options && options.temporaryReferences\n      ? options.temporaryReferences\n      : void 0\n  );\n}\nfunction startReadingFromStream(response, stream, onDone) {\n  function progress(_ref) {\n    var value = _ref.value;\n    if (_ref.done) return onDone();\n    var i = 0,\n      rowState = streamState._rowState;\n    _ref = streamState._rowID;\n    for (\n      var rowTag = streamState._rowTag,\n        rowLength = streamState._rowLength,\n        buffer = streamState._buffer,\n        chunkLength = value.length;\n      i < chunkLength;\n\n    ) {\n      var lastIdx = -1;\n      switch (rowState) {\n        case 0:\n          lastIdx = value[i++];\n          58 === lastIdx\n            ? (rowState = 1)\n            : (_ref =\n                (_ref << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n          continue;\n        case 1:\n          rowState = value[i];\n          84 === rowState ||\n          65 === rowState ||\n          79 === rowState ||\n          111 === rowState ||\n          98 === rowState ||\n          85 === rowState ||\n          83 === rowState ||\n          115 === rowState ||\n          76 === rowState ||\n          108 === rowState ||\n          71 === rowState ||\n          103 === rowState ||\n          77 === rowState ||\n          109 === rowState ||\n          86 === rowState\n            ? ((rowTag = rowState), (rowState = 2), i++)\n            : (64 < rowState && 91 > rowState) ||\n                35 === rowState ||\n                114 === rowState ||\n                120 === rowState\n              ? ((rowTag = rowState), (rowState = 3), i++)\n              : ((rowTag = 0), (rowState = 3));\n          continue;\n        case 2:\n          lastIdx = value[i++];\n          44 === lastIdx\n            ? (rowState = 4)\n            : (rowLength =\n                (rowLength << 4) |\n                (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n          continue;\n        case 3:\n          lastIdx = value.indexOf(10, i);\n          break;\n        case 4:\n          (lastIdx = i + rowLength), lastIdx > value.length && (lastIdx = -1);\n      }\n      var offset = value.byteOffset + i;\n      if (-1 < lastIdx)\n        (rowLength = new Uint8Array(value.buffer, offset, lastIdx - i)),\n          98 === rowTag\n            ? resolveBuffer(\n                response,\n                _ref,\n                lastIdx === chunkLength ? rowLength : rowLength.slice()\n              )\n            : processFullBinaryRow(\n                response,\n                streamState,\n                _ref,\n                rowTag,\n                buffer,\n                rowLength\n              ),\n          (i = lastIdx),\n          3 === rowState && i++,\n          (rowLength = _ref = rowTag = rowState = 0),\n          (buffer.length = 0);\n      else {\n        value = new Uint8Array(value.buffer, offset, value.byteLength - i);\n        98 === rowTag\n          ? ((rowLength -= value.byteLength),\n            resolveBuffer(response, _ref, value))\n          : (buffer.push(value), (rowLength -= value.byteLength));\n        break;\n      }\n    }\n    streamState._rowState = rowState;\n    streamState._rowID = _ref;\n    streamState._rowTag = rowTag;\n    streamState._rowLength = rowLength;\n    return reader.read().then(progress).catch(error);\n  }\n  function error(e) {\n    reportGlobalError(response, e);\n  }\n  var streamState = {\n      _rowState: 0,\n      _rowID: 0,\n      _rowTag: 0,\n      _rowLength: 0,\n      _buffer: []\n    },\n    reader = stream.getReader();\n  reader.read().then(progress).catch(error);\n}\nexports.createFromFetch = function (promiseForResponse, options) {\n  var response = createResponseFromOptions(options);\n  promiseForResponse.then(\n    function (r) {\n      startReadingFromStream(response, r.body, close.bind(null, response));\n    },\n    function (e) {\n      reportGlobalError(response, e);\n    }\n  );\n  return getChunk(response, 0);\n};\nexports.createFromReadableStream = function (stream, options) {\n  options = createResponseFromOptions(options);\n  startReadingFromStream(options, stream, close.bind(null, options));\n  return getChunk(options, 0);\n};\nexports.createServerReference = function (id) {\n  return createServerReference$1(id, noServerCall);\n};\nexports.createTemporaryReferenceSet = function () {\n  return new Map();\n};\nexports.encodeReply = function (value, options) {\n  return new Promise(function (resolve, reject) {\n    var abort = processReply(\n      value,\n      \"\",\n      options && options.temporaryReferences\n        ? options.temporaryReferences\n        : void 0,\n      resolve,\n      reject\n    );\n    if (options && options.signal) {\n      var signal = options.signal;\n      if (signal.aborted) abort(signal.reason);\n      else {\n        var listener = function () {\n          abort(signal.reason);\n          signal.removeEventListener(\"abort\", listener);\n        };\n        signal.addEventListener(\"abort\", listener);\n      }\n    }\n  });\n};\nexports.registerServerReference = function (reference, id, encodeFormAction) {\n  registerBoundServerReference(reference, id, null, encodeFormAction);\n  return reference;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.edge.production.js');\n} else {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.edge.development.js');\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { NavigationSeed } from '../segment-cache/navigation'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  previousTree: FlightRouterState\n  url: URL\n  nextUrl: string | null\n  seed: NavigationSeed | null\n  mpa: boolean\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nconst pathname = `${basePath}/__nextjs_source-map`;\nexport const findSourceMapURL = process.env.NODE_ENV === 'development' ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return `${filename}.map`;\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : undefined;\n\n//# sourceMappingURL=app-find-source-map-url.js.map","import { startTransition } from 'react';\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types';\nimport { dispatchAppRouterAction } from './components/use-action-queue';\nexport async function callServer(actionId, actionArgs) {\n    return new Promise((resolve, reject)=>{\n        startTransition(()=>{\n            dispatchAppRouterAction({\n                type: ACTION_SERVER_ACTION,\n                actionId,\n                actionArgs,\n                resolve,\n                reject\n            });\n        });\n    });\n}\n\n//# sourceMappingURL=app-call-server.js.map","import { addSearchParamsIfPageSegment, DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from '../shared/lib/segment';\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding';\nimport { NEXT_REWRITTEN_PATH_HEADER, NEXT_REWRITTEN_QUERY_HEADER, NEXT_RSC_UNION_QUERY } from './components/app-router-headers';\nexport function getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nexport function getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nexport function parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Catchall intercepted\n        case 'ci(..)(..)':\n        case 'ci(.)':\n        case 'ci(..)':\n        case 'ci(...)':\n            {\n                const prefix = paramType.length - 2;\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s, i)=>{\n                    if (i === 0) {\n                        return encodeURIComponent(s.slice(prefix));\n                    }\n                    return encodeURIComponent(s);\n                }) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        // Dynamic intercepted\n        case 'di(..)(..)':\n        case 'di(.)':\n        case 'di(..)':\n        case 'di(...)':\n            {\n                const prefix = paramType.length - 2;\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex].slice(prefix));\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nexport function doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nexport function getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nexport function urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY);\n    if (process.env.NODE_ENV === 'production') {\n        if (process.env.__NEXT_CONFIG_OUTPUT === 'export' && urlWithoutFlightParameters.pathname.endsWith('.txt')) {\n            const { pathname } = urlWithoutFlightParameters;\n            const length = pathname.endsWith('/index.txt') ? 10 : 4;\n            // Slice off `/index.txt` or `.txt` from the end of the pathname\n            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);\n        }\n    }\n    return urlWithoutFlightParameters;\n}\nexport function getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nexport function urlSearchParamsToParsedUrlQuery(searchParams) {\n    // Converts a URLSearchParams object to the same type used by the server when\n    // creating search params props, i.e. the type returned by Node's\n    // \"querystring\" module.\n    const result = {};\n    for (const [key, value] of searchParams.entries()){\n        if (result[key] === undefined) {\n            result[key] = value;\n        } else if (Array.isArray(result[key])) {\n            result[key].push(value);\n        } else {\n            result[key] = [\n                result[key],\n                value\n            ];\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=route-params.js.map","import { PAGE_SEGMENT_KEY } from '../segment';\nexport const ROOT_SEGMENT_REQUEST_KEY = '';\nexport const HEAD_REQUEST_KEY = '/_head';\nexport function createSegmentRequestKeyPart(segment) {\n    if (typeof segment === 'string') {\n        if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n            // The Flight Router State type sometimes includes the search params in\n            // the page segment. However, the Segment Cache tracks this as a separate\n            // key. So, we strip the search params here, and then add them back when\n            // the cache entry is turned back into a FlightRouterState. This is an\n            // unfortunate consequence of the FlightRouteState being used both as a\n            // transport type and as a cache key; we'll address this once more of the\n            // Segment Cache implementation has settled.\n            // TODO: We should hoist the search params out of the FlightRouterState\n            // type entirely, This is our plan for dynamic route params, too.\n            return PAGE_SEGMENT_KEY;\n        }\n        const safeName = // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n        // But params typically don't include the leading slash. We should use\n        // a different encoding to avoid this special case.\n        segment === '/_not-found' ? '_not-found' : encodeToFilesystemAndURLSafeString(segment);\n        // Since this is not a dynamic segment, it's fully encoded. It does not\n        // need to be \"hydrated\" with a param value.\n        return safeName;\n    }\n    const name = segment[0];\n    const paramType = segment[2];\n    const safeName = encodeToFilesystemAndURLSafeString(name);\n    const encodedName = '$' + paramType + '$' + safeName;\n    return encodedName;\n}\nexport function appendSegmentRequestKeyPart(parentRequestKey, parallelRouteKey, childRequestKeyPart) {\n    // Aside from being filesystem safe, segment keys are also designed so that\n    // each segment and parallel route creates its own subdirectory. Roughly in\n    // the same shape as the source app directory. This is mostly just for easier\n    // debugging (you can open up the build folder and navigate the output); if\n    // we wanted to do we could just use a flat structure.\n    // Omit the parallel route key for children, since this is the most\n    // common case. Saves some bytes (and it's what the app directory does).\n    const slotKey = parallelRouteKey === 'children' ? childRequestKeyPart : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`;\n    return parentRequestKey + '/' + slotKey;\n}\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/;\nfunction encodeToFilesystemAndURLSafeString(value) {\n    if (simpleParamValueRegex.test(value)) {\n        return value;\n    }\n    // If there are any unsafe characters, base64url-encode the entire value.\n    // We also add a ! prefix so it doesn't collide with the simple case.\n    const base64url = btoa(value).replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n    ;\n    return '!' + base64url;\n}\nexport function convertSegmentPathToStaticExportFilename(segmentPath) {\n    return `__next${segmentPath.replace(/\\//g, '.')}.txt`;\n}\n\n//# sourceMappingURL=segment-value-encoding.js.map","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import { PAGE_SEGMENT_KEY } from '../shared/lib/segment';\nimport { getCacheKeyForDynamicParam, parseDynamicParamFromURLPart, doesStaticSegmentAppearInURL, getRenderedPathname, getRenderedSearch } from './route-params';\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url';\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(flightDataPath) {\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n    const flightDataPathLength = 4;\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\n    return {\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\n        pathToSegment: segmentPath.slice(0, -1),\n        segmentPath,\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n        // in which case we default to ''.\n        segment: segmentPath[segmentPath.length - 1] ?? '',\n        tree,\n        seedData,\n        head,\n        isHeadPartial,\n        isRootRender: flightDataPath.length === flightDataPathLength\n    };\n}\nexport function createInitialRSCPayloadFromFallbackPrerender(response, fallbackInitialRSCPayload) {\n    // This is a static fallback page. In order to hydrate the page, we need to\n    // parse the client params from the URL, but to account for the possibility\n    // that the page was rewritten, we need to check the response headers\n    // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n    // we can't access the headers of the initial document response, the client\n    // performs a fetch request to the current location. Since it's possible that\n    // the fetch request will be dynamically rewritten to a different path than\n    // the initial document, this fetch request delivers _all_ the hydration data\n    // for the page; it was not inlined into the document, like it normally\n    // would be.\n    //\n    // TODO: Consider treating the case where fetch is rewritten to a different\n    // path from the document as a special deopt case. We should optimistically\n    // assume this won't happen, inline the data into the document, and perform\n    // a minimal request (like a HEAD or range request) to verify that the\n    // response matches. Tricky to get right because we need to account for\n    // all the different deployment environments we support, like output:\n    // \"export\" mode, where we currently don't assume that custom response\n    // headers are present.\n    // Patch the Flight data sent by the server with the correct params parsed\n    // from the URL + response object.\n    const renderedPathname = getRenderedPathname(response);\n    const renderedSearch = getRenderedSearch(response);\n    const canonicalUrl = createHrefFromUrl(new URL(location.href));\n    const originalFlightDataPath = fallbackInitialRSCPayload.f[0];\n    const originalFlightRouterState = originalFlightDataPath[0];\n    return {\n        b: fallbackInitialRSCPayload.b,\n        c: canonicalUrl.split('/'),\n        q: renderedSearch,\n        i: fallbackInitialRSCPayload.i,\n        f: [\n            [\n                fillInFallbackFlightRouterState(originalFlightRouterState, renderedPathname, renderedSearch),\n                originalFlightDataPath[1],\n                originalFlightDataPath[2],\n                originalFlightDataPath[2]\n            ]\n        ],\n        m: fallbackInitialRSCPayload.m,\n        G: fallbackInitialRSCPayload.G,\n        S: fallbackInitialRSCPayload.S\n    };\n}\nfunction fillInFallbackFlightRouterState(flightRouterState, renderedPathname, renderedSearch) {\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    return fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, index);\n}\nfunction fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, pathnamePartsIndex) {\n    const originalSegment = flightRouterState[0];\n    let newSegment;\n    let doesAppearInURL;\n    if (typeof originalSegment === 'string') {\n        newSegment = originalSegment;\n        doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment);\n    } else {\n        const paramName = originalSegment[0];\n        const paramType = originalSegment[2];\n        const paramValue = parseDynamicParamFromURLPart(paramType, pathnameParts, pathnamePartsIndex);\n        const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch);\n        newSegment = [\n            paramName,\n            cacheKey,\n            paramType\n        ];\n        doesAppearInURL = true;\n    }\n    // Only increment the index if the segment appears in the URL. If it's a\n    // \"virtual\" segment, like a route group, it remains the same.\n    const childPathnamePartsIndex = doesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n    const children = flightRouterState[1];\n    const newChildren = {};\n    for(let key in children){\n        const childFlightRouterState = children[key];\n        newChildren[key] = fillInFallbackFlightRouterStateImpl(childFlightRouterState, renderedSearch, pathnameParts, childPathnamePartsIndex);\n    }\n    const newState = [\n        newSegment,\n        newChildren,\n        null,\n        flightRouterState[3],\n        flightRouterState[4]\n    ];\n    return newState;\n}\nexport function getNextFlightSegmentPath(flightSegmentPath) {\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n    // to get the next segment path.\n    return flightSegmentPath.slice(2);\n}\nexport function normalizeFlightData(flightData) {\n    // FlightData can be a string when the server didn't respond with a proper flight response,\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n    if (typeof flightData === 'string') {\n        return flightData;\n    }\n    return flightData.map((flightDataPath)=>getFlightDataPartsFromPath(flightDataPath));\n}\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */ export function prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {\n    // HMR requests need the complete, unmodified state for proper functionality\n    if (isHmrRefresh) {\n        return encodeURIComponent(JSON.stringify(flightRouterState));\n    }\n    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));\n}\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {\n    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;\n    // __PAGE__ segments are always fetched from the server, so there's\n    // no need to send them up\n    const cleanedSegment = stripSearchParamsFromPageSegment(segment);\n    // Recursively process parallel routes\n    const cleanedParallelRoutes = {};\n    for (const [key, childState] of Object.entries(parallelRoutes)){\n        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);\n    }\n    const result = [\n        cleanedSegment,\n        cleanedParallelRoutes,\n        null,\n        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null\n    ];\n    // Append optional fields if present\n    if (isRootLayout !== undefined) {\n        result[4] = isRootLayout;\n    }\n    if (hasLoadingBoundary !== undefined) {\n        result[5] = hasLoadingBoundary;\n    }\n    return result;\n}\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */ function stripSearchParamsFromPageSegment(segment) {\n    if (typeof segment === 'string' && segment.startsWith(PAGE_SEGMENT_KEY + '?')) {\n        return PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */ function shouldPreserveRefreshMarker(refreshMarker) {\n    return Boolean(refreshMarker && refreshMarker !== 'refresh');\n}\n\n//# sourceMappingURL=flight-data-helpers.js.map","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId = '';\nexport function setAppBuildId(buildId) {\n    globalBuildId = buildId;\n}\nexport function getAppBuildId() {\n    return globalBuildId;\n}\n\n//# sourceMappingURL=app-build-id.js.map","import { hexHash } from '../../hash';\nexport function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {\n    if ((prefetchHeader === undefined || prefetchHeader === '0') && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {\n        return '';\n    }\n    return hexHash([\n        prefetchHeader || '0',\n        segmentPrefetchHeader || '0',\n        stateTreeHeader || '0',\n        nextUrlHeader || '0'\n    ].join(','));\n}\n\n//# sourceMappingURL=cache-busting-search-param.js.map","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str) {\n    let hash = 5381;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) + hash + char & 0xffffffff;\n    }\n    return hash >>> 0;\n}\nexport function hexHash(str) {\n    return djb2Hash(str).toString(36).slice(0, 5);\n}\n\n//# sourceMappingURL=hash.js.map","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","'use client';\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream as createFromReadableStreamBrowser, createFromFetch as createFromFetchBrowser } from 'react-server-dom-webpack/client';\nimport { NEXT_ROUTER_STATE_TREE_HEADER, NEXT_RSC_UNION_QUERY, NEXT_URL, RSC_HEADER, RSC_CONTENT_TYPE_HEADER, NEXT_HMR_REFRESH_HEADER, NEXT_DID_POSTPONE_HEADER, NEXT_ROUTER_STALE_TIME_HEADER, NEXT_HTML_REQUEST_ID_HEADER, NEXT_REQUEST_ID_HEADER } from '../app-router-headers';\nimport { callServer } from '../../app-call-server';\nimport { findSourceMapURL } from '../../app-find-source-map-url';\nimport { normalizeFlightData, prepareFlightRouterStateForRequest } from '../../flight-data-helpers';\nimport { getAppBuildId } from '../../app-build-id';\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param';\nimport { getRenderedSearch, urlToUrlWithoutFlightMarker } from '../../route-params';\nimport { getDeploymentId } from '../../../shared/lib/deployment-id';\nconst createFromReadableStream = createFromReadableStreamBrowser;\nconst createFromFetch = createFromFetchBrowser;\nlet createDebugChannel;\nif (process.env.NODE_ENV !== 'production' && process.env.__NEXT_REACT_DEBUG_CHANNEL) {\n    createDebugChannel = require('../../dev/debug-channel').createDebugChannel;\n}\nfunction doMpaNavigation(url) {\n    return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString();\n}\nlet isPageUnloading = false;\nif (typeof window !== 'undefined') {\n    // Track when the page is unloading, e.g. due to reloading the page or\n    // performing hard navigations. This allows us to suppress error logging when\n    // the browser cancels in-flight requests during page unload.\n    window.addEventListener('pagehide', ()=>{\n        isPageUnloading = true;\n    });\n    // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n    // execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        isPageUnloading = false;\n    });\n}\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */ export async function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl } = options;\n    const headers = {\n        // Enable flight response\n        [RSC_HEADER]: '1',\n        // Provide the current router state\n        [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(flightRouterState, options.isHmrRefresh)\n    };\n    if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n        headers[NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[NEXT_URL] = nextUrl;\n    }\n    // In static export mode, we need to modify the URL to request the .txt file,\n    // but we should preserve the original URL for the canonical URL and error handling.\n    const originalUrl = url;\n    try {\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                // In \"output: export\" mode, we can't rely on headers to distinguish\n                // between HTML and RSC requests. Instead, we append an extra prefix\n                // to the request.\n                url = new URL(url);\n                if (url.pathname.endsWith('/')) {\n                    url.pathname += 'index.txt';\n                } else {\n                    url.pathname += '.txt';\n                }\n            }\n        }\n        // Typically, during a navigation, we decode the response using Flight's\n        // `createFromFetch` API, which accepts a `fetch` promise.\n        // TODO: Remove this check once the old PPR flag is removed\n        const isLegacyPPR = process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS;\n        const shouldImmediatelyDecode = !isLegacyPPR;\n        const res = await createFetch(url, headers, 'auto', shouldImmediatelyDecode);\n        const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : originalUrl;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!res.headers.get('vary')?.includes(NEXT_URL);\n        const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER);\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                if (!isFlightResponse) {\n                    isFlightResponse = contentType.startsWith('text/plain');\n                }\n            }\n        }\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        // TODO: This needs to happen in the Flight Client.\n        // Or Webpack needs to include the runtime update in the Flight response as\n        // a blocking script.\n        if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n            await require('../../dev/hot-reloader/app/hot-reloader-app').waitForWebpackRuntimeHotUpdate();\n        }\n        let flightResponsePromise = res.flightResponse;\n        if (flightResponsePromise === null) {\n            // Typically, `createFetch` would have already started decoding the\n            // Flight response. If it hasn't, though, we need to decode it now.\n            // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n            // without Cache Components). Remove this branch once legacy PPR\n            // is deleted.\n            const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n            flightResponsePromise = createFromNextReadableStream(flightStream, headers);\n        }\n        const flightResponse = await flightResponsePromise;\n        if (getAppBuildId() !== flightResponse.b) {\n            return doMpaNavigation(res.url);\n        }\n        const normalizedFlightData = normalizeFlightData(flightResponse.f);\n        if (typeof normalizedFlightData === 'string') {\n            return doMpaNavigation(normalizedFlightData);\n        }\n        return {\n            flightData: normalizedFlightData,\n            canonicalUrl: canonicalUrl,\n            renderedSearch: getRenderedSearch(res),\n            couldBeIntercepted: interception,\n            prerendered: flightResponse.S,\n            postponed,\n            staleTime,\n            debugInfo: flightResponsePromise._debugInfo ?? null\n        };\n    } catch (err) {\n        if (!isPageUnloading) {\n            console.error(`Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`, err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return originalUrl.toString();\n    }\n}\nexport async function createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n        headers['Next-Test-Fetch-Priority'] = fetchPriority;\n    }\n    const deploymentId = getDeploymentId();\n    if (deploymentId) {\n        headers['x-deployment-id'] = deploymentId;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (self.__next_r) {\n            headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    setCacheBustingSearchParam(fetchUrl, headers);\n    let fetchPromise = fetch(fetchUrl, fetchOptions);\n    // Immediately pass the fetch promise to the Flight client so that the debug\n    // info includes the latency from the client to the server. The internal timer\n    // in React starts as soon as `createFromFetch` is called.\n    //\n    // The only case where we don't do this is during a prefetch, because we have\n    // to do some extra processing of the response stream (see\n    // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n    // prefetch response never blocks a navigation; if it hasn't already been\n    // written into the cache by the time the navigation happens, the router will\n    // go straight to a dynamic request.\n    let flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n    let browserResponse = await fetchPromise;\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid — when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n        // This is to prevent a redirect loop. Same limit used by Chrome.\n        const MAX_REDIRECTS = 20;\n        for(let n = 0; n < MAX_REDIRECTS; n++){\n            if (!browserResponse.redirected) {\n                break;\n            }\n            const responseUrl = new URL(browserResponse.url, fetchUrl);\n            if (responseUrl.origin !== fetchUrl.origin) {\n                break;\n            }\n            if (responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) === fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)) {\n                break;\n            }\n            // The RSC request was redirected. Assume the response is invalid.\n            //\n            // Append the cache busting search param to the redirected URL and\n            // fetch again.\n            // TODO: We should abort the previous request.\n            fetchUrl = new URL(responseUrl);\n            setCacheBustingSearchParam(fetchUrl, headers);\n            fetchPromise = fetch(fetchUrl, fetchOptions);\n            flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n            browserResponse = await fetchPromise;\n            // We just performed a manual redirect, so this is now true.\n            redirected = true;\n        }\n    }\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status,\n        // This is the exact promise returned by `createFromFetch`. It contains\n        // debug information that we need to transfer to any derived promises that\n        // are later rendered by React.\n        flightResponse: flightResponsePromise\n    };\n    return rscResponse;\n}\nexport function createFromNextReadableStream(flightStream, requestHeaders) {\n    return createFromReadableStream(flightStream, {\n        callServer,\n        findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createFromNextFetch(promiseForResponse, requestHeaders) {\n    return createFromFetch(promiseForResponse, {\n        callServer,\n        findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\n\n//# sourceMappingURL=fetch-server-response.js.map","// This could also be a variable instead of a function, but some unit tests want to change the ID at\n// runtime. Even though that would never happen in a real deployment.\nexport function getDeploymentId() {\n    return process.env.NEXT_DEPLOYMENT_ID;\n}\nexport function getDeploymentIdQueryOrEmptyString() {\n    let deploymentId = getDeploymentId();\n    if (deploymentId) {\n        return `?dpl=${deploymentId}`;\n    }\n    return '';\n}\n\n//# sourceMappingURL=deployment-id.js.map","import { FetchStrategy } from './types';\nimport { Fallback } from './cache-map';\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding';\nexport function getRouteVaryPath(pathname, search, nextUrl) {\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: nextUrl,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nexport function getFulfilledRouteVaryPath(pathname, search, nextUrl, couldBeIntercepted) {\n    // This is called when a route's data is fulfilled. The cache entry will be\n    // re-keyed based on which inputs the response varies by.\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: couldBeIntercepted ? nextUrl : Fallback,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nexport function appendLayoutVaryPath(parentPath, cacheKey) {\n    const varyPathPart = {\n        value: cacheKey,\n        parent: parentPath\n    };\n    return varyPathPart;\n}\nexport function finalizeLayoutVaryPath(requestKey, varyPath) {\n    const layoutVaryPath = {\n        value: requestKey,\n        parent: varyPath\n    };\n    return layoutVaryPath;\n}\nexport function finalizePageVaryPath(requestKey, renderedSearch, varyPath) {\n    // Unlike layouts, a page segment's vary path also includes the search string.\n    // requestKey -> searchParams -> pathParams\n    const pageVaryPath = {\n        value: requestKey,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nexport function finalizeMetadataVaryPath(pageRequestKey, renderedSearch, varyPath) {\n    // The metadata \"segment\" is not a real segment because it doesn't exist in\n    // the normal structure of the route tree, but in terms of caching, it\n    // behaves like a page segment because it varies by all the same params as\n    // a page.\n    //\n    // To keep the protocol for querying the server simple, the request key for\n    // the metadata does not include any path information. It's unnecessary from\n    // the server's perspective, because unlike page segments, there's only one\n    // metadata response per URL, i.e. there's no need to distinguish multiple\n    // parallel pages.\n    //\n    // However, this means the metadata request key is insufficient for\n    // caching the the metadata in the client cache, because on the client we\n    // use the request key to distinguish the metadata entry from all other\n    // page's metadata entries.\n    //\n    // So instead we create a simulated request key based on the page segment.\n    // Conceptually this is equivalent to the request key the server would have\n    // assigned the metadata segment if it treated it as part of the actual\n    // route structure.\n    // If there are multiple parallel pages, we use whichever is the first one.\n    // This is fine because the only difference between request keys for\n    // different parallel pages are things like route groups and parallel\n    // route slots. As long as it's always the same one, it doesn't matter.\n    const pageVaryPath = {\n        // Append the actual metadata request key to the page request key. Note\n        // that we're not using a separate vary path part; it's unnecessary because\n        // these are not conceptually separate inputs.\n        value: pageRequestKey + HEAD_REQUEST_KEY,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nexport function getSegmentVaryPathForRequest(fetchStrategy, tree) {\n    // This is used for storing pending requests in the cache. We want to choose\n    // the most generic vary path based on the strategy used to fetch it, i.e.\n    // static/PPR versus runtime prefetching, so that it can be reused as much\n    // as possible.\n    //\n    // We may be able to re-key the response to something even more generic once\n    // we receive it — for example, if the server tells us that the response\n    // doesn't vary on a particular param — but even before we send the request,\n    // we know some params are reusable based on the fetch strategy alone. For\n    // example, a static prefetch will never vary on search params.\n    //\n    // The original vary path with all the params filled in is stored on the\n    // route tree object. We will clone this one to create a new vary path\n    // where certain params are replaced with Fallback.\n    //\n    // This result of this function is not stored anywhere. It's only used to\n    // access the cache a single time.\n    //\n    // TODO: Rather than create a new list object just to access the cache, the\n    // plan is to add the concept of a \"vary mask\". This will represent all the\n    // params that can be treated as Fallback. (Or perhaps the inverse.)\n    const originalVaryPath = tree.varyPath;\n    // Only page segments (and the special \"metadata\" segment, which is treated\n    // like a page segment for the purposes of caching) may contain search\n    // params. There's no reason to include them in the vary path otherwise.\n    if (tree.isPage) {\n        // Only a runtime prefetch will include search params in the vary path.\n        // Static prefetches never include search params, so they can be reused\n        // across all possible search param values.\n        const doesVaryOnSearchParams = fetchStrategy === FetchStrategy.Full || fetchStrategy === FetchStrategy.PPRRuntime;\n        if (!doesVaryOnSearchParams) {\n            // The response from the the server will not vary on search params. Clone\n            // the end of the original vary path to replace the search params\n            // with Fallback.\n            //\n            // requestKey -> searchParams -> pathParams\n            //               ^ This part gets replaced with Fallback\n            const searchParamsVaryPath = originalVaryPath.parent;\n            const pathParamsVaryPath = searchParamsVaryPath.parent;\n            const patchedVaryPath = {\n                value: originalVaryPath.value,\n                parent: {\n                    value: Fallback,\n                    parent: pathParamsVaryPath\n                }\n            };\n            return patchedVaryPath;\n        }\n    }\n    // The request does vary on search params. We don't need to modify anything.\n    return originalVaryPath;\n}\nexport function clonePageVaryPathWithNewSearchParams(originalVaryPath, newSearch) {\n    // requestKey -> searchParams -> pathParams\n    //               ^ This part gets replaced with newSearch\n    const searchParamsVaryPath = originalVaryPath.parent;\n    const clonedVaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n            value: newSearch,\n            parent: searchParamsVaryPath.parent\n        }\n    };\n    return clonedVaryPath;\n}\n\n//# sourceMappingURL=vary-path.js.map","import { deleteMapEntry } from './cache-map';\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\nlet head = null;\nlet didScheduleCleanup = false;\nlet lruSize = 0;\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n;\nexport function lruPut(node) {\n    if (head === node) {\n        // Already at the head\n        return;\n    }\n    const prev = node.prev;\n    const next = node.next;\n    if (next === null || prev === null) {\n        // This is an insertion\n        lruSize += node.size;\n        // Whenever we add an entry, we need to check if we've exceeded the\n        // max size. We don't evict entries immediately; they're evicted later in\n        // an asynchronous task.\n        ensureCleanupIsScheduled();\n    } else {\n        // This is a move. Remove from its current position.\n        prev.next = next;\n        next.prev = prev;\n    }\n    // Move to the front of the list\n    if (head === null) {\n        // This is the first entry\n        node.prev = node;\n        node.next = node;\n    } else {\n        // Add to the front of the list\n        const tail = head.prev;\n        node.prev = tail;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            tail.next = node;\n        }\n        node.next = head;\n        head.prev = node;\n    }\n    head = node;\n}\nexport function updateLruSize(node, newNodeSize) {\n    // This is a separate function from `put` so that we can resize the entry\n    // regardless of whether it's currently being tracked by the LRU.\n    const prevNodeSize = node.size;\n    node.size = newNodeSize;\n    if (node.next === null) {\n        // This entry is not currently being tracked by the LRU.\n        return;\n    }\n    // Update the total LRU size\n    lruSize = lruSize - prevNodeSize + newNodeSize;\n    ensureCleanupIsScheduled();\n}\nexport function deleteFromLru(deleted) {\n    const next = deleted.next;\n    const prev = deleted.prev;\n    if (next !== null && prev !== null) {\n        lruSize -= deleted.size;\n        deleted.next = null;\n        deleted.prev = null;\n        // Remove from the list\n        if (head === deleted) {\n            // Update the head\n            if (next === head) {\n                // This was the last entry\n                head = null;\n            } else {\n                head = next;\n                prev.next = next;\n                next.prev = prev;\n            }\n        } else {\n            prev.next = next;\n            next.prev = prev;\n        }\n    } else {\n    // Already deleted\n    }\n}\nfunction ensureCleanupIsScheduled() {\n    if (didScheduleCleanup || lruSize <= maxLruSize) {\n        return;\n    }\n    didScheduleCleanup = true;\n    requestCleanupCallback(cleanup);\n}\nfunction cleanup() {\n    didScheduleCleanup = false;\n    // Evict entries until we're at 90% capacity. We can assume this won't\n    // infinite loop because even if `maxLruSize` were 0, eventually\n    // `deleteFromLru` sets `head` to `null` when we run out entries.\n    const ninetyPercentMax = maxLruSize * 0.9;\n    while(lruSize > ninetyPercentMax && head !== null){\n        const tail = head.prev;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            // Delete the entry from the map. In turn, this will remove it from\n            // the LRU.\n            deleteMapEntry(tail);\n        }\n    }\n}\nconst requestCleanupCallback = typeof requestIdleCallback === 'function' ? requestIdleCallback : (cb)=>setTimeout(cb, 0);\n\n//# sourceMappingURL=lru.js.map","import { lruPut, updateLruSize, deleteFromLru } from './lru';\nexport const Fallback = {};\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {};\nexport function createCacheMap() {\n    const cacheMap = {\n        parent: null,\n        key: null,\n        value: null,\n        map: null,\n        // LRU-related fields\n        prev: null,\n        next: null,\n        size: 0\n    };\n    return cacheMap;\n}\nfunction getOrInitialize(cacheMap, keys, isRevalidation) {\n    // Go through each level of keys until we find the entry that matches, or\n    // create a new entry if one doesn't exist.\n    //\n    // This function will only return entries that match the keypath _exactly_.\n    // Unlike getWithFallback, it will not access fallback entries unless it's\n    // explicitly part of the keypath.\n    let entry = cacheMap;\n    let remainingKeys = keys;\n    let key = null;\n    while(true){\n        const previousKey = key;\n        if (remainingKeys !== null) {\n            key = remainingKeys.value;\n            remainingKeys = remainingKeys.parent;\n        } else if (isRevalidation && previousKey !== Revalidation) {\n            // During a revalidation, we append an internal \"Revalidation\" key to\n            // the end of the keypath. The \"normal\" entry is its parent.\n            // However, if the parent entry is currently empty, we don't need to store\n            // this as a revalidation entry. Just insert the revalidation into the\n            // normal slot.\n            if (entry.value === null) {\n                return entry;\n            }\n            // Otheriwse, create a child entry.\n            key = Revalidation;\n        } else {\n            break;\n        }\n        let map = entry.map;\n        if (map !== null) {\n            const existingEntry = map.get(key);\n            if (existingEntry !== undefined) {\n                // Found a match. Keep going.\n                entry = existingEntry;\n                continue;\n            }\n        } else {\n            map = new Map();\n            entry.map = map;\n        }\n        // No entry exists yet at this level. Create a new one.\n        const newEntry = {\n            parent: entry,\n            key,\n            value: null,\n            map: null,\n            // LRU-related fields\n            prev: null,\n            next: null,\n            size: 0\n        };\n        map.set(key, newEntry);\n        entry = newEntry;\n    }\n    return entry;\n}\nexport function getFromCacheMap(now, currentCacheVersion, rootEntry, keys, isRevalidation) {\n    const entry = getEntryWithFallbackImpl(now, currentCacheVersion, rootEntry, keys, isRevalidation, 0);\n    if (entry === null || entry.value === null) {\n        return null;\n    }\n    // This is an LRU access. Move the entry to the front of the list.\n    lruPut(entry);\n    return entry.value;\n}\nexport function isValueExpired(now, currentCacheVersion, value) {\n    return value.staleAt <= now || value.version < currentCacheVersion;\n}\nfunction lazilyEvictIfNeeded(now, currentCacheVersion, entry) {\n    // We have a matching entry, but before we can return it, we need to check if\n    // it's still fresh. Otherwise it should be treated the same as a cache miss.\n    if (entry.value === null) {\n        // This entry has no value, so there's nothing to evict.\n        return entry;\n    }\n    const value = entry.value;\n    if (isValueExpired(now, currentCacheVersion, value)) {\n        // The value expired. Lazily evict it from the cache, and return null. This\n        // is conceptually the same as a cache miss.\n        deleteMapEntry(entry);\n        return null;\n    }\n    // The matched entry has not expired. Return it.\n    return entry;\n}\nfunction getEntryWithFallbackImpl(now, currentCacheVersion, entry, keys, isRevalidation, previousKey) {\n    // This is similar to getExactEntry, but if an exact match is not found for\n    // a key, it will return the fallback entry instead. This is recursive at\n    // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n    // valid match for [a, b, c, d].\n    //\n    // It will return the most specific match available.\n    let key;\n    let remainingKeys;\n    if (keys !== null) {\n        key = keys.value;\n        remainingKeys = keys.parent;\n    } else if (isRevalidation && previousKey !== Revalidation) {\n        // During a revalidation, we append an internal \"Revalidation\" key to\n        // the end of the keypath.\n        key = Revalidation;\n        remainingKeys = null;\n    } else {\n        // There are no more keys. This is the terminal entry.\n        // TODO: When performing a lookup during a navigation, as opposed to a\n        // prefetch, we may want to skip entries that are Pending if there's also\n        // a Fulfilled fallback entry. Tricky to say, though, since if it's\n        // already pending, it's likely to stream in soon. Maybe we could do this\n        // just on slow connections and offline mode.\n        return lazilyEvictIfNeeded(now, currentCacheVersion, entry);\n    }\n    const map = entry.map;\n    if (map !== null) {\n        const existingEntry = map.get(key);\n        if (existingEntry !== undefined) {\n            // Found an exact match for this key. Keep searching.\n            const result = getEntryWithFallbackImpl(now, currentCacheVersion, existingEntry, remainingKeys, isRevalidation, key);\n            if (result !== null) {\n                return result;\n            }\n        }\n        // No match found for this key. Check if there's a fallback.\n        const fallbackEntry = map.get(Fallback);\n        if (fallbackEntry !== undefined) {\n            // Found a fallback for this key. Keep searching.\n            return getEntryWithFallbackImpl(now, currentCacheVersion, fallbackEntry, remainingKeys, isRevalidation, key);\n        }\n    }\n    return null;\n}\nexport function setInCacheMap(cacheMap, keys, value, isRevalidation) {\n    // Add a value to the map at the given keypath. If the value is already\n    // part of the map, it's removed from its previous keypath. (NOTE: This is\n    // unlike a regular JS map, but the behavior is intentional.)\n    const entry = getOrInitialize(cacheMap, keys, isRevalidation);\n    setMapEntryValue(entry, value);\n    // This is an LRU access. Move the entry to the front of the list.\n    lruPut(entry);\n    updateLruSize(entry, value.size);\n}\nfunction setMapEntryValue(entry, value) {\n    if (entry.value !== null) {\n        // There's already a value at the given keypath. Disconnect the old value\n        // from the map. We're not calling `deleteMapEntry` here because the\n        // entry itself is still in the map. We just want to overwrite its value.\n        dropRef(entry.value);\n        entry.value = null;\n    }\n    // This value may already be in the map at a different keypath.\n    // Grab a reference before we overwrite it.\n    const oldEntry = value.ref;\n    entry.value = value;\n    value.ref = entry;\n    updateLruSize(entry, value.size);\n    if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n        // This value is already in the map at a different keypath in the map.\n        // Values only exist at a single keypath at a time. Remove it from the\n        // previous keypath.\n        //\n        // Note that only the internal map entry is garbage collected; we don't\n        // call `dropRef` here because it's still in the map, just\n        // at a new keypath (the one we just set, above).\n        deleteMapEntry(oldEntry);\n    }\n}\nexport function deleteFromCacheMap(value) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    dropRef(value);\n    deleteMapEntry(entry);\n}\nfunction dropRef(value) {\n    // Drop the value from the map by setting its `ref` backpointer to\n    // null. This is a separate operation from `deleteMapEntry` because when\n    // re-keying a value we need to be able to delete the old, internal map\n    // entry without garbage collecting the value itself.\n    value.ref = null;\n}\nexport function deleteMapEntry(entry) {\n    // Delete the entry from the cache.\n    entry.value = null;\n    deleteFromLru(entry);\n    // Check if we can garbage collect the entry.\n    const map = entry.map;\n    if (map === null) {\n        // Since this entry has no value, and also no child entries, we can\n        // garbage collect it. Remove it from its parent, and keep garbage\n        // collecting the parents until we reach a non-empty entry.\n        let parent = entry.parent;\n        let key = entry.key;\n        while(parent !== null){\n            const parentMap = parent.map;\n            if (parentMap !== null) {\n                parentMap.delete(key);\n                if (parentMap.size === 0) {\n                    // We just removed the last entry in the parent map.\n                    parent.map = null;\n                    if (parent.value === null) {\n                        // The parent node has no child entries, nor does it have a value\n                        // on itself. It can be garbage collected. Keep going.\n                        key = parent.key;\n                        parent = parent.parent;\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n    } else {\n        // Check if there's a revalidating entry. If so, promote it to a\n        // \"normal\" entry, since the normal one was just deleted.\n        const revalidatingEntry = map.get(Revalidation);\n        if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n            setMapEntryValue(entry, revalidatingEntry.value);\n        }\n    }\n}\nexport function setSizeInCacheMap(value, size) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    // Except during initialization (when the size is set to 0), this is the only\n    // place the `size` field should be updated, to ensure it's in sync with the\n    // the LRU.\n    value.size = size;\n    updateLruSize(entry, size);\n}\n\n//# sourceMappingURL=cache-map.js.map","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash';\nimport { isGroupSegment } from '../../segment';\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */ export function normalizeAppPath(route) {\n    return ensureLeadingSlash(route.split('/').reduce((pathname, segment, index, segments)=>{\n        // Empty segments are ignored.\n        if (!segment) {\n            return pathname;\n        }\n        // Groups are ignored.\n        if (isGroupSegment(segment)) {\n            return pathname;\n        }\n        // Parallel segments are ignored.\n        if (segment[0] === '@') {\n            return pathname;\n        }\n        // The last segment (if it's a leaf) should be ignored.\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\n            return pathname;\n        }\n        return `${pathname}/${segment}`;\n    }, ''));\n}\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */ export function normalizeRscURL(url) {\n    return url.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\n    '$1');\n}\n\n//# sourceMappingURL=app-paths.js.map","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ export function ensureLeadingSlash(path) {\n    return path.startsWith('/') ? path : `/${path}`;\n}\n\n//# sourceMappingURL=ensure-leading-slash.js.map","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport type InterceptionMarker = (typeof INTERCEPTION_ROUTE_MARKERS)[number]\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes';\nimport { isGroupSegment, DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from '../../../shared/lib/segment';\nimport { matchSegment } from '../match-segments';\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === '/' ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === 'string') {\n        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n        if (segment === 'children') return '';\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === '' || isGroupSegment(segment)) {\n            return acc;\n        }\n        return `${acc}/${segment}`;\n    }, '') || '/';\n}\nexport function extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === DEFAULT_SEGMENT_KEY || INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(PAGE_SEGMENT_KEY)) return '';\n    const segments = [\n        segmentToPathname(segment)\n    ];\n    const parallelRoutes = flightRouterState[1] ?? {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === 'children') continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return '';\n    }\n    if (!matchSegment(segmentA, segmentB)) {\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return extractPathFromFlightRouterState(treeB) ?? '';\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return `${segmentToPathname(segmentB)}/${changedPath}`;\n            }\n        }\n    }\n    return null;\n}\nexport function computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === '/') {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split('/'));\n}\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */ export function getSelectedParams(currentTree, params = {}) {\n    const parallelRoutes = currentTree[1];\n    for (const parallelRoute of Object.values(parallelRoutes)){\n        const segment = parallelRoute[0];\n        const isDynamicParameter = Array.isArray(segment);\n        const segmentValue = isDynamicParameter ? segment[1] : segment;\n        if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue;\n        // Ensure catchAll and optional catchall are turned into an array\n        const isCatchAll = isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc');\n        if (isCatchAll) {\n            params[segment[0]] = segment[1].split('/');\n        } else if (isDynamicParameter) {\n            params[segment[0]] = segment[1];\n        }\n        params = getSelectedParams(parallelRoute, params);\n    }\n    return params;\n}\n\n//# sourceMappingURL=compute-changed-path.js.map","import { computeChangedPath } from './compute-changed-path';\nfunction isNotUndefined(value) {\n    return typeof value !== 'undefined';\n}\nexport function handleMutable(state, mutable) {\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = mutable.shouldScroll ?? true;\n    let previousNextUrl = state.previousNextUrl;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = computeChangedPath(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            previousNextUrl = nextUrl;\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    return {\n        // Set href.\n        canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n        renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable?.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: mutable.onlyHashChange || false,\n            hashFragment: shouldScroll ? // #top is handled in layout-router.\n            mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl,\n        previousNextUrl: previousNextUrl,\n        debugInfo: mutable.collectedDebugInfo ?? null\n    };\n}\n\n//# sourceMappingURL=handle-mutable.js.map","import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  ChildSegmentMap,\n  CacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  NOT_FOUND_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { dispatchAppRouterAction } from '../use-action-queue'\nimport {\n  ACTION_SERVER_PATCH,\n  type ServerPatchAction,\n} from './router-reducer-types'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\nimport {\n  convertServerPatchToFullTree,\n  type NavigationSeed,\n} from '../segment-cache/navigation'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type NavigationTask = {\n  status: NavigationTaskStatus\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents.\n  node: CacheNode\n  // The tree sent to the server during the dynamic request. If all the segments\n  // are static, then this will be null, and no server request is required.\n  // Otherwise, this is the same as `route`, except with the `refetch` marker\n  // set on the top-most segment that needs to be fetched.\n  dynamicRequestTree: FlightRouterState | null\n  // The URL that should be used to fetch the dynamic data. This is only set\n  // when the segment cannot be refetched from the current route, because it's\n  // part of a \"default\" parallel slot that was reused during a navigation.\n  refreshUrl: string | null\n  children: Map<string, NavigationTask> | null\n}\n\nexport const enum FreshnessPolicy {\n  Default,\n  Hydration,\n  HistoryTraversal,\n  RefreshAll,\n  HMRRefresh,\n}\n\nconst enum NavigationTaskStatus {\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\n/**\n * When a NavigationTask finishes, there may or may not be data still missing,\n * necessitating a retry.\n */\nconst enum NavigationTaskExitStatus {\n  /**\n   * No additional navigation is required.\n   */\n  Done = 0,\n  /**\n   * Some data failed to load, presumably due to a route tree mismatch. Perform\n   * a soft retry to reload the entire tree.\n   */\n  SoftRetry = 1,\n  /**\n   * Some data failed to load in an unrecoverable way, e.g. in an inactive\n   * parallel route. Fall back to a hard (MPA-style) retry.\n   */\n  HardRetry = 2,\n}\n\nexport type NavigationRequestAccumulation = {\n  scrollableSegments: Array<FlightSegmentPath> | null\n  separateRefreshUrls: Set<string> | null\n}\n\nconst noop = () => {}\n\nexport function createInitialCacheNodeForHydration(\n  navigatedAt: number,\n  initialTree: FlightRouterState,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData\n): CacheNode {\n  // Create the initial cache node tree, using the data embedded into the\n  // HTML document.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = createCacheNodeOnNavigation(\n    navigatedAt,\n    initialTree,\n    undefined,\n    FreshnessPolicy.Hydration,\n    seedData,\n    seedHead,\n    null,\n    null,\n    false,\n    null,\n    null,\n    false,\n    accumulation\n  )\n\n  // NOTE: We intentionally don't check if any data needs to be fetched from the\n  // server. We assume the initial hydration payload is sufficient to render\n  // the page.\n  //\n  // The completeness of the initial data is an important property that we rely\n  // on as a last-ditch mechanism for recovering the app; we must always be able\n  // to reload a fresh HTML document to get to a consistent state.\n  //\n  // In the future, there may be cases where the server intentionally sends\n  // partial data and expects the client to fill in the rest, in which case this\n  // logic may change. (There already is a similar case where the server sends\n  // _no_ hydration data in the HTML document at all, and the client fetches it\n  // separately, but that's different because we still end up hydrating with a\n  // complete tree.)\n\n  return task.node\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | null,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  const didFindRootLayout = false\n  const parentNeedsDynamicRequest = false\n  const parentRefreshUrl = null\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode !== null ? oldCacheNode : undefined,\n    oldRouterState,\n    newRouterState,\n    freshness,\n    didFindRootLayout,\n    seedData,\n    seedHead,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    null,\n    null,\n    parentNeedsDynamicRequest,\n    parentRefreshUrl,\n    accumulation\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | void,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  didFindRootLayout: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  parentRefreshUrl: string | null,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  // Check if this segment matches the one in the previous route.\n  const oldSegment = oldRouterState[0]\n  const newSegment = newRouterState[0]\n  if (!matchSegment(newSegment, oldSegment)) {\n    // This segment does not match the previous route. We're now entering the\n    // new part of the target route. Switch to the \"create\" path.\n    if (\n      // Check if the route tree changed before we reached a layout. (The\n      // highest-level layout in a route tree is referred to as the \"root\"\n      // layout.) This could mean that we're navigating between two different\n      // root layouts. When this happens, we perform a full-page (MPA-style)\n      // navigation.\n      //\n      // However, the algorithm for deciding where to start rendering a route\n      // (i.e. the one performed in order to reach this function) is stricter\n      // than the one used to detect a change in the root layout. So just\n      // because we're re-rendering a segment outside of the root layout does\n      // not mean we should trigger a full-page navigation.\n      //\n      // Specifically, we handle dynamic parameters differently: two segments\n      // are considered the same even if their parameter values are different.\n      //\n      // Refer to isNavigatingToNewRootLayout for details.\n      //\n      // Note that we only have to perform this extra traversal if we didn't\n      // already discover a root layout in the part of the tree that is\n      // unchanged. We also only need to compare the subtree that is not\n      // shared. In the common case, this branch is skipped completely.\n      (!didFindRootLayout &&\n        isNavigatingToNewRootLayout(oldRouterState, newRouterState)) ||\n      // The global Not Found route (app/global-not-found.tsx) is a special\n      // case, because it acts like a root layout, but in the router tree, it\n      // is rendered in the same position as app/layout.tsx.\n      //\n      // Any navigation to the global Not Found route should trigger a\n      // full-page navigation.\n      //\n      // TODO: We should probably model this by changing the key of the root\n      // segment when this happens. Then the root layout check would work\n      // as expected, without a special case.\n      newSegment === NOT_FOUND_SEGMENT_KEY\n    ) {\n      return null\n    }\n    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n      // The root should never mismatch. If it does, it suggests an internal\n      // Next.js error, or a malformed server response. Trigger a full-\n      // page navigation.\n      return null\n    }\n    return createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterState,\n      oldCacheNode,\n      freshness,\n      seedData,\n      seedHead,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      parentSegmentPath,\n      parentParallelRouteKey,\n      parentNeedsDynamicRequest,\n      accumulation\n    )\n  }\n\n  // TODO: The segment paths are tracked so that LayoutRouter knows which\n  // segments to scroll to after a navigation. But we should just mark this\n  // information on the CacheNode directly. It used to be necessary to do this\n  // separately because CacheNodes were created lazily during render, not when\n  // rather than when creating the route tree.\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const oldRouterStateChildren = oldRouterState[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  // We're currently traversing the part of the tree that was also part of\n  // the previous route. If we discover a root layout, then we don't need to\n  // trigger an MPA navigation.\n  const isRootLayout = newRouterState[4] === true\n  const childDidFindRootLayout = didFindRootLayout || isRootLayout\n\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n      // We should never drop dynamic data in shared layouts, except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n      shouldRefreshDynamicData = false\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      shouldDropSiblingCaches = true\n      shouldRefreshDynamicData = true\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n\n  // TODO: We're not consistent about how we do this check. Some places\n  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n  // check if there any any children, which is why I'm doing it here. We\n  // should probably encode an empty children set as `null` though. Either\n  // way, we should update all the checks to be consistent.\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  // Get the data for this segment. Since it was part of the previous route,\n  // usually we just clone the data from the old CacheNode. However, during a\n  // refresh or a revalidation, there won't be any existing CacheNode. So we\n  // may need to consult the prefetch cache, like we would for a new segment.\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (\n    oldCacheNode !== undefined &&\n    !shouldRefreshDynamicData &&\n    // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)\n  ) {\n    // Reuse the existing CacheNode\n    const dropPrefetchRsc = false\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = seedHead === null\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  // During a refresh navigation, there's a special case that happens when\n  // entering a \"default\" slot. The default slot may not be part of the\n  // current route; it may have been reused from an older route. If so,\n  // we need to fetch its data from the old route's URL rather than current\n  // route's URL. Keep track of this as we traverse the tree.\n  const href = newRouterState[2]\n  const refreshUrl =\n    typeof href === 'string' && newRouterState[3] === 'refresh'\n      ? // This segment is not present in the current route. Track its\n        // refresh URL as we continue traversing the tree.\n        href\n      : // Inherit the refresh URL from the parent.\n        parentRefreshUrl\n\n  // If this segment itself needs to fetch new data from the server, then by\n  // definition it is being refreshed. Track its refresh URL so we know which\n  // URL to request the data from.\n  if (needsDynamicRequest && refreshUrl !== null) {\n    accumulateRefreshUrl(accumulation, refreshUrl)\n  }\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let childNeedsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n  // at the end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    let newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    if (oldRouterStateChild === undefined) {\n      // This should never happen, but if it does, it suggests a malformed\n      // server response. Trigger a full-page navigation.\n      return null\n    }\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n\n    let seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    let prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    let newSegmentChild = newRouterStateChild[0]\n    let seedHeadChild = seedHead\n    let prefetchHeadChild = prefetchHead\n    let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n    if (\n      // Skip this branch during a history traversal. We restore the tree that\n      // was stashed in the history entry as-is.\n      freshness !== FreshnessPolicy.HistoryTraversal &&\n      newSegmentChild === DEFAULT_SEGMENT_KEY\n    ) {\n      // This is a \"default\" segment. These are never sent by the server during\n      // a soft navigation; instead, the client reuses whatever segment was\n      // already active in that slot on the previous route.\n      newRouterStateChild = reuseActiveSegmentInDefaultSlot(\n        oldUrl,\n        oldRouterStateChild\n      )\n      newSegmentChild = newRouterStateChild[0]\n\n      // Since we're switching to a different route tree, these are no\n      // longer valid, because they correspond to the outer tree.\n      seedDataChild = null\n      seedHeadChild = null\n      prefetchDataChild = null\n      prefetchHeadChild = null\n      isPrefetchHeadPartialChild = false\n    }\n\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = updateCacheNodeOnNavigation(\n      navigatedAt,\n      oldUrl,\n      oldCacheNodeChild,\n      oldRouterStateChild,\n      newRouterStateChild,\n      freshness,\n      childDidFindRootLayout,\n      seedDataChild ?? null,\n      seedHeadChild,\n      prefetchDataChild ?? null,\n      prefetchHeadChild,\n      isPrefetchHeadPartialChild,\n      isSamePageNavigation,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      refreshUrl,\n      accumulation\n    )\n\n    if (taskChild === null) {\n      // One of the child tasks discovered a change to the root layout.\n      // Immediately unwind from this recursive traversal. This will trigger a\n      // full-page navigation.\n      return null\n    }\n\n    // Recursively propagate up the child tasks.\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    // The child tree's route state may be different from the prefetched\n    // route sent by the server. We need to clone it as we traverse back up\n    // the tree.\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      // Something in the child tree is dynamic.\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    refreshUrl,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  newRouterState: FlightRouterState,\n  oldCacheNode: CacheNode | void,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n  // path once we reach the part of the tree that was not in the previous route.\n  // We don't need to diff against the old tree, we just need to create a new\n  // one. We also don't need to worry about any refresh-related logic.\n  //\n  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n  // change that happens in this function likely needs to be applied to that\n  // one, too. However there are some places where the behavior intentionally\n  // diverges, which is why we keep them separate.\n\n  const newSegment = newRouterState[0]\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  let dropPrefetchRsc: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n      // We should never drop dynamic data in sibling caches except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n\n      // Only reuse the dynamic data if experimental.staleTimes.dynamic config\n      // is set, and the data is not stale. (This is not a recommended API with\n      // Cache Components, but it's supported for backwards compatibility. Use\n      // cacheLife instead.)\n      //\n      // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased.\n      shouldRefreshDynamicData =\n        oldCacheNode === undefined ||\n        navigatedAt - oldCacheNode.navigatedAt >= DYNAMIC_STALETIME_MS\n\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.Hydration:\n      // During hydration, we assume the data sent by the server is both\n      // consistent and complete.\n      shouldRefreshDynamicData = false\n      shouldDropSiblingCaches = false\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.HistoryTraversal:\n      // During back/forward navigations, we reuse the dynamic data regardless\n      // of how stale it may be.\n      shouldRefreshDynamicData = false\n      shouldRefreshDynamicData = false\n\n      // Only show prefetched data if the dynamic data is still pending. This\n      // avoids a flash back to the prefetch state in a case where it's highly\n      // likely to have already streamed in.\n      //\n      // Tehnically, what we're actually checking is whether the dynamic network\n      // response was received. But since it's a streaming response, this does\n      // not mean that all the dynamic data has fully streamed in. It just means\n      // that _some_ of the dynamic data was received. But as a heuristic, we\n      // assume that the rest dynamic data will stream in quickly, so it's still\n      // better to skip the prefetch state.\n      if (oldCacheNode !== undefined) {\n        const oldRsc = oldCacheNode.rsc\n        const oldRscDidResolve =\n          !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending'\n        dropPrefetchRsc = oldRscDidResolve\n      } else {\n        dropPrefetchRsc = false\n      }\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      // Drop all dynamic data.\n      shouldRefreshDynamicData = true\n      shouldDropSiblingCaches = true\n      dropPrefetchRsc = false\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    //\n    // This only happens for new pages, not for refreshed pages.\n    //\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    if (accumulation.scrollableSegments === null) {\n      accumulation.scrollableSegments = []\n    }\n    accumulation.scrollableSegments.push(segmentPath)\n  }\n\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n    // Reuse the existing CacheNode\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial =\n      seedHead === null && freshness !== FreshnessPolicy.Hydration\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (\n    freshness === FreshnessPolicy.Hydration &&\n    isLeafSegment &&\n    seedHead !== null\n  ) {\n    // This is another weird case related to \"not found\" pages and hydration.\n    // There will be a head sent by the server, but no page seed data.\n    // TODO: We really should get rid of all these \"not found\" specific quirks\n    // and make sure the tree is always consistent.\n    const seedRsc = null\n    const seedLoading = null\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = false\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = false\n  } else if (freshness !== FreshnessPolicy.Hydration && prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  let childNeedsDynamicRequest = false\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n    const seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterStateChild,\n      oldCacheNodeChild,\n      freshness,\n      seedDataChild ?? null,\n      seedHead,\n      prefetchDataChild ?? null,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      accumulation\n    )\n\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    // This route is not part of the current tree, so there's no reason to\n    // track the refresh URL.\n    refreshUrl: null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction createDynamicRequestTree(\n  newRouterState: FlightRouterState,\n  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n  needsDynamicRequest: boolean,\n  childNeedsDynamicRequest: boolean,\n  parentNeedsDynamicRequest: boolean\n): FlightRouterState | null {\n  // Create a FlightRouterState that instructs the server how to render the\n  // requested segment.\n  //\n  // Or, if neither this segment nor any of the children require a new data,\n  // then we return `null` to skip the request.\n  let dynamicRequestTree: FlightRouterState | null = null\n  if (needsDynamicRequest) {\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n    // The \"refetch\" marker is set on the top-most segment that requires new\n    // data. We can omit it if a parent was already marked.\n    if (!parentNeedsDynamicRequest) {\n      dynamicRequestTree[3] = 'refetch'\n    }\n  } else if (childNeedsDynamicRequest) {\n    // This segment does not request new data, but at least one of its\n    // children does.\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n  } else {\n    dynamicRequestTree = null\n  }\n  return dynamicRequestTree\n}\n\nfunction accumulateRefreshUrl(\n  accumulation: NavigationRequestAccumulation,\n  refreshUrl: string\n) {\n  // This is a refresh navigation, and we're inside a \"default\" slot that's\n  // not part of the current route; it was reused from an older route. In\n  // order to get fresh data for this reused route, we need to issue a\n  // separate request using the old route's URL.\n  //\n  // Track these extra URLs in the accumulated result. Later, we'll construct\n  // an appropriate request for each unique URL in the final set. The reason\n  // we don't do it immediately here is so we can deduplicate multiple\n  // instances of the same URL into a single request. See\n  // listenForDynamicRequest for more details.\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    accumulation.separateRefreshUrls = new Set([refreshUrl])\n  } else {\n    separateRefreshUrls.add(refreshUrl)\n  }\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): FlightRouterState {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return reusedRouterState\n}\n\nfunction reuseDynamicCacheNode(\n  dropPrefetchRsc: boolean,\n  existingCacheNode: CacheNode,\n  parallelRoutes: Map<string, ChildSegmentMap>\n): CacheNode {\n  // Clone an existing CacheNode's data, with (possibly) new children.\n  const cacheNode: CacheNode = {\n    rsc: existingCacheNode.rsc,\n    prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n    head: existingCacheNode.head,\n    prefetchHead: dropPrefetchRsc ? null : existingCacheNode.prefetchHead,\n    loading: existingCacheNode.loading,\n\n    parallelRoutes,\n\n    // Don't update the navigatedAt timestamp, since we're reusing\n    // existing data.\n    navigatedAt: existingCacheNode.navigatedAt,\n  }\n  return cacheNode\n}\n\nfunction readCacheNodeFromSeedData(\n  seedRsc: React.ReactNode,\n  seedLoading: LoadingModuleData | Promise<LoadingModuleData>,\n  isSeedRscPartial: boolean,\n  seedHead: HeadData | null,\n  isSeedHeadPartial: boolean,\n  isPageSegment: boolean,\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  navigatedAt: number\n): CacheNode {\n  // TODO: Currently this is threaded through the navigation logic using the\n  // CacheNodeSeedData type, but in the future this will read directly from\n  // the Segment Cache. See readRenderSnapshotFromCache.\n\n  let rsc: React.ReactNode\n  let prefetchRsc: React.ReactNode\n  if (isSeedRscPartial) {\n    // The prefetched data contains dynamic holes. Create a pending promise that\n    // will be fulfilled when the dynamic data is received from the server.\n    prefetchRsc = seedRsc\n    rsc = createDeferredRsc()\n  } else {\n    // The prefetched data is complete. Use it directly.\n    prefetchRsc = null\n    rsc = seedRsc\n  }\n\n  // If this is a page segment, also read the head.\n  let prefetchHead: HeadData | null\n  let head: HeadData | null\n  if (isPageSegment) {\n    if (isSeedHeadPartial) {\n      prefetchHead = seedHead\n      head = createDeferredRsc()\n    } else {\n      prefetchHead = null\n      head = seedHead\n    }\n  } else {\n    prefetchHead = null\n    head = null\n  }\n\n  const cacheNode: CacheNode = {\n    rsc,\n    prefetchRsc,\n    head,\n    prefetchHead,\n    // TODO: Technically, a loading boundary could contain dynamic data. We\n    // should have separate `loading` and `prefetchLoading` fields to handle\n    // this, like we do for the segment data and head.\n    loading: seedLoading,\n    parallelRoutes,\n    navigatedAt,\n  }\n\n  return cacheNode\n}\n\nfunction spawnNewCacheNode(\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  isLeafSegment: boolean,\n  navigatedAt: number,\n  freshness: FreshnessPolicy\n): CacheNode {\n  // We should never spawn network requests during hydration. We must treat the\n  // initial payload as authoritative, because the initial page load is used\n  // as a last-ditch mechanism for recovering the app.\n  //\n  // This is also an important safety check because if this leaks into the\n  // server rendering path (which theoretically it never should because\n  // the server payload should be consistent), the server would hang because\n  // these promises would never resolve.\n  //\n  // TODO: There is an existing case where the global \"not found\" boundary\n  // triggers this path. But it does render correctly despite that. That's an\n  // unusual render path so it's not surprising, but we should look into\n  // modeling it in a more consistent way. See also the /_notFound special\n  // case in updateCacheNodeOnNavigation.\n  const isHydration = freshness === FreshnessPolicy.Hydration\n\n  const cacheNode: CacheNode = {\n    rsc: !isHydration ? createDeferredRsc() : null,\n    prefetchRsc: null,\n    head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n    prefetchHead: null,\n    loading: !isHydration ? createDeferredRsc<LoadingModuleData>() : null,\n    parallelRoutes,\n    navigatedAt,\n  }\n  return cacheNode\n}\n\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function spawnDynamicRequests(\n  task: NavigationTask,\n  primaryUrl: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  accumulation: NavigationRequestAccumulation\n): void {\n  const dynamicRequestTree = task.dynamicRequestTree\n  if (dynamicRequestTree === null) {\n    // This navigation was fully cached. There are no dynamic requests to spawn.\n    previousNavigationDidMismatch = false\n    return\n  }\n\n  // This is intentionally not an async function to discourage the caller from\n  // awaiting the result. Any subsequent async operations spawned by this\n  // function should result in a separate navigation task, rather than\n  // block the original one.\n  //\n  // In this function we spawn (but do not await) all the network requests that\n  // block the navigation, and collect the promises. The next function,\n  // `finishNavigationTask`, can await the promises in any order without\n  // accidentally introducing a network waterfall.\n  const primaryRequestPromise = fetchMissingDynamicData(\n    task,\n    dynamicRequestTree,\n    primaryUrl,\n    nextUrl,\n    freshnessPolicy\n  )\n\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  let refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null = null\n  if (separateRefreshUrls !== null) {\n    // There are multiple URLs that we need to request the data from. This\n    // happens when a \"default\" parallel route slot is present in the tree, and\n    // its data cannot be fetched from the current route. We need to split the\n    // combined dynamic request tree into separate requests per URL.\n\n    // TODO: Create a scoped dynamic request tree that omits anything that\n    // is not relevant to the given URL. Without doing this, the server may\n    // sometimes render more data than necessary; this is not a regression\n    // compared to the pre-Segment Cache implementation, though, just an\n    // optimization we can make in the future.\n\n    // Construct a request tree for each additional refresh URL. This will\n    // prune away everything except the parts of the tree that match the\n    // given refresh URL.\n    refreshRequestPromises = []\n    const canonicalUrl = createHrefFromUrl(primaryUrl)\n    for (const refreshUrl of separateRefreshUrls) {\n      if (refreshUrl === canonicalUrl) {\n        // We already initiated a request for the this URL, above. Skip it.\n        // TODO: This only happens because the main URL is not tracked as\n        // part of the separateRefreshURLs set. There's probably a better way\n        // to structure this so this case doesn't happen.\n        continue\n      }\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n      const scopedDynamicRequestTree = dynamicRequestTree\n      if (scopedDynamicRequestTree !== null) {\n        refreshRequestPromises.push(\n          fetchMissingDynamicData(\n            task,\n            scopedDynamicRequestTree,\n            new URL(refreshUrl, location.origin),\n            // TODO: Just noticed that this should actually the Next-Url at the\n            // time the refresh URL was set, not the current Next-Url. Need to\n            // start tracking this alongside the refresh URL. In the meantime,\n            // if a refresh fails due to a mismatch, it will trigger a\n            // hard refresh.\n            nextUrl,\n            freshnessPolicy\n          )\n        )\n      }\n    }\n  }\n\n  // Further async operations are moved into this separate function to\n  // discourage sequential network requests.\n  const voidPromise = finishNavigationTask(\n    task,\n    nextUrl,\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n  // `finishNavigationTask` is responsible for error handling, so we can attach\n  // noop callbacks to this promise.\n  voidPromise.then(noop, noop)\n}\n\nasync function finishNavigationTask(\n  task: NavigationTask,\n  nextUrl: string | null,\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n): Promise<void> {\n  // Wait for all the requests to finish, or for the first one to fail.\n  let exitStatus = await waitForRequestsToFinish(\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n\n  // Once the all the requests have finished, check the tree for any remaining\n  // pending tasks. If anything is still pending, it means the server response\n  // does not match the client, and we must refresh to get back to a consistent\n  // state. We can skip this step if we already detected a mismatch during the\n  // first phase; it doesn't matter in that case because we're going to refresh\n  // the whole tree regardless.\n  if (exitStatus === NavigationTaskExitStatus.Done) {\n    exitStatus = abortRemainingPendingTasks(task, null, null)\n  }\n\n  switch (exitStatus) {\n    case NavigationTaskExitStatus.Done: {\n      // The task has completely finished. There's no missing data. Exit.\n      previousNavigationDidMismatch = false\n      return\n    }\n    case NavigationTaskExitStatus.SoftRetry: {\n      // Some data failed to finish loading. Trigger a soft retry.\n      // TODO: As an extra precaution against soft retry loops, consider\n      // tracking whether a navigation was itself triggered by a retry. If two\n      // happen in a row, fall back to a hard retry.\n      const isHardRetry = false\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    case NavigationTaskExitStatus.HardRetry: {\n      // Some data failed to finish loading in a non-recoverable way, such as a\n      // network error. Trigger an MPA navigation.\n      //\n      // Hard navigating/refreshing is how we prevent an infinite retry loop\n      // caused by a network error — when the network fails, we fall back to the\n      // browser behavior for offline navigations. In the future, Next.js may\n      // introduce its own custom handling of offline navigations, but that\n      // doesn't exist yet.\n      const isHardRetry = true\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    default: {\n      return exitStatus satisfies never\n    }\n  }\n}\n\nfunction waitForRequestsToFinish(\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n) {\n  // Custom async combinator logic. This could be replaced by Promise.any but\n  // we don't assume that's available.\n  //\n  // Each promise resolves once the server responsds and the data is written\n  // into the CacheNode tree. Resolve the combined promise once all the\n  // requests finish.\n  //\n  // Or, resolve as soon as one of the requests fails, without waiting for the\n  // others to finish.\n  return new Promise<NavigationTaskExitStatus>((resolve) => {\n    const onFulfill = (result: { exitStatus: NavigationTaskExitStatus }) => {\n      if (result.exitStatus === NavigationTaskExitStatus.Done) {\n        remainingCount--\n        if (remainingCount === 0) {\n          // All the requests finished successfully.\n          resolve(NavigationTaskExitStatus.Done)\n        }\n      } else {\n        // One of the requests failed. Exit with a failing status.\n        // NOTE: It's possible for one of the requests to fail with SoftRetry\n        // and a later one to fail with HardRetry. In this case, we choose to\n        // retry immediately, rather than delay the retry until all the requests\n        // finish. If it fails again, we will hard retry on the next\n        // attempt, anyway.\n        resolve(result.exitStatus)\n      }\n    }\n    // onReject shouldn't ever be called because fetchMissingDynamicData's\n    // entire body is wrapped in a try/catch. This is just defensive.\n    const onReject = () => resolve(NavigationTaskExitStatus.HardRetry)\n\n    // Attach the listeners to the promises.\n    let remainingCount = 1\n    primaryRequestPromise.then(onFulfill, onReject)\n    if (refreshRequestPromises !== null) {\n      remainingCount += refreshRequestPromises.length\n      refreshRequestPromises.forEach((refreshRequestPromise) =>\n        refreshRequestPromise.then(onFulfill, onReject)\n      )\n    }\n  })\n}\n\nfunction dispatchRetryDueToTreeMismatch(\n  isHardRetry: boolean,\n  retryUrl: URL,\n  retryNextUrl: string | null,\n  seed: NavigationSeed | null,\n  baseTree: FlightRouterState\n) {\n  // If this is the second time in a row that a navigation resulted in a\n  // mismatch, fall back to a hard (MPA) refresh.\n  isHardRetry = isHardRetry || previousNavigationDidMismatch\n  previousNavigationDidMismatch = true\n  const retryAction: ServerPatchAction = {\n    type: ACTION_SERVER_PATCH,\n    previousTree: baseTree,\n    url: retryUrl,\n    nextUrl: retryNextUrl,\n    seed,\n    mpa: isHardRetry,\n  }\n  dispatchAppRouterAction(retryAction)\n}\n\nasync function fetchMissingDynamicData(\n  task: NavigationTask,\n  dynamicRequestTree: FlightRouterState,\n  url: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy\n): Promise<{\n  exitStatus: NavigationTaskExitStatus\n  url: URL\n  seed: NavigationSeed | null\n}> {\n  try {\n    const result = await fetchServerResponse(url, {\n      flightRouterState: dynamicRequestTree,\n      nextUrl,\n      isHmrRefresh: freshnessPolicy === FreshnessPolicy.HMRRefresh,\n    })\n    if (typeof result === 'string') {\n      // fetchServerResponse will return an href to indicate that the SPA\n      // navigation failed. For example, if the server triggered a hard\n      // redirect, or the fetch request errored. Initiate an MPA navigation\n      // to the given href.\n      return {\n        exitStatus: NavigationTaskExitStatus.HardRetry,\n        url: new URL(result, location.origin),\n        seed: null,\n      }\n    }\n    const seed = convertServerPatchToFullTree(\n      task.route,\n      result.flightData,\n      result.renderedSearch\n    )\n    const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(\n      task,\n      seed.tree,\n      seed.data,\n      seed.head,\n      result.debugInfo\n    )\n    return {\n      exitStatus: didReceiveUnknownParallelRoute\n        ? NavigationTaskExitStatus.SoftRetry\n        : NavigationTaskExitStatus.Done,\n      url: new URL(result.canonicalUrl, location.origin),\n      seed,\n    }\n  } catch {\n    // This shouldn't happen because fetchServerResponse's entire body is\n    // wrapped in a try/catch. If it does, though, it implies the server failed\n    // to respond with any tree at all. So we must fall back to a hard retry.\n    return {\n      exitStatus: NavigationTaskExitStatus.HardRetry,\n      url: url,\n      seed: null,\n    }\n  }\n}\n\nfunction writeDynamicDataIntoNavigationTask(\n  task: NavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData | null,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): boolean {\n  if (task.status === NavigationTaskStatus.Pending && dynamicData !== null) {\n    task.status = NavigationTaskStatus.Fulfilled\n    finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo)\n  }\n\n  const taskChildren = task.children\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null\n\n  // Detect whether the server sends a parallel route slot that the client\n  // doesn't know about.\n  let didReceiveUnknownParallelRoute = false\n\n  if (taskChildren !== null) {\n    for (const parallelRouteKey in serverChildren) {\n      const serverRouterStateChild: FlightRouterState =\n        serverChildren[parallelRouteKey]\n      const dynamicDataChild: CacheNodeSeedData | null | void =\n        dynamicDataChildren !== null\n          ? dynamicDataChildren[parallelRouteKey]\n          : null\n\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild === undefined) {\n        // The server sent a child segment that the client doesn't know about.\n        //\n        // When we receive an unknown parallel route, we must consider it a\n        // mismatch. This is unlike the case where the segment itself\n        // mismatches, because multiple routes can be active simultaneously.\n        // But a given layout should never have a mismatching set of\n        // child slots.\n        //\n        // Theoretically, this should only happen in development during an HMR\n        // refresh, because the set of parallel routes for a layout does not\n        // change over the lifetime of a build/deployment. In production, we\n        // should have already mismatched on either the build id or the segment\n        // path. But as an extra precaution, we validate in prod, too.\n        didReceiveUnknownParallelRoute = true\n      } else {\n        const taskSegment = taskChild.route[0]\n        if (\n          matchSegment(serverRouterStateChild[0], taskSegment) &&\n          dynamicDataChild !== null &&\n          dynamicDataChild !== undefined\n        ) {\n          // Found a match for this task. Keep traversing down the task tree.\n          const childDidReceiveUnknownParallelRoute =\n            writeDynamicDataIntoNavigationTask(\n              taskChild,\n              serverRouterStateChild,\n              dynamicDataChild,\n              dynamicHead,\n              debugInfo\n            )\n          if (childDidReceiveUnknownParallelRoute) {\n            didReceiveUnknownParallelRoute = true\n          }\n        }\n      }\n    }\n  }\n\n  return didReceiveUnknownParallelRoute\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n\n  if (dynamicSegmentData === null) {\n    // This is an empty CacheNode; this particular server request did not\n    // render this segment. There may be a separate pending request that will,\n    // though, so we won't abort the task until all pending requests finish.\n    return\n  }\n\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nfunction abortRemainingPendingTasks(\n  task: NavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): NavigationTaskExitStatus {\n  let exitStatus\n  if (task.status === NavigationTaskStatus.Pending) {\n    // The data for this segment is still missing.\n    task.status = NavigationTaskStatus.Rejected\n    abortPendingCacheNode(task.node, error, debugInfo)\n\n    // If the server failed to fulfill the data for this segment, it implies\n    // that the route tree received from the server mismatched the tree that\n    // was previously prefetched.\n    //\n    // In an app with fully static routes and no proxy-driven redirects or\n    // rewrites, this should never happen, because the route for a URL would\n    // always be the same across multiple requests. So, this implies that some\n    // runtime routing condition changed, likely in a proxy, without being\n    // pushed to the client.\n    //\n    // When this happens, we treat this the same as a refresh(). The entire\n    // tree will be re-rendered from the root.\n    if (task.refreshUrl === null) {\n      // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n      // in a Server Action.\n      exitStatus = NavigationTaskExitStatus.SoftRetry\n    } else {\n      // The mismatch was discovered inside an inactive parallel route. This\n      // implies the inactive parallel route is no longer reachable at the URL\n      // that originally rendered it. Fall back to an MPA refresh.\n      // TODO: An alternative could be to trigger a soft refresh but to _not_\n      // re-use the inactive parallel routes this time. Similar to what would\n      // happen if were to do a hard refrehs, but without the HTML page.\n      exitStatus = NavigationTaskExitStatus.HardRetry\n    }\n  } else {\n    // This segment finished. (An error here is treated as Done because they are\n    // surfaced to the application during render.)\n    exitStatus = NavigationTaskExitStatus.Done\n  }\n\n  const taskChildren = task.children\n  if (taskChildren !== null) {\n    for (const [, taskChild] of taskChildren) {\n      const childExitStatus = abortRemainingPendingTasks(\n        taskChild,\n        error,\n        debugInfo\n      )\n      // Propagate the exit status up the tree. The statuses are ordered by\n      // their precedence.\n      if (childExitStatus > exitStatus) {\n        exitStatus = childExitStatus\n      }\n    }\n  }\n\n  return exitStatus\n}\n\nfunction abortPendingCacheNode(\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nexport function isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n","import { fetchServerResponse } from '../router-reducer/fetch-server-response';\nimport { startPPRNavigation, spawnDynamicRequests, FreshnessPolicy } from '../router-reducer/ppr-navigations';\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url';\nimport { EntryStatus, readRouteCacheEntry, readSegmentCacheEntry, waitForSegmentCacheEntry, requestOptimisticRouteCacheEntry } from './cache';\nimport { createCacheKey } from './cache-key';\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment';\nimport { NavigationResultTag } from './types';\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */ export function navigate(url, currentUrl, currentCacheNode, currentFlightRouterState, nextUrl, freshnessPolicy, shouldScroll, accumulation) {\n    const now = Date.now();\n    const href = url.href;\n    // We special case navigations to the exact same URL as the current location.\n    // It's a common UI pattern for apps to refresh when you click a link to the\n    // current page. So when this happens, we refresh the dynamic data in the page\n    // segments.\n    //\n    // Note that this does not apply if the any part of the hash or search query\n    // has changed. This might feel a bit weird but it makes more sense when you\n    // consider that the way to trigger this behavior is to click the same link\n    // multiple times.\n    //\n    // TODO: We should probably refresh the *entire* route when this case occurs,\n    // not just the page segments. Essentially treating it the same as a refresh()\n    // triggered by an action, which is the more explicit way of modeling the UI\n    // pattern described above.\n    //\n    // Also note that this only refreshes the dynamic data, not static/ cached\n    // data. If the page segment is fully static and prefetched, the request is\n    // skipped. (This is also how refresh() works.)\n    const isSamePageNavigation = href === currentUrl.href;\n    const cacheKey = createCacheKey(href, nextUrl);\n    const route = readRouteCacheEntry(now, cacheKey);\n    if (route !== null && route.status === EntryStatus.Fulfilled) {\n        // We have a matching prefetch.\n        const snapshot = readRenderSnapshotFromCache(now, route, route.tree);\n        const prefetchFlightRouterState = snapshot.flightRouterState;\n        const prefetchSeedData = snapshot.seedData;\n        const headSnapshot = readHeadSnapshotFromCache(now, route);\n        const prefetchHead = headSnapshot.rsc;\n        const isPrefetchHeadPartial = headSnapshot.isPartial;\n        // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n        // because hash entries do not vary by hash fragment. However, the one\n        // we set in the router state *does* include the hash, and it's used to\n        // sync with the actual browser location. To make this less of a refactor\n        // hazard, we should always track the hash separately from the rest of\n        // the URL.\n        const newCanonicalUrl = route.canonicalUrl + url.hash;\n        const renderedSearch = route.renderedSearch;\n        return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, renderedSearch, freshnessPolicy, shouldScroll);\n    }\n    // There was no matching route tree in the cache. Let's see if we can\n    // construct an \"optimistic\" route tree.\n    //\n    // Do not construct an optimistic route tree if there was a cache hit, but\n    // the entry has a rejected status, since it may have been rejected due to a\n    // rewrite or redirect based on the search params.\n    //\n    // TODO: There are multiple reasons a prefetch might be rejected; we should\n    // track them explicitly and choose what to do here based on that.\n    if (route === null || route.status !== EntryStatus.Rejected) {\n        const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl);\n        if (optimisticRoute !== null) {\n            // We have an optimistic route tree. Proceed with the normal flow.\n            const snapshot = readRenderSnapshotFromCache(now, optimisticRoute, optimisticRoute.tree);\n            const prefetchFlightRouterState = snapshot.flightRouterState;\n            const prefetchSeedData = snapshot.seedData;\n            const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute);\n            const prefetchHead = headSnapshot.rsc;\n            const isPrefetchHeadPartial = headSnapshot.isPartial;\n            const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash;\n            const newRenderedSearch = optimisticRoute.renderedSearch;\n            return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, newRenderedSearch, freshnessPolicy, shouldScroll);\n        }\n    }\n    // There's no matching prefetch for this route in the cache.\n    let collectedDebugInfo = accumulation.collectedDebugInfo ?? [];\n    if (accumulation.collectedDebugInfo === undefined) {\n        collectedDebugInfo = accumulation.collectedDebugInfo = [];\n    }\n    return {\n        tag: NavigationResultTag.Async,\n        data: navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, shouldScroll, collectedDebugInfo)\n    };\n}\nexport function navigateToSeededRoute(now, url, canonicalUrl, navigationSeed, currentUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll) {\n    // A version of navigate() that accepts the target route tree as an argument\n    // rather than reading it from the prefetch cache.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const isSamePageNavigation = url.href === currentUrl.href;\n    const task = startPPRNavigation(now, currentUrl, currentCacheNode, currentFlightRouterState, navigationSeed.tree, freshnessPolicy, navigationSeed.data, navigationSeed.head, null, null, false, isSamePageNavigation, accumulation);\n    if (task !== null) {\n        spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation);\n        return navigationTaskToResult(task, canonicalUrl, navigationSeed.renderedSearch, accumulation.scrollableSegments, shouldScroll, url.hash);\n    }\n    // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n    return {\n        tag: NavigationResultTag.MPA,\n        data: canonicalUrl\n    };\n}\nfunction navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, canonicalUrl, renderedSearch, freshnessPolicy, shouldScroll) {\n    // Recursively construct a prefetch tree by reading from the Segment Cache. To\n    // maintain compatibility, we output the same data structures as the old\n    // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n    // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n    // read from the Segment Cache directly. It's only structured this way for now\n    // so we can share code with the old prefetching implementation.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const seedData = null;\n    const seedHead = null;\n    const task = startPPRNavigation(now, currentUrl, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, freshnessPolicy, seedData, seedHead, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, accumulation);\n    if (task !== null) {\n        spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation);\n        return navigationTaskToResult(task, canonicalUrl, renderedSearch, accumulation.scrollableSegments, shouldScroll, url.hash);\n    }\n    // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n    return {\n        tag: NavigationResultTag.MPA,\n        data: canonicalUrl\n    };\n}\nfunction navigationTaskToResult(task, canonicalUrl, renderedSearch, scrollableSegments, shouldScroll, hash) {\n    return {\n        tag: NavigationResultTag.Success,\n        data: {\n            flightRouterState: task.route,\n            cacheNode: task.node,\n            canonicalUrl,\n            renderedSearch,\n            scrollableSegments,\n            shouldScroll,\n            hash\n        }\n    };\n}\nfunction readRenderSnapshotFromCache(now, route, tree) {\n    let childRouterStates = {};\n    let childSeedDatas = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childResult = readRenderSnapshotFromCache(now, route, childTree);\n            childRouterStates[parallelRouteKey] = childResult.flightRouterState;\n            childSeedDatas[parallelRouteKey] = childResult.seedData;\n        }\n    }\n    let rsc = null;\n    let loading = null;\n    let isPartial = true;\n    const segmentEntry = readSegmentCacheEntry(now, tree.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case EntryStatus.Fulfilled:\n                {\n                    // Happy path: a cache hit\n                    rsc = segmentEntry.rsc;\n                    loading = segmentEntry.loading;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case EntryStatus.Pending:\n                {\n                    // We haven't received data for this segment yet, but there's already\n                    // an in-progress request. Since it's extremely likely to arrive\n                    // before the dynamic data response, we might as well use it.\n                    const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    loading = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.loading : null);\n                    // Because the request is still pending, we typically don't know yet\n                    // whether the response will be partial. We shouldn't skip this segment\n                    // during the dynamic navigation request. Otherwise, we might need to\n                    // do yet another request to fill in the remaining data, creating\n                    // a waterfall.\n                    //\n                    // The one exception is if this segment is being fetched with via\n                    // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n                    // we can assume the response will be full. This field is set to `false`\n                    // for such segments.\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case EntryStatus.Empty:\n            case EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    // The navigation implementation expects the search params to be\n    // included in the segment. However, the Segment Cache tracks search\n    // params separately from the rest of the segment key. So we need to\n    // add them back here.\n    //\n    // See corresponding comment in convertFlightRouterStateToTree.\n    //\n    // TODO: What we should do instead is update the navigation diffing\n    // logic to compare search params explicitly. This is a temporary\n    // solution until more of the Segment Cache implementation has settled.\n    const segment = addSearchParamsIfPageSegment(tree.segment, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    // We don't need this information in a render snapshot, so this can just be a placeholder.\n    const hasRuntimePrefetch = false;\n    return {\n        flightRouterState: [\n            segment,\n            childRouterStates,\n            null,\n            null,\n            tree.isRootLayout\n        ],\n        seedData: [\n            rsc,\n            childSeedDatas,\n            loading,\n            isPartial,\n            hasRuntimePrefetch\n        ]\n    };\n}\nfunction readHeadSnapshotFromCache(now, route) {\n    // Same as readRenderSnapshotFromCache, but for the head\n    let rsc = null;\n    let isPartial = true;\n    const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case EntryStatus.Fulfilled:\n                {\n                    rsc = segmentEntry.rsc;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case EntryStatus.Pending:\n                {\n                    const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case EntryStatus.Empty:\n            case EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    return {\n        rsc,\n        isPartial\n    };\n}\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute = [\n    '',\n    {},\n    null,\n    'refetch'\n];\nasync function navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, shouldScroll, collectedDebugInfo) {\n    // Runs when a navigation happens but there's no cached prefetch we can use.\n    // Don't bother to wait for a prefetch response; go straight to a full\n    // navigation that contains both static and dynamic data in a single stream.\n    // (This is unlike the old navigation implementation, which instead blocks\n    // the dynamic request until a prefetch request is received.)\n    //\n    // To avoid duplication of logic, we're going to pretend that the tree\n    // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n    // use the same server response to write the actual data into the CacheNode\n    // tree. So it's the same flow as the \"happy path\" (prefetch, then\n    // navigation), except we use a single server response for both stages.\n    let dynamicRequestTree;\n    switch(freshnessPolicy){\n        case FreshnessPolicy.Default:\n        case FreshnessPolicy.HistoryTraversal:\n            dynamicRequestTree = currentFlightRouterState;\n            break;\n        case FreshnessPolicy.Hydration:\n        case FreshnessPolicy.RefreshAll:\n        case FreshnessPolicy.HMRRefresh:\n            dynamicRequestTree = DynamicRequestTreeForEntireRoute;\n            break;\n        default:\n            freshnessPolicy;\n            dynamicRequestTree = currentFlightRouterState;\n            break;\n    }\n    const promiseForDynamicServerResponse = fetchServerResponse(url, {\n        flightRouterState: dynamicRequestTree,\n        nextUrl\n    });\n    const result = await promiseForDynamicServerResponse;\n    if (typeof result === 'string') {\n        // This is an MPA navigation.\n        const newUrl = result;\n        return {\n            tag: NavigationResultTag.MPA,\n            data: newUrl\n        };\n    }\n    const { flightData, canonicalUrl, renderedSearch, debugInfo: debugInfoFromResponse } = result;\n    if (debugInfoFromResponse !== null) {\n        collectedDebugInfo.push(...debugInfoFromResponse);\n    }\n    // Since the response format of dynamic requests and prefetches is slightly\n    // different, we'll need to massage the data a bit. Create FlightRouterState\n    // tree that simulates what we'd receive as the result of a prefetch.\n    const navigationSeed = convertServerPatchToFullTree(currentFlightRouterState, flightData, renderedSearch);\n    return navigateToSeededRoute(now, url, createHrefFromUrl(canonicalUrl), navigationSeed, currentUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll);\n}\nexport function convertServerPatchToFullTree(currentTree, flightData, renderedSearch) {\n    // During a client navigation or prefetch, the server sends back only a patch\n    // for the parts of the tree that have changed.\n    //\n    // This applies the patch to the base tree to create a full representation of\n    // the resulting tree.\n    //\n    // The return type includes a full FlightRouterState tree and a full\n    // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n    // eventually be unified, but there's still lots of existing code that\n    // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n    //\n    // TODO: This similar to what apply-router-state-patch-to-tree does. It\n    // will eventually fully replace it. We should get rid of all the remaining\n    // places where we iterate over the server patch format. This should also\n    // eventually replace normalizeFlightData.\n    let baseTree = currentTree;\n    let baseData = null;\n    let head = null;\n    for (const { segmentPath, tree: treePatch, seedData: dataPatch, head: headPatch } of flightData){\n        const result = convertServerPatchToFullTreeImpl(baseTree, baseData, treePatch, dataPatch, segmentPath, 0);\n        baseTree = result.tree;\n        baseData = result.data;\n        // This is the same for all patches per response, so just pick an\n        // arbitrary one\n        head = headPatch;\n    }\n    return {\n        tree: baseTree,\n        data: baseData,\n        renderedSearch,\n        head\n    };\n}\nfunction convertServerPatchToFullTreeImpl(baseRouterState, baseData, treePatch, dataPatch, segmentPath, index) {\n    if (index === segmentPath.length) {\n        // We reached the part of the tree that we need to patch.\n        return {\n            tree: treePatch,\n            data: dataPatch\n        };\n    }\n    // segmentPath represents the parent path of subtree. It's a repeating\n    // pattern of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // This path tells us which part of the base tree to apply the tree patch.\n    //\n    // NOTE: We receive the FlightRouterState patch in the same request as the\n    // seed data patch. Therefore we don't need to worry about diffing the segment\n    // values; we can assume the server sent us a correct result.\n    const updatedParallelRouteKey = segmentPath[index];\n    // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n    const baseTreeChildren = baseRouterState[1];\n    const baseSeedDataChildren = baseData !== null ? baseData[1] : null;\n    const newTreeChildren = {};\n    const newSeedDataChildren = {};\n    for(const parallelRouteKey in baseTreeChildren){\n        const childBaseRouterState = baseTreeChildren[parallelRouteKey];\n        const childBaseSeedData = baseSeedDataChildren !== null ? baseSeedDataChildren[parallelRouteKey] ?? null : null;\n        if (parallelRouteKey === updatedParallelRouteKey) {\n            const result = convertServerPatchToFullTreeImpl(childBaseRouterState, childBaseSeedData, treePatch, dataPatch, segmentPath, // Advance the index by two and keep cloning until we reach\n            // the end of the segment path.\n            index + 2);\n            newTreeChildren[parallelRouteKey] = result.tree;\n            newSeedDataChildren[parallelRouteKey] = result.data;\n        } else {\n            // This child is not being patched. Copy it over as-is.\n            newTreeChildren[parallelRouteKey] = childBaseRouterState;\n            newSeedDataChildren[parallelRouteKey] = childBaseSeedData;\n        }\n    }\n    let clonedTree;\n    let clonedSeedData;\n    // Clone all the fields except the children.\n    // Clone the FlightRouterState tree. Based on equivalent logic in\n    // apply-router-state-patch-to-tree, but should confirm whether we need to\n    // copy all of these fields. Not sure the server ever sends, e.g. the\n    // refetch marker.\n    clonedTree = [\n        baseRouterState[0],\n        newTreeChildren\n    ];\n    if (2 in baseRouterState) {\n        clonedTree[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clonedTree[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clonedTree[4] = baseRouterState[4];\n    }\n    // Clone the CacheNodeSeedData tree.\n    const isEmptySeedDataPartial = true;\n    clonedSeedData = [\n        null,\n        newSeedDataChildren,\n        null,\n        isEmptySeedDataPartial,\n        false\n    ];\n    return {\n        tree: clonedTree,\n        data: clonedSeedData\n    };\n}\n\n//# sourceMappingURL=navigation.js.map","import { createHrefFromUrl } from '../create-href-from-url';\nimport { handleMutable } from '../handle-mutable';\nimport { navigate as navigateUsingSegmentCache } from '../../segment-cache/navigation';\nimport { NavigationResultTag } from '../../segment-cache/types';\nimport { getStaleTimeMs } from '../../segment-cache/cache';\nimport { FreshnessPolicy } from '../ppr-navigations';\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000;\nexport const STATIC_STALETIME_MS = getStaleTimeMs(Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME));\nexport function handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return handleMutable(state, mutable);\n}\nexport function generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nexport function handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.renderedSearch = result.data.renderedSearch;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n                // some confusing and subtle logic in `handleMutable` that decides what\n                // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n                // not convinced it's totally coherent but the tests assert on this\n                // particular behavior so I've ported the logic as-is from the previous\n                // router implementation, for now.\n                mutable.scrollableSegments = result.data.scrollableSegments ?? undefined;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // We don't need to compare the origins, because client-driven\n                // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return handleMutable(state, mutable);\n            }\n        case NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // If the navigation failed, return the current state.\n                // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nexport function navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const href = createHrefFromUrl(url);\n    const pendingPush = navigateType === 'push';\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const currentUrl = new URL(state.canonicalUrl, location.origin);\n    const result = navigateUsingSegmentCache(url, currentUrl, state.cache, state.tree, state.nextUrl, FreshnessPolicy.Default, shouldScroll, mutable);\n    return handleNavigationResult(url, state, mutable, pendingPush, result);\n}\n\n//# sourceMappingURL=navigate-reducer.js.map","export function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n  // Shim of Stage 4 Promise.withResolvers proposal\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { resolve: resolve!, reject: reject!, promise }\n}\n","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it — i.e. the one\n  // optionally passed to router.prefetch(onInvalidate) — then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete — this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert — should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time — it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","import { HasLoadingBoundary } from '../../../shared/lib/app-router-types';\nimport { matchSegment } from '../match-segments';\nimport { readOrCreateRouteCacheEntry, readOrCreateSegmentCacheEntry, fetchRouteOnCacheMiss, fetchSegmentOnCacheMiss, EntryStatus, fetchSegmentPrefetchesUsingDynamicRequest, convertRouteTreeToFlightRouterState, readOrCreateRevalidatingSegmentEntry, upsertSegmentEntry, upgradeToPendingSegment, waitForSegmentCacheEntry, overwriteRevalidatingSegmentCacheEntry, canNewFetchStrategyProvideMoreContent } from './cache';\nimport { getSegmentVaryPathForRequest } from './vary-path';\nimport { createCacheKey } from './cache-key';\nimport { FetchStrategy, PrefetchPriority } from './types';\nimport { getCurrentCacheVersion } from './cache';\nimport { addSearchParamsIfPageSegment, PAGE_SEGMENT_KEY } from '../../../shared/lib/segment';\nconst scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : (fn)=>Promise.resolve().then(fn).catch((error)=>setTimeout(()=>{\n            throw error;\n        }));\nconst taskHeap = [];\nlet inProgressRequests = 0;\nlet sortIdCounter = 0;\nlet didScheduleMicrotask = false;\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink = null;\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300;\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle = null;\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */ export function startRevalidationCooldown() {\n    // Clear any existing timeout in case multiple revalidations happen\n    // in quick succession.\n    if (revalidationCooldownTimeoutHandle !== null) {\n        clearTimeout(revalidationCooldownTimeoutHandle);\n    }\n    // Schedule the cooldown to expire after the delay.\n    revalidationCooldownTimeoutHandle = setTimeout(()=>{\n        revalidationCooldownTimeoutHandle = null;\n        // Retry the prefetch queue now that the cooldown has expired.\n        ensureWorkIsScheduled();\n    }, REVALIDATION_COOLDOWN_MS);\n}\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */ export function schedulePrefetchTask(key, treeAtTimeOfPrefetch, fetchStrategy, priority, onInvalidate) {\n    // Spawn a new prefetch task\n    const task = {\n        key,\n        treeAtTimeOfPrefetch,\n        cacheVersion: getCurrentCacheVersion(),\n        priority,\n        phase: 1,\n        hasBackgroundWork: false,\n        spawnedRuntimePrefetches: null,\n        fetchStrategy,\n        sortId: sortIdCounter++,\n        isCanceled: false,\n        onInvalidate,\n        _heapIndex: -1\n    };\n    trackMostRecentlyHoveredLink(task);\n    heapPush(taskHeap, task);\n    // Schedule an async task to process the queue.\n    //\n    // The main reason we process the queue in an async task is for batching.\n    // It's common for a single JS task/event to trigger multiple prefetches.\n    // By deferring to a microtask, we only process the queue once per JS task.\n    // If they have different priorities, it also ensures they are processed in\n    // the optimal order.\n    ensureWorkIsScheduled();\n    return task;\n}\nexport function cancelPrefetchTask(task) {\n    // Remove the prefetch task from the queue. If the task already completed,\n    // then this is a no-op.\n    //\n    // We must also explicitly mark the task as canceled so that a blocked task\n    // does not get added back to the queue when it's pinged by the network.\n    task.isCanceled = true;\n    heapDelete(taskHeap, task);\n}\nexport function reschedulePrefetchTask(task, treeAtTimeOfPrefetch, fetchStrategy, priority) {\n    // Bump the prefetch task to the top of the queue, as if it were a fresh\n    // task. This is essentially the same as canceling the task and scheduling\n    // a new one, except it reuses the original object.\n    //\n    // The primary use case is to increase the priority of a Link-initated\n    // prefetch on hover.\n    // Un-cancel the task, in case it was previously canceled.\n    task.isCanceled = false;\n    task.phase = 1;\n    // Assign a new sort ID to move it ahead of all other tasks at the same\n    // priority level. (Higher sort IDs are processed first.)\n    task.sortId = sortIdCounter++;\n    task.priority = // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority;\n    task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch;\n    task.fetchStrategy = fetchStrategy;\n    trackMostRecentlyHoveredLink(task);\n    if (task._heapIndex !== -1) {\n        // The task is already in the queue.\n        heapResift(taskHeap, task);\n    } else {\n        heapPush(taskHeap, task);\n    }\n    ensureWorkIsScheduled();\n}\nexport function isPrefetchTaskDirty(task, nextUrl, tree) {\n    // This is used to quickly bail out of a prefetch task if the result is\n    // guaranteed to not have changed since the task was initiated. This is\n    // strictly an optimization — theoretically, if it always returned true, no\n    // behavior should change because a full prefetch task will effectively\n    // perform the same checks.\n    const currentCacheVersion = getCurrentCacheVersion();\n    return task.cacheVersion !== currentCacheVersion || task.treeAtTimeOfPrefetch !== tree || task.key.nextUrl !== nextUrl;\n}\nfunction trackMostRecentlyHoveredLink(task) {\n    // Track the mostly recently hovered link, i.e. the most recently scheduled\n    // task at Intent priority. There must only be one such task at a time.\n    if (task.priority === PrefetchPriority.Intent && task !== mostRecentlyHoveredLink) {\n        if (mostRecentlyHoveredLink !== null) {\n            // Bump the previously hovered link's priority down to Default.\n            if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n                mostRecentlyHoveredLink.priority = PrefetchPriority.Default;\n                heapResift(taskHeap, mostRecentlyHoveredLink);\n            }\n        }\n        mostRecentlyHoveredLink = task;\n    }\n}\nfunction ensureWorkIsScheduled() {\n    if (didScheduleMicrotask) {\n        // Already scheduled a task to process the queue\n        return;\n    }\n    didScheduleMicrotask = true;\n    scheduleMicrotask(processQueueInMicrotask);\n}\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit — prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */ function hasNetworkBandwidth(task) {\n    // Check if we're within the revalidation cooldown window\n    if (revalidationCooldownTimeoutHandle !== null) {\n        // We're within the cooldown window. Return false to prevent prefetching.\n        // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n        // to retry the queue.\n        return false;\n    }\n    // TODO: Also check if there's an in-progress navigation. We should never\n    // add prefetch requests to the network queue if an actual navigation is\n    // taking place, to ensure there's sufficient bandwidth for render-blocking\n    // data and resources.\n    // TODO: Consider reserving some amount of bandwidth for static prefetches.\n    if (task.priority === PrefetchPriority.Intent) {\n        // The most recently hovered link is allowed to exceed the default limit.\n        //\n        // The goal is to always have enough bandwidth to start a new prefetch\n        // request when hovering over a link.\n        //\n        // However, because we don't abort in-progress requests, it's still possible\n        // we'll run out of bandwidth. When links are hovered in quick succession,\n        // there could be multiple hover requests running simultaneously.\n        return inProgressRequests < 12;\n    }\n    // The default limit is lower than the limit for a hovered link.\n    return inProgressRequests < 4;\n}\nfunction spawnPrefetchSubtask(prefetchSubtask) {\n    // When the scheduler spawns an async task, we don't await its result.\n    // Instead, the async task writes its result directly into the cache, then\n    // pings the scheduler to continue.\n    //\n    // We process server responses streamingly, so the prefetch subtask will\n    // likely resolve before we're finished receiving all the data. The subtask\n    // result includes a promise that resolves once the network connection is\n    // closed. The scheduler uses this to control network bandwidth by tracking\n    // and limiting the number of concurrent requests.\n    inProgressRequests++;\n    return prefetchSubtask.then((result)=>{\n        if (result === null) {\n            // The prefetch task errored before it could start processing the\n            // network stream. Assume the connection is closed.\n            onPrefetchConnectionClosed();\n            return null;\n        }\n        // Wait for the connection to close before freeing up more bandwidth.\n        result.closed.then(onPrefetchConnectionClosed);\n        return result.value;\n    });\n}\nfunction onPrefetchConnectionClosed() {\n    inProgressRequests--;\n    // Notify the scheduler that we have more bandwidth, and can continue\n    // processing tasks.\n    ensureWorkIsScheduled();\n}\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */ export function pingPrefetchTask(task) {\n    // \"Ping\" a prefetch that's already in progress to notify it of new data.\n    if (// Check if prefetch was canceled.\n    task.isCanceled || // Check if prefetch is already queued.\n    task._heapIndex !== -1) {\n        return;\n    }\n    // Add the task back to the queue.\n    heapPush(taskHeap, task);\n    ensureWorkIsScheduled();\n}\nfunction processQueueInMicrotask() {\n    didScheduleMicrotask = false;\n    // We aim to minimize how often we read the current time. Since nearly all\n    // functions in the prefetch scheduler are synchronous, we can read the time\n    // once and pass it as an argument wherever it's needed.\n    const now = Date.now();\n    // Process the task queue until we run out of network bandwidth.\n    let task = heapPeek(taskHeap);\n    while(task !== null && hasNetworkBandwidth(task)){\n        task.cacheVersion = getCurrentCacheVersion();\n        const exitStatus = pingRoute(now, task);\n        // These fields are only valid for a single attempt. Reset them after each\n        // iteration of the task queue.\n        const hasBackgroundWork = task.hasBackgroundWork;\n        task.hasBackgroundWork = false;\n        task.spawnedRuntimePrefetches = null;\n        switch(exitStatus){\n            case 0:\n                // The task yielded because there are too many requests in progress.\n                // Stop processing tasks until we have more bandwidth.\n                return;\n            case 1:\n                // The task is blocked. It needs more data before it can proceed.\n                // Keep the task out of the queue until the server responds.\n                heapPop(taskHeap);\n                // Continue to the next task\n                task = heapPeek(taskHeap);\n                continue;\n            case 2:\n                if (task.phase === 1) {\n                    // Finished prefetching the route tree. Proceed to prefetching\n                    // the segments.\n                    task.phase = 0;\n                    heapResift(taskHeap, task);\n                } else if (hasBackgroundWork) {\n                    // The task spawned additional background work. Reschedule the task\n                    // at background priority.\n                    task.priority = PrefetchPriority.Background;\n                    heapResift(taskHeap, task);\n                } else {\n                    // The prefetch is complete. Continue to the next task.\n                    heapPop(taskHeap);\n                }\n                task = heapPeek(taskHeap);\n                continue;\n            default:\n                exitStatus;\n        }\n    }\n}\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */ function background(task) {\n    if (task.priority === PrefetchPriority.Background) {\n        return true;\n    }\n    task.hasBackgroundWork = true;\n    return false;\n}\nfunction pingRoute(now, task) {\n    const key = task.key;\n    const route = readOrCreateRouteCacheEntry(now, task, key);\n    const exitStatus = pingRootRouteTree(now, task, route);\n    if (exitStatus !== 0 && key.search !== '') {\n        // If the URL has a non-empty search string, also prefetch the pathname\n        // without the search string. We use the searchless route tree as a base for\n        // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n        //\n        // Note that we don't need to prefetch any of the segment data. Just the\n        // route tree.\n        //\n        // TODO: This is a temporary solution; the plan is to replace this by adding\n        // a wildcard lookup method to the TupleMap implementation. This is\n        // non-trivial to implement because it needs to account for things like\n        // fallback route entries, hence this temporary workaround.\n        const url = new URL(key.pathname, location.origin);\n        const keyWithoutSearch = createCacheKey(url.href, key.nextUrl);\n        const routeWithoutSearch = readOrCreateRouteCacheEntry(now, task, keyWithoutSearch);\n        switch(routeWithoutSearch.status){\n            case EntryStatus.Empty:\n                {\n                    if (background(task)) {\n                        routeWithoutSearch.status = EntryStatus.Pending;\n                        spawnPrefetchSubtask(fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch));\n                    }\n                    break;\n                }\n            case EntryStatus.Pending:\n            case EntryStatus.Fulfilled:\n            case EntryStatus.Rejected:\n                {\n                    break;\n                }\n            default:\n                routeWithoutSearch;\n        }\n    }\n    return exitStatus;\n}\nfunction pingRootRouteTree(now, task, route) {\n    switch(route.status){\n        case EntryStatus.Empty:\n            {\n                // Route is not yet cached, and there's no request already in progress.\n                // Spawn a task to request the route, load it into the cache, and ping\n                // the task to continue.\n                // TODO: There are multiple strategies in the <Link> API for prefetching\n                // a route. Currently we've only implemented the main one: per-segment,\n                // static-data only.\n                //\n                // There's also `<Link prefetch={true}>`\n                // which prefetch both static *and* dynamic data.\n                // Similarly, we need to fallback to the old, per-page\n                // behavior if PPR is disabled for a route (via the incremental opt-in).\n                //\n                // Those cases will be handled here.\n                spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key));\n                // If the request takes longer than a minute, a subsequent request should\n                // retry instead of waiting for this one. When the response is received,\n                // this value will be replaced by a new value based on the stale time sent\n                // from the server.\n                // TODO: We should probably also manually abort the fetch task, to reclaim\n                // server bandwidth.\n                route.staleAt = now + 60 * 1000;\n                // Upgrade to Pending so we know there's already a request in progress\n                route.status = EntryStatus.Pending;\n            // Intentional fallthrough to the Pending branch\n            }\n        case EntryStatus.Pending:\n            {\n                // Still pending. We can't start prefetching the segments until the route\n                // tree has loaded. Add the task to the set of blocked tasks so that it\n                // is notified when the route tree is ready.\n                const blockedTasks = route.blockedTasks;\n                if (blockedTasks === null) {\n                    route.blockedTasks = new Set([\n                        task\n                    ]);\n                } else {\n                    blockedTasks.add(task);\n                }\n                return 1;\n            }\n        case EntryStatus.Rejected:\n            {\n                // Route tree failed to load. Treat as a 404.\n                return 2;\n            }\n        case EntryStatus.Fulfilled:\n            {\n                if (task.phase !== 0) {\n                    // Do not prefetch segment data until we've entered the segment phase.\n                    return 2;\n                }\n                // Recursively fill in the segment tree.\n                if (!hasNetworkBandwidth(task)) {\n                    // Stop prefetching segments until there's more bandwidth.\n                    return 0;\n                }\n                const tree = route.tree;\n                // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n                // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n                // We don't need to do this for runtime prefetches, because those are only available in\n                // `cacheComponents`, where every route is PPR.\n                const fetchStrategy = task.fetchStrategy === FetchStrategy.PPR ? route.isPPREnabled ? FetchStrategy.PPR : FetchStrategy.LoadingBoundary : task.fetchStrategy;\n                switch(fetchStrategy){\n                    case FetchStrategy.PPR:\n                        {\n                            // For Cache Components pages, each segment may be prefetched\n                            // statically or using a runtime request, based on various\n                            // configurations and heuristics. We'll do this in two passes: first\n                            // traverse the tree and perform all the static prefetches.\n                            //\n                            // Then, if there are any segments that need a runtime request,\n                            // do another pass to perform a runtime prefetch.\n                            pingStaticHead(now, task, route);\n                            const exitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, task.treeAtTimeOfPrefetch, tree);\n                            if (exitStatus === 0) {\n                                // Child yielded without finishing.\n                                return 0;\n                            }\n                            const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches;\n                            if (spawnedRuntimePrefetches !== null) {\n                                // During the first pass, we discovered segments that require a\n                                // runtime prefetch. Do a second pass to construct a request tree.\n                                const spawnedEntries = new Map();\n                                pingRuntimeHead(now, task, route, spawnedEntries, FetchStrategy.PPRRuntime);\n                                const requestTree = pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries);\n                                let needsDynamicRequest = spawnedEntries.size > 0;\n                                if (needsDynamicRequest) {\n                                    // Perform a dynamic prefetch request and populate the cache with\n                                    // the result.\n                                    spawnPrefetchSubtask(fetchSegmentPrefetchesUsingDynamicRequest(task, route, FetchStrategy.PPRRuntime, requestTree, spawnedEntries));\n                                }\n                            }\n                            return 2;\n                        }\n                    case FetchStrategy.Full:\n                    case FetchStrategy.PPRRuntime:\n                    case FetchStrategy.LoadingBoundary:\n                        {\n                            // Prefetch multiple segments using a single dynamic request.\n                            // TODO: We can consolidate this branch with previous one by modeling\n                            // it as if the first segment in the new tree has runtime prefetching\n                            // enabled. Will do this as a follow-up refactor. Might want to remove\n                            // the special metatdata case below first. In the meantime, it's not\n                            // really that much duplication, just would be nice to remove one of\n                            // these codepaths.\n                            const spawnedEntries = new Map();\n                            pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy);\n                            const dynamicRequestTree = diffRouteTreeAgainstCurrent(now, task, route, task.treeAtTimeOfPrefetch, tree, spawnedEntries, fetchStrategy);\n                            let needsDynamicRequest = spawnedEntries.size > 0;\n                            if (needsDynamicRequest) {\n                                spawnPrefetchSubtask(fetchSegmentPrefetchesUsingDynamicRequest(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries));\n                            }\n                            return 2;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n                break;\n            }\n        default:\n            {\n                route;\n            }\n    }\n    return 2;\n}\nfunction pingStaticHead(now, task, route) {\n    // The Head data for a page (metadata, viewport) is not really a route\n    // segment, in the sense that it doesn't appear in the route tree. But we\n    // store it in the cache as if it were, using a special key.\n    pingStaticSegmentData(now, task, route, readOrCreateSegmentCacheEntry(now, FetchStrategy.PPR, route, route.metadata), task.key, route.metadata);\n}\nfunction pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy) {\n    pingRouteTreeAndIncludeDynamicData(now, task, route, route.metadata, false, spawnedEntries, // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary ? FetchStrategy.Full : fetchStrategy);\n}\n// TODO: Rename dynamic -> runtime throughout this module\nfunction pingSharedPartOfCacheComponentsTree(now, task, route, oldTree, newTree) {\n    // When Cache Components is enabled (or PPR, or a fully static route when PPR\n    // is disabled; those cases are treated equivalently to Cache Components), we\n    // start by prefetching each segment individually. Once we reach the \"new\"\n    // part of the tree — the part that doesn't exist on the current page — we\n    // may choose to switch to a runtime prefetch instead, based on the\n    // information sent by the server in the route tree.\n    //\n    // The traversal starts in the \"shared\" part of the tree. Once we reach the\n    // \"new\" part of the tree, we switch to a different traversal,\n    // pingNewPartOfCacheComponentsTree.\n    // Prefetch this segment's static data.\n    const segment = readOrCreateSegmentCacheEntry(now, task.fetchStrategy, route, newTree);\n    pingStaticSegmentData(now, task, route, segment, task.key, newTree);\n    // Recursively ping the children.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            if (!hasNetworkBandwidth(task)) {\n                // Stop prefetching segments until there's more bandwidth.\n                return 0;\n            }\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            let childExitStatus;\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // We're still in the \"shared\" part of the tree.\n                childExitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, oldTreeChild, newTreeChild);\n            } else {\n                // We've entered the \"new\" part of the tree. Switch\n                // traversal functions.\n                childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, newTreeChild);\n            }\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    return 2;\n}\nfunction pingNewPartOfCacheComponentsTree(now, task, route, tree) {\n    // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n    // exist on the current page. (In other words, we're deeper than the\n    // shared layouts.) Segments in here default to being prefetched statically.\n    // However, if the server instructs us to, we may switch to a runtime\n    // prefetch instead. Traverse the tree and check at each segment.\n    if (tree.hasRuntimePrefetch) {\n        // This route has a runtime prefetch response. Since we're below the shared\n        // layout, everything from this point should be prefetched using a single,\n        // combined runtime request, rather than using per-segment static requests.\n        // This is true even if some of the child segments are known to be fully\n        // static — once we've decided to perform a runtime prefetch, we might as\n        // well respond with the static segments in the same roundtrip. (That's how\n        // regular navigations work, too.) We'll still skip over segments that are\n        // already cached, though.\n        //\n        // It's the server's responsibility to set a reasonable value of\n        // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n        // server may send a value of `false` even if the user opts in, if it\n        // determines during build that the route is always fully static. There are\n        // more optimizations we can do once we implement fallback param\n        // tracking, too.\n        //\n        // Use the task object to collect the segments that need a runtime prefetch.\n        // This will signal to the outer task queue that a second traversal is\n        // required to construct a request tree.\n        if (task.spawnedRuntimePrefetches === null) {\n            task.spawnedRuntimePrefetches = new Set([\n                tree.requestKey\n            ]);\n        } else {\n            task.spawnedRuntimePrefetches.add(tree.requestKey);\n        }\n        // Then exit the traversal without prefetching anything further.\n        return 2;\n    }\n    // This segment should not be runtime prefetched. Prefetch its static data.\n    const segment = readOrCreateSegmentCacheEntry(now, task.fetchStrategy, route, tree);\n    pingStaticSegmentData(now, task, route, segment, task.key, tree);\n    if (tree.slots !== null) {\n        if (!hasNetworkBandwidth(task)) {\n            // Stop prefetching segments until there's more bandwidth.\n            return 0;\n        }\n        // Recursively ping the children.\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            const childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, childTree);\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    // This segment and all its children have finished prefetching.\n    return 2;\n}\nfunction diffRouteTreeAgainstCurrent(now, task, route, oldTree, newTree, spawnedEntries, fetchStrategy) {\n    // This is a single recursive traversal that does multiple things:\n    // - Finds the parts of the target route (newTree) that are not part of\n    //   of the current page (oldTree) by diffing them, using the same algorithm\n    //   as a real navigation.\n    // - Constructs a request tree (FlightRouterState) that describes which\n    //   segments need to be prefetched and which ones are already cached.\n    // - Creates a set of pending cache entries for the segments that need to\n    //   be prefetched, so that a subsequent prefetch task does not request the\n    //   same segments again.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    let requestTreeChildren = {};\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // This segment is already part of the current route. Keep traversing.\n                const requestTreeChild = diffRouteTreeAgainstCurrent(now, task, route, oldTreeChild, newTreeChild, spawnedEntries, fetchStrategy);\n                requestTreeChildren[parallelRouteKey] = requestTreeChild;\n            } else {\n                // This segment is not part of the current route. We're entering a\n                // part of the tree that we need to prefetch (unless everything is\n                // already cached).\n                switch(fetchStrategy){\n                    case FetchStrategy.LoadingBoundary:\n                        {\n                            // When PPR is disabled, we can't prefetch per segment. We must\n                            // fallback to the old prefetch behavior and send a dynamic request.\n                            // Only routes that include a loading boundary can be prefetched in\n                            // this way.\n                            //\n                            // This is simlar to a \"full\" prefetch, but we're much more\n                            // conservative about which segments to include in the request.\n                            //\n                            // The server will only render up to the first loading boundary\n                            // inside new part of the tree. If there's no loading boundary\n                            // anywhere in the tree, the server will never return any data, so\n                            // we can skip the request.\n                            const subtreeHasLoadingBoundary = newTreeChild.hasLoadingBoundary !== HasLoadingBoundary.SubtreeHasNoLoadingBoundary;\n                            const requestTreeChild = subtreeHasLoadingBoundary ? pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, newTreeChild, null, spawnedEntries) : convertRouteTreeToFlightRouterState(newTreeChild);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case FetchStrategy.PPRRuntime:\n                        {\n                            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n                            // not just the static PPR shell.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case FetchStrategy.Full:\n                        {\n                            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n                            // static and dynamic. We issue roughly the same request that we\n                            // would during a real navigation. The goal is that once the\n                            // navigation occurs, the router should not have to fetch any\n                            // additional data.\n                            //\n                            // Although the response will include dynamic data, opting into a\n                            // Full prefetch — via <Link prefetch={true}> — implicitly\n                            // instructs the cache to treat the response as \"static\", or non-\n                            // dynamic, since the whole point is to cache it for\n                            // future navigations.\n                            //\n                            // Construct a tree (currently a FlightRouterState) that represents\n                            // which segments need to be prefetched and which ones are already\n                            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n                            // send the request tree to the server and use the response to\n                            // populate the segment cache.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n            }\n        }\n    }\n    const requestTree = [\n        newTree.segment,\n        requestTreeChildren,\n        null,\n        null,\n        newTree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, tree, refetchMarkerContext, spawnedEntries) {\n    // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n    // server is only going to return a minimal loading state — it will stop\n    // rendering at the first loading boundary. Whereas a Full prefetch is\n    // intentionally aggressive and tries to pretfetch all the data that will be\n    // needed for a navigation, a LoadingBoundary prefetch is much more\n    // conservative. For example, it will omit from the request tree any segment\n    // that is already cached, regardles of whether it's partial or full. By\n    // contrast, a Full prefetch will refetch partial segments.\n    // \"inside-shared-layout\" tells the server where to start looking for a\n    // loading boundary.\n    let refetchMarker = refetchMarkerContext === null ? 'inside-shared-layout' : null;\n    const segment = readOrCreateSegmentCacheEntry(now, task.fetchStrategy, route, tree);\n    switch(segment.status){\n        case EntryStatus.Empty:\n            {\n                // This segment is not cached. Add a refetch marker so the server knows\n                // to start rendering here.\n                // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n                // FlightRouterState from the request tree. I think this would probably\n                // already work even without any updates to the server. For consistency,\n                // though, I'll send the full tree and we'll look into this later as part\n                // of a larger redesign of the request protocol.\n                // Add the pending cache entry to the result map.\n                spawnedEntries.set(tree.requestKey, upgradeToPendingSegment(segment, // Set the fetch strategy to LoadingBoundary to indicate that the server\n                // might not include it in the pending response. If another route is able\n                // to issue a per-segment request, we'll do that in the background.\n                FetchStrategy.LoadingBoundary));\n                if (refetchMarkerContext !== 'refetch') {\n                    refetchMarker = refetchMarkerContext = 'refetch';\n                } else {\n                // There's already a parent with a refetch marker, so we don't need\n                // to add another one.\n                }\n                break;\n            }\n        case EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                const segmentHasLoadingBoundary = tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary;\n                if (segmentHasLoadingBoundary) {\n                    // This segment has a loading boundary, which means the server won't\n                    // render its children. So there's nothing left to prefetch along this\n                    // path. We can bail out.\n                    return convertRouteTreeToFlightRouterState(tree);\n                }\n                break;\n            }\n        case EntryStatus.Pending:\n            {\n                break;\n            }\n        case EntryStatus.Rejected:\n            {\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, childTree, refetchMarkerContext, spawnedEntries);\n        }\n    }\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRouteTreeAndIncludeDynamicData(now, task, route, tree, isInsideRefetchingParent, spawnedEntries, fetchStrategy) {\n    // The tree we're constructing is the same shape as the tree we're navigating\n    // to. But even though this is a \"new\" tree, some of the individual segments\n    // may be cached as a result of other route prefetches.\n    //\n    // So we need to find the first uncached segment along each path add an\n    // explicit \"refetch\" marker so the server knows where to start rendering.\n    // Once the server starts rendering along a path, it keeps rendering the\n    // entire subtree.\n    const segment = readOrCreateSegmentCacheEntry(now, // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy, route, tree);\n    let spawnedSegment = null;\n    switch(segment.status){\n        case EntryStatus.Empty:\n            {\n                // This segment is not cached. Include it in the request.\n                spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy);\n                break;\n            }\n        case EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                if (segment.isPartial && canNewFetchStrategyProvideMoreContent(segment.fetchStrategy, fetchStrategy)) {\n                    // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n                    // This means we're in one of these cases:\n                    //   - we have a static prefetch, and we're doing a runtime prefetch\n                    //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n                    // In either case, we need to include it in the request to get a more specific (or full) version.\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        case EntryStatus.Pending:\n        case EntryStatus.Rejected:\n            {\n                // There's either another prefetch currently in progress, or the previous\n                // attempt failed. If the new strategy can provide more content, fetch it again.\n                if (canNewFetchStrategyProvideMoreContent(segment.fetchStrategy, fetchStrategy)) {\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRouteTreeAndIncludeDynamicData(now, task, route, childTree, isInsideRefetchingParent || spawnedSegment !== null, spawnedEntries, fetchStrategy);\n        }\n    }\n    if (spawnedSegment !== null) {\n        // Add the pending entry to the result map.\n        spawnedEntries.set(tree.requestKey, spawnedSegment);\n    }\n    // Don't bother to add a refetch marker if one is already present in a parent.\n    const refetchMarker = !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null;\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries) {\n    // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n    // a segment is part of the runtime prefetch, the tree is constructed by\n    // diffing against what's already in the prefetch cache. Otherwise, we send\n    // a regular FlightRouterState with no special markers.\n    //\n    // See pingRouteTreeAndIncludeDynamicData for details.\n    if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n        // This segment needs a runtime prefetch.\n        return pingRouteTreeAndIncludeDynamicData(now, task, route, tree, false, spawnedEntries, FetchStrategy.PPRRuntime);\n    }\n    let requestTreeChildren = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(now, task, route, childTree, spawnedRuntimePrefetches, spawnedEntries);\n        }\n    }\n    // This segment is not part of the runtime prefetch. Clone the base tree.\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        null\n    ];\n    return requestTree;\n}\nfunction pingStaticSegmentData(now, task, route, segment, routeKey, tree) {\n    switch(segment.status){\n        case EntryStatus.Empty:\n            // Upgrade to Pending so we know there's already a request in progress\n            spawnPrefetchSubtask(fetchSegmentOnCacheMiss(route, upgradeToPendingSegment(segment, FetchStrategy.PPR), routeKey, tree));\n            break;\n        case EntryStatus.Pending:\n            {\n                // There's already a request in progress. Depending on what kind of\n                // request it is, we may want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case FetchStrategy.PPR:\n                    case FetchStrategy.PPRRuntime:\n                    case FetchStrategy.Full:\n                        break;\n                    case FetchStrategy.LoadingBoundary:\n                        // There's a pending request, but because it's using the old\n                        // prefetching strategy, we can't be sure if it will be fulfilled by\n                        // the response — it might be inside the loading boundary. Perform\n                        // a revalidation, but because it's speculative, wait to do it at\n                        // background priority.\n                        if (background(task)) {\n                            // TODO: Instead of speculatively revalidating, consider including\n                            // `hasLoading` in the route tree prefetch response.\n                            pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        }\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case EntryStatus.Rejected:\n            {\n                // The existing entry in the cache was rejected. Depending on how it\n                // was originally fetched, we may or may not want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case FetchStrategy.PPR:\n                    case FetchStrategy.PPRRuntime:\n                    case FetchStrategy.Full:\n                        break;\n                    case FetchStrategy.LoadingBoundary:\n                        // There's a rejected entry, but it was fetched using the loading\n                        // boundary strategy. So the reason it wasn't returned by the server\n                        // might just be because it was inside a loading boundary. Or because\n                        // there was a dynamic rewrite. Revalidate it using the per-\n                        // segment strategy.\n                        //\n                        // Because a rejected segment will definitely prevent the segment (and\n                        // all of its children) from rendering, we perform this revalidation\n                        // immediately instead of deferring it to a background task.\n                        pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case EntryStatus.Fulfilled:\n            break;\n        default:\n            segment;\n    }\n// Segments do not have dependent tasks, so once the prefetch is initiated,\n// there's nothing else for us to do (except write the server data into the\n// entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\nfunction pingPPRSegmentRevalidation(now, route, routeKey, tree) {\n    const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(now, FetchStrategy.PPR, route, tree);\n    switch(revalidatingSegment.status){\n        case EntryStatus.Empty:\n            // Spawn a prefetch request and upsert the segment into the cache\n            // upon completion.\n            upsertSegmentOnCompletion(spawnPrefetchSubtask(fetchSegmentOnCacheMiss(route, upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR), routeKey, tree)), getSegmentVaryPathForRequest(FetchStrategy.PPR, tree));\n            break;\n        case EntryStatus.Pending:\n            break;\n        case EntryStatus.Fulfilled:\n        case EntryStatus.Rejected:\n            break;\n        default:\n            revalidatingSegment;\n    }\n}\nfunction pingFullSegmentRevalidation(now, route, tree, fetchStrategy) {\n    const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(now, fetchStrategy, route, tree);\n    if (revalidatingSegment.status === EntryStatus.Empty) {\n        // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n        // segments that we need. So we don't initiate a request here directly. By\n        // returning a pending entry from this function, it signals to the caller\n        // that this segment should be included in the request that's sent to\n        // the server.\n        const pendingSegment = upgradeToPendingSegment(revalidatingSegment, fetchStrategy);\n        upsertSegmentOnCompletion(waitForSegmentCacheEntry(pendingSegment), getSegmentVaryPathForRequest(fetchStrategy, tree));\n        return pendingSegment;\n    } else {\n        // There's already a revalidation in progress.\n        const nonEmptyRevalidatingSegment = revalidatingSegment;\n        if (canNewFetchStrategyProvideMoreContent(nonEmptyRevalidatingSegment.fetchStrategy, fetchStrategy)) {\n            // The existing revalidation was fetched using a less specific strategy.\n            // Reset it and start a new revalidation.\n            const emptySegment = overwriteRevalidatingSegmentCacheEntry(fetchStrategy, route, tree);\n            const pendingSegment = upgradeToPendingSegment(emptySegment, fetchStrategy);\n            upsertSegmentOnCompletion(waitForSegmentCacheEntry(pendingSegment), getSegmentVaryPathForRequest(fetchStrategy, tree));\n            return pendingSegment;\n        }\n        switch(nonEmptyRevalidatingSegment.status){\n            case EntryStatus.Pending:\n                // There's already an in-progress prefetch that includes this segment.\n                return null;\n            case EntryStatus.Fulfilled:\n            case EntryStatus.Rejected:\n                // A previous revalidation attempt finished, but we chose not to replace\n                // the existing entry in the cache. Don't try again until or unless the\n                // revalidation entry expires.\n                return null;\n            default:\n                nonEmptyRevalidatingSegment;\n                return null;\n        }\n    }\n}\nconst noop = ()=>{};\nfunction upsertSegmentOnCompletion(promise, varyPath) {\n    // Wait for a segment to finish loading, then upsert it into the cache\n    promise.then((fulfilled)=>{\n        if (fulfilled !== null) {\n            // Received new data. Attempt to replace the existing entry in the cache.\n            upsertSegmentEntry(Date.now(), varyPath, fulfilled);\n        }\n    }, noop);\n}\nfunction doesCurrentSegmentMatchCachedSegment(route, currentSegment, cachedSegment) {\n    if (cachedSegment === PAGE_SEGMENT_KEY) {\n        // In the FlightRouterState stored by the router, the page segment has the\n        // rendered search params appended to the name of the segment. In the\n        // prefetch cache, however, this is stored separately. So, when comparing\n        // the router's current FlightRouterState to the cached FlightRouterState,\n        // we need to make sure we compare both parts of the segment.\n        // TODO: This is not modeled clearly. We use the same type,\n        // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n        // _and_ the server response format, when conceptually those are three\n        // different things and treated in different ways. We should encode more of\n        // this information into the type design so mistakes are less likely.\n        return currentSegment === addSearchParamsIfPageSegment(PAGE_SEGMENT_KEY, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    }\n    // Non-page segments are compared using the same function as the server\n    return matchSegment(cachedSegment, currentSegment);\n}\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\nfunction compareQueuePriority(a, b) {\n    // Since the queue is a MinHeap, this should return a positive number if b is\n    // higher priority than a, and a negative number if a is higher priority\n    // than b.\n    // `priority` is an integer, where higher numbers are higher priority.\n    const priorityDiff = b.priority - a.priority;\n    if (priorityDiff !== 0) {\n        return priorityDiff;\n    }\n    // If the priority is the same, check which phase the prefetch is in — is it\n    // prefetching the route tree, or the segments? Route trees are prioritized.\n    const phaseDiff = b.phase - a.phase;\n    if (phaseDiff !== 0) {\n        return phaseDiff;\n    }\n    // Finally, check the insertion order. `sortId` is an incrementing counter\n    // assigned to prefetches. We want to process the newest prefetches first.\n    return b.sortId - a.sortId;\n}\nfunction heapPush(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    node._heapIndex = index;\n    heapSiftUp(heap, node, index);\n}\nfunction heapPeek(heap) {\n    return heap.length === 0 ? null : heap[0];\n}\nfunction heapPop(heap) {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    first._heapIndex = -1;\n    const last = heap.pop();\n    if (last !== first) {\n        heap[0] = last;\n        last._heapIndex = 0;\n        heapSiftDown(heap, last, 0);\n    }\n    return first;\n}\nfunction heapDelete(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        node._heapIndex = -1;\n        if (heap.length !== 0) {\n            const last = heap.pop();\n            if (last !== node) {\n                heap[index] = last;\n                last._heapIndex = index;\n                heapSiftDown(heap, last, index);\n            }\n        }\n    }\n}\nfunction heapResift(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        if (index === 0) {\n            heapSiftDown(heap, node, 0);\n        } else {\n            const parentIndex = index - 1 >>> 1;\n            const parent = heap[parentIndex];\n            if (compareQueuePriority(parent, node) > 0) {\n                // The parent is larger. Sift up.\n                heapSiftUp(heap, node, index);\n            } else {\n                // The parent is smaller (or equal). Sift down.\n                heapSiftDown(heap, node, index);\n            }\n        }\n    }\n}\nfunction heapSiftUp(heap, node, i) {\n    let index = i;\n    while(index > 0){\n        const parentIndex = index - 1 >>> 1;\n        const parent = heap[parentIndex];\n        if (compareQueuePriority(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            node._heapIndex = parentIndex;\n            heap[index] = parent;\n            parent._heapIndex = index;\n            index = parentIndex;\n        } else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction heapSiftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while(index < halfLength){\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compareQueuePriority(left, node) < 0) {\n            if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n                heap[index] = right;\n                right._heapIndex = index;\n                heap[rightIndex] = node;\n                node._heapIndex = rightIndex;\n                index = rightIndex;\n            } else {\n                heap[index] = left;\n                left._heapIndex = index;\n                heap[leftIndex] = node;\n                node._heapIndex = leftIndex;\n                index = leftIndex;\n            }\n        } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n            heap[index] = right;\n            right._heapIndex = index;\n            heap[rightIndex] = node;\n            node._heapIndex = rightIndex;\n            index = rightIndex;\n        } else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\n\n//# sourceMappingURL=scheduler.js.map","import { FetchStrategy, PrefetchPriority } from './segment-cache/types';\nimport { createCacheKey } from './segment-cache/cache-key';\nimport { schedulePrefetchTask as scheduleSegmentPrefetchTask, cancelPrefetchTask, reschedulePrefetchTask, isPrefetchTaskDirty } from './segment-cache/scheduler';\nimport { startTransition } from 'react';\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation = null;\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = {\n    pending: true\n};\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = {\n    pending: false\n};\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link) {\n    startTransition(()=>{\n        linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS);\n        link?.setOptimisticLinkStatus(PENDING_LINK_STATUS);\n        linkForMostRecentNavigation = link;\n    });\n}\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link) {\n    if (linkForMostRecentNavigation === link) {\n        linkForMostRecentNavigation = null;\n    }\n}\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction observeVisibility(element, instance) {\n    const existingInstance = prefetchable.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountPrefetchableInstance(element);\n    }\n    // Only track prefetchable links that have a valid prefetch URL\n    prefetchable.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction coercePrefetchableUrl(href) {\n    if (typeof window !== 'undefined') {\n        const { createPrefetchURL } = require('./app-router-utils');\n        try {\n            return createPrefetchURL(href);\n        } catch  {\n            // createPrefetchURL sometimes throws an error if an invalid URL is\n            // provided, though I'm not sure if it's actually necessary.\n            // TODO: Consider removing the throw from the inner function, or change it\n            // to reportError. Or maybe the error isn't even necessary for automatic\n            // prefetches, just navigations.\n            const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n            reportErrorFn(`Cannot prefetch '${href}' because it cannot be converted to a URL.`);\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nexport function mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {\n    if (prefetchEnabled) {\n        const prefetchURL = coercePrefetchableUrl(href);\n        if (prefetchURL !== null) {\n            const instance = {\n                router,\n                fetchStrategy,\n                isVisible: false,\n                prefetchTask: null,\n                prefetchHref: prefetchURL.href,\n                setOptimisticLinkStatus\n            };\n            // We only observe the link's visibility if it's prefetchable. For\n            // example, this excludes links to external URLs.\n            observeVisibility(element, instance);\n            return instance;\n        }\n    }\n    // If the link is not prefetchable, we still create an instance so we can\n    // track its optimistic state (i.e. useLinkStatus).\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: null,\n        setOptimisticLinkStatus\n    };\n    return instance;\n}\nexport function mountFormInstance(element, href, router, fetchStrategy) {\n    const prefetchURL = coercePrefetchableUrl(href);\n    if (prefetchURL === null) {\n        // This href is not prefetchable, so we don't track it.\n        // TODO: We currently observe/unobserve a form every time its href changes.\n        // For Links, this isn't a big deal because the href doesn't usually change,\n        // but for forms it's extremely common. We should optimize this.\n        return;\n    }\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus: null\n    };\n    observeVisibility(element, instance);\n}\nexport function unmountPrefetchableInstance(element) {\n    const instance = prefetchable.get(element);\n    if (instance !== undefined) {\n        prefetchable.delete(element);\n        prefetchableAndVisible.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            cancelPrefetchTask(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nexport function onLinkVisibilityChanged(element, isVisible) {\n    if (process.env.NODE_ENV !== 'production') {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        prefetchableAndVisible.add(instance);\n    } else {\n        prefetchableAndVisible.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Default);\n}\nexport function onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        if (process.env.__NEXT_DYNAMIC_ON_HOVER && unstable_upgradeToDynamicPrefetch) {\n            // Switch to a full prefetch\n            instance.fetchStrategy = FetchStrategy.Full;\n        }\n        rescheduleLinkPrefetch(instance, PrefetchPriority.Intent);\n    }\n}\nfunction rescheduleLinkPrefetch(instance, priority) {\n    // Ensures that app-router-instance is not compiled in the server bundle\n    if (typeof window !== 'undefined') {\n        const existingPrefetchTask = instance.prefetchTask;\n        if (!instance.isVisible) {\n            // Cancel any in-progress prefetch task. (If it already finished then this\n            // is a no-op.)\n            if (existingPrefetchTask !== null) {\n                cancelPrefetchTask(existingPrefetchTask);\n            }\n            // We don't need to reset the prefetchTask to null upon cancellation; an\n            // old task object can be rescheduled with reschedulePrefetchTask. This is a\n            // micro-optimization but also makes the code simpler (don't need to\n            // worry about whether an old task object is stale).\n            return;\n        }\n        const { getCurrentAppRouterState } = require('./app-router-instance');\n        const appRouterState = getCurrentAppRouterState();\n        if (appRouterState !== null) {\n            const treeAtTimeOfPrefetch = appRouterState.tree;\n            if (existingPrefetchTask === null) {\n                // Initiate a prefetch task.\n                const nextUrl = appRouterState.nextUrl;\n                const cacheKey = createCacheKey(instance.prefetchHref, nextUrl);\n                instance.prefetchTask = scheduleSegmentPrefetchTask(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, null);\n            } else {\n                // We already have an old task object that we can reschedule. This is\n                // effectively the same as canceling the old task and creating a new one.\n                reschedulePrefetchTask(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);\n            }\n        }\n    }\n}\nexport function pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    for (const instance of prefetchableAndVisible){\n        const task = instance.prefetchTask;\n        if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            cancelPrefetchTask(task);\n        }\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl);\n        instance.prefetchTask = scheduleSegmentPrefetchTask(cacheKey, tree, instance.fetchStrategy, PrefetchPriority.Default, null);\n    }\n}\n\n//# sourceMappingURL=links.js.map"],"names":["warnOnce","_","process","env","NODE_ENV","warnings","Set","msg","has","console","warn","add","NavigationResultTag","PrefetchPriority","FetchStrategy","createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","pathname","search","HasLoadingBoundary","matchSegment","existingSegment","segment","ACTION_REFRESH","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_SERVER_PATCH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","PrefetchKind","isThenable","promise","then","React","use","useMemo","dispatch","dispatchAppRouterAction","action","Error","__DEV__","promisesWithDebugInfo","WeakMap","useActionQueue","actionQueue","state","setState","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","asyncState","push","_debugInfo","set","createHrefFromUrl","url","includeHash","hash","computeCacheBustingSearchParam","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","NEXT_RSC_UNION_QUERY","setCacheBustingSearchParam","headers","uniqueCacheKey","setCacheBustingSearchParamWithHash","existingSearch","rawQuery","startsWith","slice","pairs","split","filter","pair","length","join","normalizeAppPath","INTERCEPTION_ROUTE_MARKERS","isInterceptionRouteAppPath","path","find","m","extractInterceptionRouteInformation","interceptingRoute","marker","interceptedRoute","concat","splitInterceptingRoute","PAGE_SEGMENT_KEY","createRouterCacheKey","withoutSearchParameters","Array","isArray","isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","currentTreeChild","Object","values","nextTreeChild","DEFAULT_SEGMENT_KEY","NOT_FOUND_SEGMENT_KEY","fetchServerResponse","DYNAMIC_STALETIME_MS","convertServerPatchToFullTree","FreshnessPolicy","noop","createInitialCacheNodeForHydration","navigatedAt","initialTree","seedData","seedHead","accumulation","scrollableSegments","separateRefreshUrls","task","createCacheNodeOnNavigation","node","startPPRNavigation","oldUrl","oldCacheNode","oldRouterState","newRouterState","freshness","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","didFindRootLayout","parentNeedsDynamicRequest","parentRefreshUrl","updateCacheNodeOnNavigation","parentSegmentPath","parentParallelRouteKey","oldSegment","newSegment","segmentPath","newRouterStateChildren","oldRouterStateChildren","seedDataChildren","prefetchDataChildren","isRootLayout","childDidFindRootLayout","oldParallelRoutes","parallelRoutes","shouldDropSiblingCaches","shouldRefreshDynamicData","newParallelRoutes","Map","isLeafSegment","keys","newCacheNode","needsDynamicRequest","dropPrefetchRsc","reuseDynamicCacheNode","seedRsc","seedLoading","isSeedRscPartial","isSeedHeadPartial","readCacheNodeFromSeedData","prefetchRsc","prefetchLoading","isPrefetchRSCPartial","spawnNewCacheNode","href","refreshUrl","accumulateRefreshUrl","patchedRouterStateChildren","taskChildren","childNeedsDynamicRequest","dynamicRequestTreeChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","seedDataChild","prefetchDataChild","newSegmentChild","seedHeadChild","prefetchHeadChild","isPrefetchHeadPartialChild","reuseActiveSegmentInDefaultSlot","newSegmentKeyChild","oldCacheNodeChild","taskChild","newCacheNodeChild","newSegmentMapChild","taskChildRoute","route","dynamicRequestTreeChild","dynamicRequestTree","status","patchRouterStateWithNewChildren","createDynamicRequestTree","children","oldRsc","rsc","oldRscDidResolve","isDeferredRsc","baseRouterState","newChildren","clone","reusedRouterState","oldRefreshMarker","existingCacheNode","cacheNode","head","loading","isPageSegment","createDeferredRsc","isHydration","previousNavigationDidMismatch","spawnDynamicRequests","primaryUrl","freshnessPolicy","primaryRequestPromise","fetchMissingDynamicData","refreshRequestPromises","canonicalUrl","scopedDynamicRequestTree","location","origin","voidPromise","finishNavigationTask","exitStatus","waitForRequestsToFinish","abortRemainingPendingTasks","isHardRetry","primaryRequestResult","dispatchRetryDueToTreeMismatch","seed","onFulfill","result","remainingCount","onReject","forEach","refreshRequestPromise","retryUrl","retryNextUrl","baseTree","retryAction","type","previousTree","mpa","flightRouterState","isHmrRefresh","flightData","renderedSearch","didReceiveUnknownParallelRoute","writeDynamicDataIntoNavigationTask","tree","data","serverRouterState","dynamicData","dynamicHead","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","taskSegment","childDidReceiveUnknownParallelRoute","dynamicSegmentData","dynamicLoading","error","abortPendingCacheNode","childExitStatus","reject","DEFERRED","Symbol","value","tag","pendingRsc","res","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","createPromiseWithResolvers","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","createFetch","createFromNextReadableStream","pingPrefetchTask","isPrefetchTaskDirty","startRevalidationCooldown","getRouteVaryPath","getFulfilledRouteVaryPath","getSegmentVaryPathForRequest","appendLayoutVaryPath","finalizeLayoutVaryPath","finalizePageVaryPath","clonePageVaryPathWithNewSearchParams","finalizeMetadataVaryPath","getAppBuildId","createPrefetchRequestKey","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","createCacheMap","getFromCacheMap","setInCacheMap","setSizeInCacheMap","deleteFromCacheMap","isValueExpired","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentRequestKeyPart","HEAD_REQUEST_KEY","ROOT_SEGMENT_REQUEST_KEY","normalizeFlightData","prepareFlightRouterStateForRequest","STATIC_STALETIME_MS","pingVisibleLinks","getStaleTimeMs","staleTimeSeconds","Math","max","EntryStatus","isOutputExportMode","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","segmentCacheMap","invalidationListeners","currentCacheVersion","getCurrentCacheVersion","revalidateEntireCache","pingInvalidationListeners","attachInvalidationListener","onInvalidate","notifyInvalidationListener","reportError","tasks","readRouteCacheEntry","now","key","varyPath","isRevalidation","readSegmentCacheEntry","readRevalidatingSegmentCacheEntry","waitForSegmentCacheEntry","pendingEntry","promiseWithResolvers","readOrCreateRouteCacheEntry","existingEntry","blockedTasks","metadata","couldBeIntercepted","isPPREnabled","ref","size","staleAt","Infinity","version","requestOptimisticRouteCacheEntry","requestedUrl","requestedSearch","urlWithoutSearchParams","routeWithNoSearchParams","canonicalUrlForRouteWithNoSearchParams","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","optimisticCanonicalUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","slots","childTree","isPage","requestKey","hasLoadingBoundary","hasRuntimePrefetch","readOrCreateSegmentCacheEntry","fetchStrategy","varyPathForRequest","createDetachedSegmentCacheEntry","readOrCreateRevalidatingSegmentEntry","overwriteRevalidatingSegmentCacheEntry","upsertSegmentEntry","candidateEntry","canNewFetchStrategyProvideMoreContent","isPartial","rejectedEntry","emptyEntry","PPR","upgradeToPendingSegment","Full","pingBlockedTasks","entry","fulfillRouteCacheEntry","metadataVaryPath","SubtreeHasNoLoadingBoundary","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","acc","pathnameParts","p","index","rootSegment","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","childPrefetch","childParamName","name","childParamType","paramType","childServerSentParamKey","paramKey","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","childParamKey","childPathnamePartsIndex","childRequestKeyPart","childRequestKey","endsWith","SegmentHasLoadingBoundary","convertRootFlightRouterStateToRouteTree","convertFlightRouterStateToRouteTree","parentPartialVaryPath","originalSegment","paramCacheKey","childRouterState","convertRouteTreeToFlightRouterState","routeTree","fetchRouteOnCacheMiss","response","urlAfterRedirects","headResponse","fetch","method","Date","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","includes","closed","routeIsPPREnabled","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","buildId","staleTimeMs","staleTime","b","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","fetchSegmentOnCacheMiss","routeKey","normalizedRequestKey","requestUrl","fetchSegmentPrefetchesUsingDynamicRequest","spawnedEntries","PPRRuntime","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","f","isRootRender","parseInt","isNaN","entries","flightDatas","i","writeSeedDataIntoCache","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","childSeedData","ownedEntry","possiblyNewEntry","newEntry","fetchPriority","shouldImmediatelyDecode","contentType","isFlightResponse","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","staticExportFilename","currentStrategy","newStrategy"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]}